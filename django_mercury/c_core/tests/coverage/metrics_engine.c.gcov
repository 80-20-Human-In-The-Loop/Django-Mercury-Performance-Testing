        -:    0:Source:metrics_engine.c
        -:    0:Source is newer than graph
        -:    1:/**
        -:    2: * @file metrics_engine.c
        -:    3: * @brief High-Performance Metrics Collection Engine
        -:    4: * 
        -:    5: * This library implements a high-performance metrics collection engine for the
        -:    6: * Mercury Performance Testing Framework. It replaces the Python-based metrics
        -:    7: * collection in monitor.py with optimized C implementations.
        -:    8: *
        -:    9: * Key Features:
        -:   10: * - RDTSC high-resolution timing with nanosecond precision
        -:   11: * - SIMD-accelerated threshold checking using SSE2/AVX
        -:   12: * - Native stack frame walking with libunwind
        -:   13: * - Cache-aligned data structures for optimal performance
        -:   14: * - Memory-efficient metrics storage and aggregation
        -:   15: *
        -:   16: * Performance Target: 67% reduction in metrics collection overhead
        -:   17: * Memory Usage: Cache-aligned structures for SIMD operations
        -:   18: */
        -:   19:
        -:   20:#include "common.h"
        -:   21:
        -:   22:// Platform-specific includes
        -:   23:#ifdef MERCURY_MACOS
        -:   24:#include <mach/task.h>
        -:   25:#include <mach/mach_init.h>
        -:   26:#endif
        -:   27:
        -:   28:// Conditional includes for stack unwinding
        -:   29:#ifdef MERCURY_LINUX
        -:   30:    // Check if libunwind is available
        -:   31:    #ifdef __has_include
        -:   32:        #if __has_include(<libunwind.h>)
        -:   33:            #define UNW_LOCAL_ONLY
        -:   34:            #include <libunwind.h>
        -:   35:            #include <dlfcn.h>
        -:   36:            #define MERCURY_HAS_LIBUNWIND 1
        -:   37:        #else
        -:   38:            #define MERCURY_HAS_LIBUNWIND 0
        -:   39:        #endif
        -:   40:    #else
        -:   41:        // Assume libunwind is available on Linux (fallback)
        -:   42:        #define UNW_LOCAL_ONLY
        -:   43:        #include <libunwind.h>
        -:   44:        #include <dlfcn.h>
        -:   45:        #define MERCURY_HAS_LIBUNWIND 1
        -:   46:    #endif
        -:   47:#else
        -:   48:    #define MERCURY_HAS_LIBUNWIND 0
        -:   49:#endif
        -:   50:
        -:   51:// === CONSTANTS ===
        -:   52:
        -:   53:#define MAX_ACTIVE_MONITORS 64
        -:   54:#define MAX_METRICS_HISTORY 1000
        -:   55:#define THRESHOLD_CACHE_SIZE 32
        -:   56:#define STACK_TRACE_MAX_DEPTH 16
        -:   57:
        -:   58:// Violation flags (bit field)
        -:   59:#define VIOLATION_RESPONSE_TIME  (1ULL << 0)
        -:   60:#define VIOLATION_MEMORY_USAGE   (1ULL << 1)
        -:   61:#define VIOLATION_QUERY_COUNT    (1ULL << 2)
        -:   62:#define VIOLATION_CACHE_RATIO    (1ULL << 3)
        -:   63:#define VIOLATION_N_PLUS_ONE     (1ULL << 4)
        -:   64:
        -:   65:// === DATA STRUCTURES ===
        -:   66:
        -:   67:/**
        -:   68: * @struct StackFrame
        -:   69: * @brief Stack frame information for debugging and profiling
        -:   70: * 
        -:   71: * @var StackFrame::address
        -:   72: * Memory address of the stack frame
        -:   73: * 
        -:   74: * @var StackFrame::function_name
        -:   75: * Name of the function (demangled if C++)
        -:   76: * 
        -:   77: * @var StackFrame::file_name
        -:   78: * Source file containing the function
        -:   79: * 
        -:   80: * @var StackFrame::line_number
        -:   81: * Line number in the source file
        -:   82: */
        -:   83:typedef struct {
        -:   84:    void* address;
        -:   85:    char function_name[128];
        -:   86:    char file_name[256];
        -:   87:    int line_number;
        -:   88:} StackFrame;
        -:   89:
        -:   90:/**
        -:   91: * @struct ThresholdConfig
        -:   92: * @brief Performance threshold configuration
        -:   93: * 
        -:   94: * SIMD-aligned structure for efficient threshold checking.
        -:   95: * 
        -:   96: * @var ThresholdConfig::response_time_ms
        -:   97: * Maximum allowed response time in milliseconds
        -:   98: * 
        -:   99: * @var ThresholdConfig::memory_usage_mb
        -:  100: * Maximum allowed memory usage in megabytes
        -:  101: * 
        -:  102: * @var ThresholdConfig::query_count_max
        -:  103: * Maximum number of database queries allowed
        -:  104: * 
        -:  105: * @var ThresholdConfig::cache_hit_ratio_min
        -:  106: * Minimum required cache hit ratio (0.0-1.0)
        -:  107: * 
        -:  108: * @var ThresholdConfig::flags
        -:  109: * Configuration flags for enabling/disabling checks
        -:  110: */
        -:  111:typedef struct MERCURY_ALIGNED(32) {
        -:  112:    double response_time_ms;
        -:  113:    double memory_usage_mb;
        -:  114:    uint32_t query_count_max;
        -:  115:    double cache_hit_ratio_min;
        -:  116:    uint32_t flags;  // Configuration flags
        -:  117:} ThresholdConfig;
        -:  118:
        -:  119:// Performance monitor session
        -:  120:typedef struct MERCURY_ALIGNED(64) {
        -:  121:    int64_t session_id;
        -:  122:    MercuryTimestamp start_time;
        -:  123:    MercuryTimestamp end_time;
        -:  124:    
        -:  125:    // Metrics
        -:  126:    uint32_t query_count_start;
        -:  127:    uint32_t query_count_end;
        -:  128:    uint32_t cache_hits;
        -:  129:    uint32_t cache_misses;
        -:  130:    size_t memory_start_bytes;
        -:  131:    size_t memory_peak_bytes;
        -:  132:    size_t memory_end_bytes;
        -:  133:    
        -:  134:    // Configuration
        -:  135:    ThresholdConfig thresholds;
        -:  136:    
        -:  137:    // Context information
        -:  138:    char operation_name[128];
        -:  139:    char operation_type[64];
        -:  140:    
        -:  141:    // Stack trace for error reporting
        -:  142:    StackFrame stack_trace[STACK_TRACE_MAX_DEPTH];
        -:  143:    int stack_depth;
        -:  144:    
        -:  145:    // Status
        -:  146:    uint64_t violation_flags;
        -:  147:    bool is_active;
        -:  148:    
        -:  149:} PerformanceMonitor;
        -:  150:
        -:  151:// Global metrics engine state
        -:  152:typedef struct {
        -:  153:    PerformanceMonitor* monitors;
        -:  154:    size_t monitor_count;
        -:  155:    size_t max_monitors;
        -:  156:    
        -:  157:    // SIMD-aligned threshold cache for fast checking
        -:  158:    ThresholdConfig* MERCURY_ALIGNED(32) threshold_cache;
        -:  159:    size_t cache_size;
        -:  160:    
        -:  161:    // Statistics
        -:  162:    _Atomic(uint64_t) total_sessions;
        -:  163:    _Atomic(uint64_t) violations_detected;
        -:  164:    _Atomic(uint64_t) timing_overhead_ns;  // Self-monitoring
        -:  165:    
        -:  166:    // Django hook counters
        -:  167:    _Atomic(uint64_t) global_query_count;
        -:  168:    _Atomic(uint64_t) global_cache_hits;
        -:  169:    _Atomic(uint64_t) global_cache_misses;
        -:  170:    
        -:  171:    // RDTSC calibration
        -:  172:    uint64_t rdtsc_frequency;
        -:  173:    bool rdtsc_available;
        -:  174:    
        -:  175:} MetricsEngine;
        -:  176:
        -:  177:// Global engine instance
        -:  178:static MetricsEngine* g_engine = NULL;
        -:  179:
        -:  180:// === TIMING UTILITIES ===
        -:  181:
        -:  182:// Get current memory usage (RSS) in bytes
     213*:  183:static size_t get_memory_usage(void) {
        -:  184:#ifdef MERCURY_LINUX
     213*:  185:    FILE* file = fopen("/proc/self/status", "r");
     213*:  186:    if (!file) return 0;
        -:  187:    
        -:  188:    char line[256];
     213*:  189:    size_t memory_kb = 0;
        -:  190:    
    4899*:  191:    while (fgets(line, sizeof(line), file)) {
    4686*:  192:        if (strncmp(line, "VmRSS:", 6) == 0) {
     213*:  193:            sscanf(line, "VmRSS: %zu kB", &memory_kb);
     213*:  194:            break;
        -:  195:        }
        -:  196:    }
        -:  197:    
     213*:  198:    fclose(file);
     213*:  199:    return memory_kb * 1024;  // Convert to bytes
        -:  200:    
        -:  201:#elif defined(MERCURY_MACOS)
        -:  202:    // macOS implementation using task_info
        -:  203:    struct task_basic_info info;
        -:  204:    mach_msg_type_number_t info_count = TASK_BASIC_INFO_COUNT;
        -:  205:    
        -:  206:    if (task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&info, &info_count) == KERN_SUCCESS) {
        -:  207:        return info.resident_size;
        -:  208:    }
        -:  209:    return 0;
        -:  210:    
        -:  211:#elif defined(MERCURY_WINDOWS)
        -:  212:    PROCESS_MEMORY_COUNTERS pmc;
        -:  213:    if (GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc))) {
        -:  214:        return pmc.WorkingSetSize;
        -:  215:    }
        -:  216:    return 0;
        -:  217:    
        -:  218:#else
        -:  219:    return 0;  // Fallback for unsupported platforms
        -:  220:#endif
        -:  221:}
------------------
get_memory_usage:
function get_memory_usage called 0 returned 0% blocks executed 0%
    #####:  183:static size_t get_memory_usage(void) {
        -:  184:#ifdef MERCURY_LINUX
    #####:  185:    FILE* file = fopen("/proc/self/status", "r");
call    0 never executed
    #####:  186:    if (!file) return 0;
branch  0 never executed
branch  1 never executed
        -:  187:    
        -:  188:    char line[256];
    #####:  189:    size_t memory_kb = 0;
        -:  190:    
    #####:  191:    while (fgets(line, sizeof(line), file)) {
branch  0 never executed
branch  1 never executed
    #####:  192:        if (strncmp(line, "VmRSS:", 6) == 0) {
branch  0 never executed
branch  1 never executed
    #####:  193:            sscanf(line, "VmRSS: %zu kB", &memory_kb);
    #####:  194:            break;
        -:  195:        }
        -:  196:    }
        -:  197:    
    #####:  198:    fclose(file);
call    0 never executed
    #####:  199:    return memory_kb * 1024;  // Convert to bytes
        -:  200:    
        -:  201:#elif defined(MERCURY_MACOS)
        -:  202:    // macOS implementation using task_info
        -:  203:    struct task_basic_info info;
        -:  204:    mach_msg_type_number_t info_count = TASK_BASIC_INFO_COUNT;
        -:  205:    
        -:  206:    if (task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&info, &info_count) == KERN_SUCCESS) {
        -:  207:        return info.resident_size;
        -:  208:    }
        -:  209:    return 0;
        -:  210:    
        -:  211:#elif defined(MERCURY_WINDOWS)
        -:  212:    PROCESS_MEMORY_COUNTERS pmc;
        -:  213:    if (GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc))) {
        -:  214:        return pmc.WorkingSetSize;
        -:  215:    }
        -:  216:    return 0;
        -:  217:    
        -:  218:#else
        -:  219:    return 0;  // Fallback for unsupported platforms
        -:  220:#endif
        -:  221:}
------------------
get_memory_usage:
function get_memory_usage called 213 returned 100% blocks executed 100%
      213:  183:static size_t get_memory_usage(void) {
        -:  184:#ifdef MERCURY_LINUX
      213:  185:    FILE* file = fopen("/proc/self/status", "r");
call    0 returned 100%
      213:  186:    if (!file) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  187:    
        -:  188:    char line[256];
      213:  189:    size_t memory_kb = 0;
        -:  190:    
     4899:  191:    while (fgets(line, sizeof(line), file)) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
     4686:  192:        if (strncmp(line, "VmRSS:", 6) == 0) {
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
      213:  193:            sscanf(line, "VmRSS: %zu kB", &memory_kb);
      213:  194:            break;
        -:  195:        }
        -:  196:    }
        -:  197:    
      213:  198:    fclose(file);
call    0 returned 100%
      213:  199:    return memory_kb * 1024;  // Convert to bytes
        -:  200:    
        -:  201:#elif defined(MERCURY_MACOS)
        -:  202:    // macOS implementation using task_info
        -:  203:    struct task_basic_info info;
        -:  204:    mach_msg_type_number_t info_count = TASK_BASIC_INFO_COUNT;
        -:  205:    
        -:  206:    if (task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&info, &info_count) == KERN_SUCCESS) {
        -:  207:        return info.resident_size;
        -:  208:    }
        -:  209:    return 0;
        -:  210:    
        -:  211:#elif defined(MERCURY_WINDOWS)
        -:  212:    PROCESS_MEMORY_COUNTERS pmc;
        -:  213:    if (GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc))) {
        -:  214:        return pmc.WorkingSetSize;
        -:  215:    }
        -:  216:    return 0;
        -:  217:    
        -:  218:#else
        -:  219:    return 0;  // Fallback for unsupported platforms
        -:  220:#endif
        -:  221:}
------------------
        -:  222:
        -:  223:// Capture stack trace for error reporting
     120*:  224:static int capture_stack_trace(StackFrame* frames, int max_frames) {
        -:  225:    int frame_count = 0;
        -:  226:    
        -:  227:#if defined(MERCURY_LINUX) && MERCURY_HAS_LIBUNWIND
        -:  228:    unw_cursor_t cursor;
        -:  229:    unw_context_t context;
        -:  230:    
     120*:  231:    if (unw_getcontext(&context) != 0) {
        -:  232:        return 0;
        -:  233:    }
        -:  234:    
     120*:  235:    if (unw_init_local(&cursor, &context) != 0) {
        -:  236:        return 0;
        -:  237:    }
        -:  238:    
     745*:  239:    while (frame_count < max_frames && unw_step(&cursor) > 0) {
     625*:  240:        StackFrame* frame = &frames[frame_count];
        -:  241:        
        -:  242:        // Get instruction pointer
        -:  243:        unw_word_t ip;
     625*:  244:        if (unw_get_reg(&cursor, UNW_REG_IP, &ip) != 0) {
        -:  245:            break;
        -:  246:        }
     625*:  247:        frame->address = (void*)ip;
        -:  248:        
        -:  249:        // Get function name
        -:  250:        char func_name[128];
        -:  251:        unw_word_t offset;
     625*:  252:        if (unw_get_proc_name(&cursor, func_name, sizeof(func_name), &offset) == 0) {
     625*:  253:            strncpy(frame->function_name, func_name, sizeof(frame->function_name) - 1);
     625*:  254:            frame->function_name[sizeof(frame->function_name) - 1] = '\0';
        -:  255:        } else {
    #####:  256:            strcpy(frame->function_name, "<unknown>");
        -:  257:        }
        -:  258:        
        -:  259:        // Get file and line info using dladdr
        -:  260:        Dl_info dl_info;
     625*:  261:        if (dladdr(frame->address, &dl_info) && dl_info.dli_fname) {
     625*:  262:            strncpy(frame->file_name, dl_info.dli_fname, sizeof(frame->file_name) - 1);
     625*:  263:            frame->file_name[sizeof(frame->file_name) - 1] = '\0';
        -:  264:        } else {
    #####:  265:            strcpy(frame->file_name, "<unknown>");
        -:  266:        }
        -:  267:        
     625*:  268:        frame->line_number = 0;  // Line numbers require debug info
     625*:  269:        frame_count++;
        -:  270:    }
        -:  271:#else
        -:  272:    // Fallback: Use backtrace if available, or create minimal stack info
        -:  273:    if (max_frames > 0 && frames) {
        -:  274:        // Create a minimal stack frame entry
        -:  275:        StackFrame* frame = &frames[0];
        -:  276:        strcpy(frame->function_name, "<capture_stack_trace>");
        -:  277:        strcpy(frame->file_name, "metrics_engine.c");
        -:  278:        frame->address = (void*)capture_stack_trace;
        -:  279:        frame->line_number = __LINE__;
        -:  280:        frame_count = 1;
        -:  281:    }
        -:  282:#endif
        -:  283:    
        -:  284:    return frame_count;
        -:  285:}
------------------
capture_stack_trace:
function capture_stack_trace called 0 returned 0% blocks executed 0%
    #####:  224:static int capture_stack_trace(StackFrame* frames, int max_frames) {
        -:  225:    int frame_count = 0;
        -:  226:    
        -:  227:#if defined(MERCURY_LINUX) && MERCURY_HAS_LIBUNWIND
        -:  228:    unw_cursor_t cursor;
        -:  229:    unw_context_t context;
        -:  230:    
    #####:  231:    if (unw_getcontext(&context) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  232:        return 0;
        -:  233:    }
        -:  234:    
    #####:  235:    if (unw_init_local(&cursor, &context) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  236:        return 0;
        -:  237:    }
        -:  238:    
    #####:  239:    while (frame_count < max_frames && unw_step(&cursor) > 0) {
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  240:        StackFrame* frame = &frames[frame_count];
        -:  241:        
        -:  242:        // Get instruction pointer
        -:  243:        unw_word_t ip;
    #####:  244:        if (unw_get_reg(&cursor, UNW_REG_IP, &ip) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  245:            break;
        -:  246:        }
    #####:  247:        frame->address = (void*)ip;
        -:  248:        
        -:  249:        // Get function name
        -:  250:        char func_name[128];
        -:  251:        unw_word_t offset;
    #####:  252:        if (unw_get_proc_name(&cursor, func_name, sizeof(func_name), &offset) == 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  253:            strncpy(frame->function_name, func_name, sizeof(frame->function_name) - 1);
    #####:  254:            frame->function_name[sizeof(frame->function_name) - 1] = '\0';
        -:  255:        } else {
    #####:  256:            strcpy(frame->function_name, "<unknown>");
        -:  257:        }
        -:  258:        
        -:  259:        // Get file and line info using dladdr
        -:  260:        Dl_info dl_info;
    #####:  261:        if (dladdr(frame->address, &dl_info) && dl_info.dli_fname) {
call    0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
    #####:  262:            strncpy(frame->file_name, dl_info.dli_fname, sizeof(frame->file_name) - 1);
    #####:  263:            frame->file_name[sizeof(frame->file_name) - 1] = '\0';
        -:  264:        } else {
    #####:  265:            strcpy(frame->file_name, "<unknown>");
        -:  266:        }
        -:  267:        
    #####:  268:        frame->line_number = 0;  // Line numbers require debug info
    #####:  269:        frame_count++;
        -:  270:    }
        -:  271:#else
        -:  272:    // Fallback: Use backtrace if available, or create minimal stack info
        -:  273:    if (max_frames > 0 && frames) {
        -:  274:        // Create a minimal stack frame entry
        -:  275:        StackFrame* frame = &frames[0];
        -:  276:        strcpy(frame->function_name, "<capture_stack_trace>");
        -:  277:        strcpy(frame->file_name, "metrics_engine.c");
        -:  278:        frame->address = (void*)capture_stack_trace;
        -:  279:        frame->line_number = __LINE__;
        -:  280:        frame_count = 1;
        -:  281:    }
        -:  282:#endif
        -:  283:    
        -:  284:    return frame_count;
        -:  285:}
------------------
capture_stack_trace:
function capture_stack_trace called 120 returned 100% blocks executed 86%
      120:  224:static int capture_stack_trace(StackFrame* frames, int max_frames) {
        -:  225:    int frame_count = 0;
        -:  226:    
        -:  227:#if defined(MERCURY_LINUX) && MERCURY_HAS_LIBUNWIND
        -:  228:    unw_cursor_t cursor;
        -:  229:    unw_context_t context;
        -:  230:    
      120:  231:    if (unw_getcontext(&context) != 0) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  232:        return 0;
        -:  233:    }
        -:  234:    
      120:  235:    if (unw_init_local(&cursor, &context) != 0) {
call    0 returned 100%
branch  1 taken 100%
branch  2 taken 0%
        -:  236:        return 0;
        -:  237:    }
        -:  238:    
      745:  239:    while (frame_count < max_frames && unw_step(&cursor) > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
branch  3 taken 84%
branch  4 taken 16% (fallthrough)
      625:  240:        StackFrame* frame = &frames[frame_count];
        -:  241:        
        -:  242:        // Get instruction pointer
        -:  243:        unw_word_t ip;
      625:  244:        if (unw_get_reg(&cursor, UNW_REG_IP, &ip) != 0) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  245:            break;
        -:  246:        }
      625:  247:        frame->address = (void*)ip;
        -:  248:        
        -:  249:        // Get function name
        -:  250:        char func_name[128];
        -:  251:        unw_word_t offset;
      625:  252:        if (unw_get_proc_name(&cursor, func_name, sizeof(func_name), &offset) == 0) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
      625:  253:            strncpy(frame->function_name, func_name, sizeof(frame->function_name) - 1);
      625:  254:            frame->function_name[sizeof(frame->function_name) - 1] = '\0';
        -:  255:        } else {
    #####:  256:            strcpy(frame->function_name, "<unknown>");
        -:  257:        }
        -:  258:        
        -:  259:        // Get file and line info using dladdr
        -:  260:        Dl_info dl_info;
      625:  261:        if (dladdr(frame->address, &dl_info) && dl_info.dli_fname) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
branch  4 taken 0%
      625:  262:            strncpy(frame->file_name, dl_info.dli_fname, sizeof(frame->file_name) - 1);
      625:  263:            frame->file_name[sizeof(frame->file_name) - 1] = '\0';
        -:  264:        } else {
    #####:  265:            strcpy(frame->file_name, "<unknown>");
        -:  266:        }
        -:  267:        
      625:  268:        frame->line_number = 0;  // Line numbers require debug info
      625:  269:        frame_count++;
        -:  270:    }
        -:  271:#else
        -:  272:    // Fallback: Use backtrace if available, or create minimal stack info
        -:  273:    if (max_frames > 0 && frames) {
        -:  274:        // Create a minimal stack frame entry
        -:  275:        StackFrame* frame = &frames[0];
        -:  276:        strcpy(frame->function_name, "<capture_stack_trace>");
        -:  277:        strcpy(frame->file_name, "metrics_engine.c");
        -:  278:        frame->address = (void*)capture_stack_trace;
        -:  279:        frame->line_number = __LINE__;
        -:  280:        frame_count = 1;
        -:  281:    }
        -:  282:#endif
        -:  283:    
        -:  284:    return frame_count;
        -:  285:}
------------------
        -:  286:
        -:  287:// === SIMD THRESHOLD CHECKING ===
        -:  288:
        -:  289:#ifdef USE_SIMD
      93*:  290:static void check_thresholds_simd_impl(const PerformanceMonitor* monitors, size_t count,
        -:  291:                                       uint64_t* violations) {
        -:  292:    #ifdef MERCURY_X86_64
        -:  293:        // Process 4 monitors at a time using AVX
      93*:  294:        size_t simd_count = count & ~3UL;  // Round down to multiple of 4
        -:  295:        
      93*:  296:        for (size_t i = 0; i < simd_count; i += 4) {
        -:  297:            // Load response time thresholds
        -:  298:            __m256d response_thresholds = _mm256_set_pd(
    #####:  299:                monitors[i+3].thresholds.response_time_ms,
    #####:  300:                monitors[i+2].thresholds.response_time_ms,
    #####:  301:                monitors[i+1].thresholds.response_time_ms,
    #####:  302:                monitors[i+0].thresholds.response_time_ms
        -:  303:            );
        -:  304:            
        -:  305:            // Calculate actual response times
    #####:  306:            __m256d response_times = _mm256_set_pd(
    #####:  307:                mercury_ns_to_ms(monitors[i+3].end_time.nanoseconds - monitors[i+3].start_time.nanoseconds),
    #####:  308:                mercury_ns_to_ms(monitors[i+2].end_time.nanoseconds - monitors[i+2].start_time.nanoseconds),
    #####:  309:                mercury_ns_to_ms(monitors[i+1].end_time.nanoseconds - monitors[i+1].start_time.nanoseconds),
    #####:  310:                mercury_ns_to_ms(monitors[i+0].end_time.nanoseconds - monitors[i+0].start_time.nanoseconds)
        -:  311:            );
        -:  312:            
        -:  313:            // Compare response times
        -:  314:            __m256d response_violations = _mm256_cmp_pd(response_times, response_thresholds, _CMP_GT_OQ);
        -:  315:            int response_mask = _mm256_movemask_pd(response_violations);
        -:  316:            
        -:  317:            // Load memory thresholds
        -:  318:            __m256d memory_thresholds = _mm256_set_pd(
    #####:  319:                monitors[i+3].thresholds.memory_usage_mb,
    #####:  320:                monitors[i+2].thresholds.memory_usage_mb,
    #####:  321:                monitors[i+1].thresholds.memory_usage_mb,
    #####:  322:                monitors[i+0].thresholds.memory_usage_mb
        -:  323:            );
        -:  324:            
        -:  325:            // Calculate actual memory usage
    #####:  326:            __m256d memory_usage = _mm256_set_pd(
    #####:  327:                (double)monitors[i+3].memory_peak_bytes / (1024.0 * 1024.0),
    #####:  328:                (double)monitors[i+2].memory_peak_bytes / (1024.0 * 1024.0),
    #####:  329:                (double)monitors[i+1].memory_peak_bytes / (1024.0 * 1024.0),
    #####:  330:                (double)monitors[i+0].memory_peak_bytes / (1024.0 * 1024.0)
        -:  331:            );
        -:  332:            
        -:  333:            // Compare memory usage
        -:  334:            __m256d memory_violations = _mm256_cmp_pd(memory_usage, memory_thresholds, _CMP_GT_OQ);
        -:  335:            int memory_mask = _mm256_movemask_pd(memory_violations);
        -:  336:            
        -:  337:            // Set violation flags
    #####:  338:            for (int j = 0; j < 4; j++) {
    #####:  339:                if (response_mask & (1 << j)) {
    #####:  340:                    violations[i + j] |= VIOLATION_RESPONSE_TIME;
        -:  341:                }
    #####:  342:                if (memory_mask & (1 << j)) {
    #####:  343:                    violations[i + j] |= VIOLATION_MEMORY_USAGE;
        -:  344:                }
        -:  345:            }
        -:  346:        }
        -:  347:        
        -:  348:        // Handle remaining monitors with scalar operations
     186*:  349:        for (size_t i = simd_count; i < count; i++) {
      93*:  350:            const PerformanceMonitor* monitor = &monitors[i];
      93*:  351:            double response_time = mercury_ns_to_ms(monitor->end_time.nanoseconds - monitor->start_time.nanoseconds);
      93*:  352:            double memory_mb = (double)monitor->memory_peak_bytes / (1024.0 * 1024.0);
        -:  353:            
      93*:  354:            if (response_time > monitor->thresholds.response_time_ms) {
    #####:  355:                violations[i] |= VIOLATION_RESPONSE_TIME;
        -:  356:            }
      93*:  357:            if (memory_mb > monitor->thresholds.memory_usage_mb) {
    #####:  358:                violations[i] |= VIOLATION_MEMORY_USAGE;
        -:  359:            }
        -:  360:        }
        -:  361:    #endif
      93*:  362:}
------------------
check_thresholds_simd_impl:
function check_thresholds_simd_impl called 0 returned 0% blocks executed 0%
    #####:  290:static void check_thresholds_simd_impl(const PerformanceMonitor* monitors, size_t count,
        -:  291:                                       uint64_t* violations) {
        -:  292:    #ifdef MERCURY_X86_64
        -:  293:        // Process 4 monitors at a time using AVX
    #####:  294:        size_t simd_count = count & ~3UL;  // Round down to multiple of 4
        -:  295:        
    #####:  296:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  297:            // Load response time thresholds
        -:  298:            __m256d response_thresholds = _mm256_set_pd(
    #####:  299:                monitors[i+3].thresholds.response_time_ms,
    #####:  300:                monitors[i+2].thresholds.response_time_ms,
    #####:  301:                monitors[i+1].thresholds.response_time_ms,
    #####:  302:                monitors[i+0].thresholds.response_time_ms
        -:  303:            );
        -:  304:            
        -:  305:            // Calculate actual response times
    #####:  306:            __m256d response_times = _mm256_set_pd(
    #####:  307:                mercury_ns_to_ms(monitors[i+3].end_time.nanoseconds - monitors[i+3].start_time.nanoseconds),
    #####:  308:                mercury_ns_to_ms(monitors[i+2].end_time.nanoseconds - monitors[i+2].start_time.nanoseconds),
    #####:  309:                mercury_ns_to_ms(monitors[i+1].end_time.nanoseconds - monitors[i+1].start_time.nanoseconds),
    #####:  310:                mercury_ns_to_ms(monitors[i+0].end_time.nanoseconds - monitors[i+0].start_time.nanoseconds)
        -:  311:            );
        -:  312:            
        -:  313:            // Compare response times
        -:  314:            __m256d response_violations = _mm256_cmp_pd(response_times, response_thresholds, _CMP_GT_OQ);
        -:  315:            int response_mask = _mm256_movemask_pd(response_violations);
        -:  316:            
        -:  317:            // Load memory thresholds
        -:  318:            __m256d memory_thresholds = _mm256_set_pd(
    #####:  319:                monitors[i+3].thresholds.memory_usage_mb,
    #####:  320:                monitors[i+2].thresholds.memory_usage_mb,
    #####:  321:                monitors[i+1].thresholds.memory_usage_mb,
    #####:  322:                monitors[i+0].thresholds.memory_usage_mb
        -:  323:            );
        -:  324:            
        -:  325:            // Calculate actual memory usage
    #####:  326:            __m256d memory_usage = _mm256_set_pd(
    #####:  327:                (double)monitors[i+3].memory_peak_bytes / (1024.0 * 1024.0),
    #####:  328:                (double)monitors[i+2].memory_peak_bytes / (1024.0 * 1024.0),
    #####:  329:                (double)monitors[i+1].memory_peak_bytes / (1024.0 * 1024.0),
    #####:  330:                (double)monitors[i+0].memory_peak_bytes / (1024.0 * 1024.0)
        -:  331:            );
        -:  332:            
        -:  333:            // Compare memory usage
        -:  334:            __m256d memory_violations = _mm256_cmp_pd(memory_usage, memory_thresholds, _CMP_GT_OQ);
        -:  335:            int memory_mask = _mm256_movemask_pd(memory_violations);
        -:  336:            
        -:  337:            // Set violation flags
    #####:  338:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  339:                if (response_mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  340:                    violations[i + j] |= VIOLATION_RESPONSE_TIME;
        -:  341:                }
    #####:  342:                if (memory_mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  343:                    violations[i + j] |= VIOLATION_MEMORY_USAGE;
        -:  344:                }
        -:  345:            }
        -:  346:        }
        -:  347:        
        -:  348:        // Handle remaining monitors with scalar operations
    #####:  349:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  350:            const PerformanceMonitor* monitor = &monitors[i];
    #####:  351:            double response_time = mercury_ns_to_ms(monitor->end_time.nanoseconds - monitor->start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  352:            double memory_mb = (double)monitor->memory_peak_bytes / (1024.0 * 1024.0);
        -:  353:            
    #####:  354:            if (response_time > monitor->thresholds.response_time_ms) {
branch  0 never executed
branch  1 never executed
    #####:  355:                violations[i] |= VIOLATION_RESPONSE_TIME;
        -:  356:            }
    #####:  357:            if (memory_mb > monitor->thresholds.memory_usage_mb) {
branch  0 never executed
branch  1 never executed
    #####:  358:                violations[i] |= VIOLATION_MEMORY_USAGE;
        -:  359:            }
        -:  360:        }
        -:  361:    #endif
    #####:  362:}
------------------
check_thresholds_simd_impl:
function check_thresholds_simd_impl called 93 returned 100% blocks executed 41%
       93:  290:static void check_thresholds_simd_impl(const PerformanceMonitor* monitors, size_t count,
        -:  291:                                       uint64_t* violations) {
        -:  292:    #ifdef MERCURY_X86_64
        -:  293:        // Process 4 monitors at a time using AVX
       93:  294:        size_t simd_count = count & ~3UL;  // Round down to multiple of 4
        -:  295:        
      93*:  296:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 taken 0%
branch  1 taken 100%
        -:  297:            // Load response time thresholds
        -:  298:            __m256d response_thresholds = _mm256_set_pd(
    #####:  299:                monitors[i+3].thresholds.response_time_ms,
    #####:  300:                monitors[i+2].thresholds.response_time_ms,
    #####:  301:                monitors[i+1].thresholds.response_time_ms,
    #####:  302:                monitors[i+0].thresholds.response_time_ms
        -:  303:            );
        -:  304:            
        -:  305:            // Calculate actual response times
    #####:  306:            __m256d response_times = _mm256_set_pd(
    #####:  307:                mercury_ns_to_ms(monitors[i+3].end_time.nanoseconds - monitors[i+3].start_time.nanoseconds),
    #####:  308:                mercury_ns_to_ms(monitors[i+2].end_time.nanoseconds - monitors[i+2].start_time.nanoseconds),
    #####:  309:                mercury_ns_to_ms(monitors[i+1].end_time.nanoseconds - monitors[i+1].start_time.nanoseconds),
    #####:  310:                mercury_ns_to_ms(monitors[i+0].end_time.nanoseconds - monitors[i+0].start_time.nanoseconds)
        -:  311:            );
        -:  312:            
        -:  313:            // Compare response times
        -:  314:            __m256d response_violations = _mm256_cmp_pd(response_times, response_thresholds, _CMP_GT_OQ);
        -:  315:            int response_mask = _mm256_movemask_pd(response_violations);
        -:  316:            
        -:  317:            // Load memory thresholds
        -:  318:            __m256d memory_thresholds = _mm256_set_pd(
    #####:  319:                monitors[i+3].thresholds.memory_usage_mb,
    #####:  320:                monitors[i+2].thresholds.memory_usage_mb,
    #####:  321:                monitors[i+1].thresholds.memory_usage_mb,
    #####:  322:                monitors[i+0].thresholds.memory_usage_mb
        -:  323:            );
        -:  324:            
        -:  325:            // Calculate actual memory usage
    #####:  326:            __m256d memory_usage = _mm256_set_pd(
    #####:  327:                (double)monitors[i+3].memory_peak_bytes / (1024.0 * 1024.0),
    #####:  328:                (double)monitors[i+2].memory_peak_bytes / (1024.0 * 1024.0),
    #####:  329:                (double)monitors[i+1].memory_peak_bytes / (1024.0 * 1024.0),
    #####:  330:                (double)monitors[i+0].memory_peak_bytes / (1024.0 * 1024.0)
        -:  331:            );
        -:  332:            
        -:  333:            // Compare memory usage
        -:  334:            __m256d memory_violations = _mm256_cmp_pd(memory_usage, memory_thresholds, _CMP_GT_OQ);
        -:  335:            int memory_mask = _mm256_movemask_pd(memory_violations);
        -:  336:            
        -:  337:            // Set violation flags
    #####:  338:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  339:                if (response_mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  340:                    violations[i + j] |= VIOLATION_RESPONSE_TIME;
        -:  341:                }
    #####:  342:                if (memory_mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  343:                    violations[i + j] |= VIOLATION_MEMORY_USAGE;
        -:  344:                }
        -:  345:            }
        -:  346:        }
        -:  347:        
        -:  348:        // Handle remaining monitors with scalar operations
      186:  349:        for (size_t i = simd_count; i < count; i++) {
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
       93:  350:            const PerformanceMonitor* monitor = &monitors[i];
       93:  351:            double response_time = mercury_ns_to_ms(monitor->end_time.nanoseconds - monitor->start_time.nanoseconds);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       93:  352:            double memory_mb = (double)monitor->memory_peak_bytes / (1024.0 * 1024.0);
        -:  353:            
       93:  354:            if (response_time > monitor->thresholds.response_time_ms) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  355:                violations[i] |= VIOLATION_RESPONSE_TIME;
        -:  356:            }
       93:  357:            if (memory_mb > monitor->thresholds.memory_usage_mb) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  358:                violations[i] |= VIOLATION_MEMORY_USAGE;
        -:  359:            }
        -:  360:        }
        -:  361:    #endif
       93:  362:}
------------------
        -:  363:#endif
        -:  364:
        -:  365:// Scalar threshold checking (fallback)
        -:  366:#ifndef USE_SIMD
        -:  367:static void check_thresholds_scalar(const PerformanceMonitor* monitors, size_t count,
        -:  368:                                   uint64_t* violations) {
        -:  369:    for (size_t i = 0; i < count; i++) {
        -:  370:        const PerformanceMonitor* monitor = &monitors[i];
        -:  371:        
        -:  372:        // Check response time
        -:  373:        double response_time = mercury_ns_to_ms(monitor->end_time.nanoseconds - monitor->start_time.nanoseconds);
        -:  374:        if (response_time > monitor->thresholds.response_time_ms) {
        -:  375:            violations[i] |= VIOLATION_RESPONSE_TIME;
        -:  376:        }
        -:  377:        
        -:  378:        // Check memory usage
        -:  379:        double memory_mb = (double)monitor->memory_peak_bytes / (1024.0 * 1024.0);
        -:  380:        if (memory_mb > monitor->thresholds.memory_usage_mb) {
        -:  381:            violations[i] |= VIOLATION_MEMORY_USAGE;
        -:  382:        }
        -:  383:        
        -:  384:        // Check query count
        -:  385:        uint32_t query_count = monitor->query_count_end - monitor->query_count_start;
        -:  386:        if (query_count > monitor->thresholds.query_count_max) {
        -:  387:            violations[i] |= VIOLATION_QUERY_COUNT;
        -:  388:        }
        -:  389:        
        -:  390:        // Check cache hit ratio
        -:  391:        uint32_t total_cache_ops = monitor->cache_hits + monitor->cache_misses;
        -:  392:        if (total_cache_ops > 0) {
        -:  393:            double hit_ratio = (double)monitor->cache_hits / (double)total_cache_ops;
        -:  394:            if (hit_ratio < monitor->thresholds.cache_hit_ratio_min) {
        -:  395:                violations[i] |= VIOLATION_CACHE_RATIO;
        -:  396:            }
        -:  397:        }
        -:  398:    }
        -:  399:}
        -:  400:#endif
        -:  401:
        -:  402:// === ENGINE INITIALIZATION ===
        -:  403:
       1*:  404:static MercuryError init_metrics_engine(void) {
       1*:  405:    if (g_engine) {
        -:  406:        return MERCURY_SUCCESS;  // Already initialized
        -:  407:    }
        -:  408:    
       1*:  409:    g_engine = mercury_aligned_alloc(sizeof(MetricsEngine), 64);
       1*:  410:    if (!g_engine) {
    #####:  411:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate metrics engine");
    #####:  412:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  413:    }
        -:  414:    
        -:  415:    // Initialize monitor pool
       1*:  416:    g_engine->max_monitors = MAX_ACTIVE_MONITORS;
       1*:  417:    g_engine->monitors = mercury_aligned_alloc(g_engine->max_monitors * sizeof(PerformanceMonitor), 64);
       1*:  418:    if (!g_engine->monitors) {
    #####:  419:        mercury_aligned_free(g_engine);
    #####:  420:        g_engine = NULL;
    #####:  421:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate monitor pool");
    #####:  422:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  423:    }
        -:  424:    
       1*:  425:    g_engine->monitor_count = 0;
        -:  426:    
        -:  427:    // Initialize SIMD-aligned threshold cache
       1*:  428:    g_engine->cache_size = THRESHOLD_CACHE_SIZE;
       1*:  429:    g_engine->threshold_cache = mercury_aligned_alloc(g_engine->cache_size * sizeof(ThresholdConfig), 32);
       1*:  430:    if (!g_engine->threshold_cache) {
    #####:  431:        mercury_aligned_free(g_engine->monitors);
    #####:  432:        mercury_aligned_free(g_engine);
    #####:  433:        g_engine = NULL;
    #####:  434:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate threshold cache");
    #####:  435:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  436:    }
        -:  437:    
        -:  438:    // Initialize statistics
       1*:  439:    atomic_store(&g_engine->total_sessions, 0);
       1*:  440:    atomic_store(&g_engine->violations_detected, 0);
       1*:  441:    atomic_store(&g_engine->timing_overhead_ns, 0);
        -:  442:    
        -:  443:    // Initialize Django hook counters
       1*:  444:    atomic_store(&g_engine->global_query_count, 0);
       1*:  445:    atomic_store(&g_engine->global_cache_hits, 0);
       1*:  446:    atomic_store(&g_engine->global_cache_misses, 0);
        -:  447:    
        -:  448:    // Initialize timing
        -:  449:    #ifdef MERCURY_X86_64
       1*:  450:    mercury_calibrate_rdtsc();
       1*:  451:    g_engine->rdtsc_frequency = mercury_rdtsc_frequency;
       1*:  452:    g_engine->rdtsc_available = (g_engine->rdtsc_frequency > 0);
        -:  453:    #else
        -:  454:    g_engine->rdtsc_available = false;
        -:  455:    #endif
        -:  456:    
        -:  457:    // Initialize all monitors as inactive
      65*:  458:    for (size_t i = 0; i < g_engine->max_monitors; i++) {
      64*:  459:        g_engine->monitors[i].is_active = false;
      64*:  460:        g_engine->monitors[i].session_id = -1;
        -:  461:    }
        -:  462:    
       1*:  463:    MERCURY_INFO("Metrics engine initialized with %zu monitor slots", g_engine->max_monitors);
        -:  464:    return MERCURY_SUCCESS;
        -:  465:}
------------------
init_metrics_engine:
function init_metrics_engine called 0 returned 0% blocks executed 0%
    #####:  404:static MercuryError init_metrics_engine(void) {
    #####:  405:    if (g_engine) {
branch  0 never executed
branch  1 never executed
        -:  406:        return MERCURY_SUCCESS;  // Already initialized
        -:  407:    }
        -:  408:    
    #####:  409:    g_engine = mercury_aligned_alloc(sizeof(MetricsEngine), 64);
call    0 never executed
    #####:  410:    if (!g_engine) {
branch  0 never executed
branch  1 never executed
    #####:  411:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate metrics engine");
    #####:  412:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  413:    }
        -:  414:    
        -:  415:    // Initialize monitor pool
    #####:  416:    g_engine->max_monitors = MAX_ACTIVE_MONITORS;
    #####:  417:    g_engine->monitors = mercury_aligned_alloc(g_engine->max_monitors * sizeof(PerformanceMonitor), 64);
call    0 never executed
    #####:  418:    if (!g_engine->monitors) {
branch  0 never executed
branch  1 never executed
    #####:  419:        mercury_aligned_free(g_engine);
call    0 never executed
    #####:  420:        g_engine = NULL;
    #####:  421:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate monitor pool");
    #####:  422:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  423:    }
        -:  424:    
    #####:  425:    g_engine->monitor_count = 0;
        -:  426:    
        -:  427:    // Initialize SIMD-aligned threshold cache
    #####:  428:    g_engine->cache_size = THRESHOLD_CACHE_SIZE;
    #####:  429:    g_engine->threshold_cache = mercury_aligned_alloc(g_engine->cache_size * sizeof(ThresholdConfig), 32);
call    0 never executed
    #####:  430:    if (!g_engine->threshold_cache) {
branch  0 never executed
branch  1 never executed
    #####:  431:        mercury_aligned_free(g_engine->monitors);
call    0 never executed
    #####:  432:        mercury_aligned_free(g_engine);
call    0 never executed
    #####:  433:        g_engine = NULL;
    #####:  434:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate threshold cache");
    #####:  435:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  436:    }
        -:  437:    
        -:  438:    // Initialize statistics
    #####:  439:    atomic_store(&g_engine->total_sessions, 0);
    #####:  440:    atomic_store(&g_engine->violations_detected, 0);
    #####:  441:    atomic_store(&g_engine->timing_overhead_ns, 0);
        -:  442:    
        -:  443:    // Initialize Django hook counters
    #####:  444:    atomic_store(&g_engine->global_query_count, 0);
    #####:  445:    atomic_store(&g_engine->global_cache_hits, 0);
    #####:  446:    atomic_store(&g_engine->global_cache_misses, 0);
        -:  447:    
        -:  448:    // Initialize timing
        -:  449:    #ifdef MERCURY_X86_64
    #####:  450:    mercury_calibrate_rdtsc();
call    0 never executed
    #####:  451:    g_engine->rdtsc_frequency = mercury_rdtsc_frequency;
    #####:  452:    g_engine->rdtsc_available = (g_engine->rdtsc_frequency > 0);
        -:  453:    #else
        -:  454:    g_engine->rdtsc_available = false;
        -:  455:    #endif
        -:  456:    
        -:  457:    // Initialize all monitors as inactive
    #####:  458:    for (size_t i = 0; i < g_engine->max_monitors; i++) {
branch  0 never executed
branch  1 never executed
    #####:  459:        g_engine->monitors[i].is_active = false;
    #####:  460:        g_engine->monitors[i].session_id = -1;
        -:  461:    }
        -:  462:    
    #####:  463:    MERCURY_INFO("Metrics engine initialized with %zu monitor slots", g_engine->max_monitors);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  464:    return MERCURY_SUCCESS;
        -:  465:}
------------------
init_metrics_engine:
function init_metrics_engine called 1 returned 100% blocks executed 70%
        1:  404:static MercuryError init_metrics_engine(void) {
        1:  405:    if (g_engine) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  406:        return MERCURY_SUCCESS;  // Already initialized
        -:  407:    }
        -:  408:    
        1:  409:    g_engine = mercury_aligned_alloc(sizeof(MetricsEngine), 64);
call    0 returned 100%
        1:  410:    if (!g_engine) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  411:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate metrics engine");
    #####:  412:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  413:    }
        -:  414:    
        -:  415:    // Initialize monitor pool
        1:  416:    g_engine->max_monitors = MAX_ACTIVE_MONITORS;
        1:  417:    g_engine->monitors = mercury_aligned_alloc(g_engine->max_monitors * sizeof(PerformanceMonitor), 64);
call    0 returned 100%
        1:  418:    if (!g_engine->monitors) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  419:        mercury_aligned_free(g_engine);
call    0 never executed
    #####:  420:        g_engine = NULL;
    #####:  421:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate monitor pool");
    #####:  422:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  423:    }
        -:  424:    
        1:  425:    g_engine->monitor_count = 0;
        -:  426:    
        -:  427:    // Initialize SIMD-aligned threshold cache
        1:  428:    g_engine->cache_size = THRESHOLD_CACHE_SIZE;
        1:  429:    g_engine->threshold_cache = mercury_aligned_alloc(g_engine->cache_size * sizeof(ThresholdConfig), 32);
call    0 returned 100%
        1:  430:    if (!g_engine->threshold_cache) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  431:        mercury_aligned_free(g_engine->monitors);
call    0 never executed
    #####:  432:        mercury_aligned_free(g_engine);
call    0 never executed
    #####:  433:        g_engine = NULL;
    #####:  434:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate threshold cache");
    #####:  435:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  436:    }
        -:  437:    
        -:  438:    // Initialize statistics
        1:  439:    atomic_store(&g_engine->total_sessions, 0);
        1:  440:    atomic_store(&g_engine->violations_detected, 0);
        1:  441:    atomic_store(&g_engine->timing_overhead_ns, 0);
        -:  442:    
        -:  443:    // Initialize Django hook counters
        1:  444:    atomic_store(&g_engine->global_query_count, 0);
        1:  445:    atomic_store(&g_engine->global_cache_hits, 0);
        1:  446:    atomic_store(&g_engine->global_cache_misses, 0);
        -:  447:    
        -:  448:    // Initialize timing
        -:  449:    #ifdef MERCURY_X86_64
        1:  450:    mercury_calibrate_rdtsc();
call    0 returned 100%
        1:  451:    g_engine->rdtsc_frequency = mercury_rdtsc_frequency;
        1:  452:    g_engine->rdtsc_available = (g_engine->rdtsc_frequency > 0);
        -:  453:    #else
        -:  454:    g_engine->rdtsc_available = false;
        -:  455:    #endif
        -:  456:    
        -:  457:    // Initialize all monitors as inactive
       65:  458:    for (size_t i = 0; i < g_engine->max_monitors; i++) {
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
       64:  459:        g_engine->monitors[i].is_active = false;
       64:  460:        g_engine->monitors[i].session_id = -1;
        -:  461:    }
        -:  462:    
        1:  463:    MERCURY_INFO("Metrics engine initialized with %zu monitor slots", g_engine->max_monitors);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  464:    return MERCURY_SUCCESS;
        -:  465:}
------------------
        -:  466:
        2:  467:static void cleanup_metrics_engine(void) {
        2:  468:    if (!g_engine) return;
        -:  469:    
       1*:  470:    mercury_aligned_free(g_engine->threshold_cache);
       1*:  471:    mercury_aligned_free(g_engine->monitors);
       1*:  472:    mercury_aligned_free(g_engine);
       1*:  473:    g_engine = NULL;
        -:  474:    
       1*:  475:    MERCURY_INFO("Metrics engine cleaned up");
        -:  476:}
------------------
cleanup_metrics_engine:
function cleanup_metrics_engine called 1 returned 100% blocks executed 29%
        1:  467:static void cleanup_metrics_engine(void) {
        1:  468:    if (!g_engine) return;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  469:    
    #####:  470:    mercury_aligned_free(g_engine->threshold_cache);
call    0 never executed
    #####:  471:    mercury_aligned_free(g_engine->monitors);
call    0 never executed
    #####:  472:    mercury_aligned_free(g_engine);
call    0 never executed
    #####:  473:    g_engine = NULL;
        -:  474:    
    #####:  475:    MERCURY_INFO("Metrics engine cleaned up");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  476:}
------------------
cleanup_metrics_engine:
function cleanup_metrics_engine called 1 returned 100% blocks executed 100%
        1:  467:static void cleanup_metrics_engine(void) {
        1:  468:    if (!g_engine) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  469:    
        1:  470:    mercury_aligned_free(g_engine->threshold_cache);
call    0 returned 100%
        1:  471:    mercury_aligned_free(g_engine->monitors);
call    0 returned 100%
        1:  472:    mercury_aligned_free(g_engine);
call    0 returned 100%
        1:  473:    g_engine = NULL;
        -:  474:    
        1:  475:    MERCURY_INFO("Metrics engine cleaned up");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  476:}
------------------
        -:  477:
        -:  478:// === PUBLIC API FUNCTIONS ===
        -:  479:
        -:  480:// Start performance monitoring session
     158*:  481:int64_t start_performance_monitoring_enhanced(const char* operation_name, const char* operation_type) {
     158*:  482:    if (!operation_name || !operation_type) {
       2*:  483:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Operation name and type cannot be NULL");
       2*:  484:        return -1;
        -:  485:    }
        -:  486:    
        -:  487:    // Initialize engine if needed
     156*:  488:    if (!g_engine) {
       1*:  489:        if (init_metrics_engine() != MERCURY_SUCCESS) {
        -:  490:            return -1;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Find available monitor slot
        -:  495:    PerformanceMonitor* monitor = NULL;
        -:  496:    int64_t session_id = -1;
        -:  497:    
    4486*:  498:    for (size_t i = 0; i < g_engine->max_monitors; i++) {
    4450*:  499:        if (!g_engine->monitors[i].is_active) {
        -:  500:            monitor = &g_engine->monitors[i];
     120*:  501:            session_id = (int64_t)i;
     120*:  502:            break;
        -:  503:        }
        -:  504:    }
        -:  505:    
     156*:  506:    if (!monitor) {
      36*:  507:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "No available monitor slots");
      36*:  508:        return -1;
        -:  509:    }
        -:  510:    
        -:  511:    // Initialize monitor
     120*:  512:    monitor->session_id = session_id;
     120*:  513:    monitor->start_time = mercury_get_timestamp();
     120*:  514:    monitor->end_time = monitor->start_time;  // Will be updated on stop
        -:  515:    
        -:  516:    // Initialize metrics - capture baseline counters
     120*:  517:    monitor->query_count_start = (uint32_t)atomic_load(&g_engine->global_query_count);
     120*:  518:    monitor->query_count_end = 0;
     120*:  519:    monitor->cache_hits = 0;
     120*:  520:    monitor->cache_misses = 0;
     120*:  521:    monitor->memory_start_bytes = get_memory_usage();
     120*:  522:    monitor->memory_peak_bytes = monitor->memory_start_bytes;
     120*:  523:    monitor->memory_end_bytes = 0;
        -:  524:    
        -:  525:    // Set default thresholds
     120*:  526:    monitor->thresholds.response_time_ms = 1000.0;  // 1 second default
     120*:  527:    monitor->thresholds.memory_usage_mb = 200.0;    // 200MB default
     120*:  528:    monitor->thresholds.query_count_max = 50;       // 50 queries default
     120*:  529:    monitor->thresholds.cache_hit_ratio_min = 0.7;  // 70% cache hit ratio
     120*:  530:    monitor->thresholds.flags = 0;
        -:  531:    
        -:  532:    // Copy operation info
     120*:  533:    strncpy(monitor->operation_name, operation_name, sizeof(monitor->operation_name) - 1);
     120*:  534:    monitor->operation_name[sizeof(monitor->operation_name) - 1] = '\0';
     120*:  535:    strncpy(monitor->operation_type, operation_type, sizeof(monitor->operation_type) - 1);
     120*:  536:    monitor->operation_type[sizeof(monitor->operation_type) - 1] = '\0';
        -:  537:    
        -:  538:    // Capture stack trace for context
     120*:  539:    monitor->stack_depth = capture_stack_trace(monitor->stack_trace, STACK_TRACE_MAX_DEPTH);
        -:  540:    
        -:  541:    // Initialize status
     120*:  542:    monitor->violation_flags = 0;
     120*:  543:    monitor->is_active = true;
        -:  544:    
     120*:  545:    atomic_fetch_add(&g_engine->total_sessions, 1);
     120*:  546:    g_engine->monitor_count++;
        -:  547:    
     120*:  548:    return session_id;
        -:  549:}
------------------
start_performance_monitoring_enhanced:
function start_performance_monitoring_enhanced called 0 returned 0% blocks executed 0%
    #####:  481:int64_t start_performance_monitoring_enhanced(const char* operation_name, const char* operation_type) {
    #####:  482:    if (!operation_name || !operation_type) {
branch  0 never executed
branch  1 never executed
    #####:  483:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Operation name and type cannot be NULL");
    #####:  484:        return -1;
        -:  485:    }
        -:  486:    
        -:  487:    // Initialize engine if needed
    #####:  488:    if (!g_engine) {
branch  0 never executed
branch  1 never executed
    #####:  489:        if (init_metrics_engine() != MERCURY_SUCCESS) {
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  490:            return -1;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Find available monitor slot
        -:  495:    PerformanceMonitor* monitor = NULL;
        -:  496:    int64_t session_id = -1;
        -:  497:    
    #####:  498:    for (size_t i = 0; i < g_engine->max_monitors; i++) {
branch  0 never executed
branch  1 never executed
    #####:  499:        if (!g_engine->monitors[i].is_active) {
branch  0 never executed
branch  1 never executed
        -:  500:            monitor = &g_engine->monitors[i];
    #####:  501:            session_id = (int64_t)i;
    #####:  502:            break;
        -:  503:        }
        -:  504:    }
        -:  505:    
    #####:  506:    if (!monitor) {
branch  0 never executed
branch  1 never executed
    #####:  507:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "No available monitor slots");
    #####:  508:        return -1;
        -:  509:    }
        -:  510:    
        -:  511:    // Initialize monitor
    #####:  512:    monitor->session_id = session_id;
call    0 never executed
    #####:  513:    monitor->start_time = mercury_get_timestamp();
    #####:  514:    monitor->end_time = monitor->start_time;  // Will be updated on stop
        -:  515:    
        -:  516:    // Initialize metrics - capture baseline counters
    #####:  517:    monitor->query_count_start = (uint32_t)atomic_load(&g_engine->global_query_count);
    #####:  518:    monitor->query_count_end = 0;
    #####:  519:    monitor->cache_hits = 0;
    #####:  520:    monitor->cache_misses = 0;
    #####:  521:    monitor->memory_start_bytes = get_memory_usage();
call    0 never executed
    #####:  522:    monitor->memory_peak_bytes = monitor->memory_start_bytes;
    #####:  523:    monitor->memory_end_bytes = 0;
        -:  524:    
        -:  525:    // Set default thresholds
    #####:  526:    monitor->thresholds.response_time_ms = 1000.0;  // 1 second default
    #####:  527:    monitor->thresholds.memory_usage_mb = 200.0;    // 200MB default
    #####:  528:    monitor->thresholds.query_count_max = 50;       // 50 queries default
    #####:  529:    monitor->thresholds.cache_hit_ratio_min = 0.7;  // 70% cache hit ratio
    #####:  530:    monitor->thresholds.flags = 0;
        -:  531:    
        -:  532:    // Copy operation info
    #####:  533:    strncpy(monitor->operation_name, operation_name, sizeof(monitor->operation_name) - 1);
call    0 never executed
    #####:  534:    monitor->operation_name[sizeof(monitor->operation_name) - 1] = '\0';
    #####:  535:    strncpy(monitor->operation_type, operation_type, sizeof(monitor->operation_type) - 1);
    #####:  536:    monitor->operation_type[sizeof(monitor->operation_type) - 1] = '\0';
        -:  537:    
        -:  538:    // Capture stack trace for context
    #####:  539:    monitor->stack_depth = capture_stack_trace(monitor->stack_trace, STACK_TRACE_MAX_DEPTH);
call    0 never executed
        -:  540:    
        -:  541:    // Initialize status
    #####:  542:    monitor->violation_flags = 0;
    #####:  543:    monitor->is_active = true;
        -:  544:    
    #####:  545:    atomic_fetch_add(&g_engine->total_sessions, 1);
    #####:  546:    g_engine->monitor_count++;
        -:  547:    
    #####:  548:    return session_id;
        -:  549:}
------------------
start_performance_monitoring_enhanced:
function start_performance_monitoring_enhanced called 158 returned 100% blocks executed 100%
      158:  481:int64_t start_performance_monitoring_enhanced(const char* operation_name, const char* operation_type) {
      158:  482:    if (!operation_name || !operation_type) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        2:  483:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Operation name and type cannot be NULL");
        2:  484:        return -1;
        -:  485:    }
        -:  486:    
        -:  487:    // Initialize engine if needed
      156:  488:    if (!g_engine) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        1:  489:        if (init_metrics_engine() != MERCURY_SUCCESS) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -:  490:            return -1;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Find available monitor slot
        -:  495:    PerformanceMonitor* monitor = NULL;
        -:  496:    int64_t session_id = -1;
        -:  497:    
     4486:  498:    for (size_t i = 0; i < g_engine->max_monitors; i++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
     4450:  499:        if (!g_engine->monitors[i].is_active) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -:  500:            monitor = &g_engine->monitors[i];
      120:  501:            session_id = (int64_t)i;
      120:  502:            break;
        -:  503:        }
        -:  504:    }
        -:  505:    
      156:  506:    if (!monitor) {
branch  0 taken 23% (fallthrough)
branch  1 taken 77%
       36:  507:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "No available monitor slots");
       36:  508:        return -1;
        -:  509:    }
        -:  510:    
        -:  511:    // Initialize monitor
      120:  512:    monitor->session_id = session_id;
call    0 returned 100%
      120:  513:    monitor->start_time = mercury_get_timestamp();
      120:  514:    monitor->end_time = monitor->start_time;  // Will be updated on stop
        -:  515:    
        -:  516:    // Initialize metrics - capture baseline counters
      120:  517:    monitor->query_count_start = (uint32_t)atomic_load(&g_engine->global_query_count);
      120:  518:    monitor->query_count_end = 0;
      120:  519:    monitor->cache_hits = 0;
      120:  520:    monitor->cache_misses = 0;
      120:  521:    monitor->memory_start_bytes = get_memory_usage();
call    0 returned 100%
      120:  522:    monitor->memory_peak_bytes = monitor->memory_start_bytes;
      120:  523:    monitor->memory_end_bytes = 0;
        -:  524:    
        -:  525:    // Set default thresholds
      120:  526:    monitor->thresholds.response_time_ms = 1000.0;  // 1 second default
      120:  527:    monitor->thresholds.memory_usage_mb = 200.0;    // 200MB default
      120:  528:    monitor->thresholds.query_count_max = 50;       // 50 queries default
      120:  529:    monitor->thresholds.cache_hit_ratio_min = 0.7;  // 70% cache hit ratio
      120:  530:    monitor->thresholds.flags = 0;
        -:  531:    
        -:  532:    // Copy operation info
      120:  533:    strncpy(monitor->operation_name, operation_name, sizeof(monitor->operation_name) - 1);
call    0 returned 100%
      120:  534:    monitor->operation_name[sizeof(monitor->operation_name) - 1] = '\0';
      120:  535:    strncpy(monitor->operation_type, operation_type, sizeof(monitor->operation_type) - 1);
      120:  536:    monitor->operation_type[sizeof(monitor->operation_type) - 1] = '\0';
        -:  537:    
        -:  538:    // Capture stack trace for context
      120:  539:    monitor->stack_depth = capture_stack_trace(monitor->stack_trace, STACK_TRACE_MAX_DEPTH);
call    0 returned 100%
        -:  540:    
        -:  541:    // Initialize status
      120:  542:    monitor->violation_flags = 0;
      120:  543:    monitor->is_active = true;
        -:  544:    
      120:  545:    atomic_fetch_add(&g_engine->total_sessions, 1);
      120:  546:    g_engine->monitor_count++;
        -:  547:    
      120:  548:    return session_id;
        -:  549:}
------------------
        -:  550:
        -:  551:// Stop performance monitoring and return metrics
     123*:  552:MercuryMetrics* stop_performance_monitoring_enhanced(int64_t session_id) {
     123*:  553:    if (!g_engine || session_id < 0 || session_id >= (int64_t)g_engine->max_monitors) {
       2*:  554:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid session ID");
       2*:  555:        return NULL;
        -:  556:    }
        -:  557:    
     121*:  558:    PerformanceMonitor* monitor = &g_engine->monitors[session_id];
     121*:  559:    if (!monitor->is_active || monitor->session_id != session_id) {
      28*:  560:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Session not active");
      28*:  561:        return NULL;
        -:  562:    }
        -:  563:    
        -:  564:    // Record end time and final metrics
      93*:  565:    monitor->end_time = mercury_get_timestamp();
      93*:  566:    monitor->memory_end_bytes = get_memory_usage();
        -:  567:    
        -:  568:    // Update peak memory if current is higher
      93*:  569:    if (monitor->memory_end_bytes > monitor->memory_peak_bytes) {
      73*:  570:        monitor->memory_peak_bytes = monitor->memory_end_bytes;
        -:  571:    }
        -:  572:    
        -:  573:    // Capture final Django hook counters
      93*:  574:    monitor->query_count_end = (uint32_t)atomic_load(&g_engine->global_query_count);
        -:  575:    
        -:  576:    // Check thresholds
      93*:  577:    uint64_t violations = 0;
        -:  578:    
        -:  579:    #ifdef USE_SIMD
      93*:  580:        check_thresholds_simd_impl(monitor, 1, &violations);
        -:  581:    #else
        -:  582:        check_thresholds_scalar(monitor, 1, &violations);
        -:  583:    #endif
        -:  584:    
      93*:  585:    monitor->violation_flags = violations;
      93*:  586:    if (violations > 0) {
    #####:  587:        atomic_fetch_add(&g_engine->violations_detected, 1);
        -:  588:    }
        -:  589:    
        -:  590:    // Create result metrics
      93*:  591:    MercuryMetrics* metrics = mercury_aligned_alloc(sizeof(MercuryMetrics), 64);
      93*:  592:    if (!metrics) {
    #####:  593:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate result metrics");
    #####:  594:        return NULL;
        -:  595:    }
        -:  596:    
        -:  597:    // Copy data to result
      93*:  598:    metrics->start_time = monitor->start_time;
      93*:  599:    metrics->end_time = monitor->end_time;
      93*:  600:    metrics->query_count = monitor->query_count_end - monitor->query_count_start;
      93*:  601:    metrics->cache_hits = monitor->cache_hits;
      93*:  602:    metrics->cache_misses = monitor->cache_misses;
      93*:  603:    metrics->memory_bytes = monitor->memory_peak_bytes;
      93*:  604:    metrics->violation_flags = monitor->violation_flags;
        -:  605:    
      93*:  606:    strncpy(metrics->operation_name, monitor->operation_name, sizeof(metrics->operation_name) - 1);
      93*:  607:    metrics->operation_name[sizeof(metrics->operation_name) - 1] = '\0';
      93*:  608:    strncpy(metrics->operation_type, monitor->operation_type, sizeof(metrics->operation_type) - 1);
      93*:  609:    metrics->operation_type[sizeof(metrics->operation_type) - 1] = '\0';
        -:  610:    
        -:  611:    // Deactivate monitor
      93*:  612:    monitor->is_active = false;
      93*:  613:    monitor->session_id = -1;
      93*:  614:    g_engine->monitor_count--;
        -:  615:    
      93*:  616:    return metrics;
        -:  617:}
------------------
stop_performance_monitoring_enhanced:
function stop_performance_monitoring_enhanced called 0 returned 0% blocks executed 0%
    #####:  552:MercuryMetrics* stop_performance_monitoring_enhanced(int64_t session_id) {
    #####:  553:    if (!g_engine || session_id < 0 || session_id >= (int64_t)g_engine->max_monitors) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  554:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid session ID");
    #####:  555:        return NULL;
        -:  556:    }
        -:  557:    
    #####:  558:    PerformanceMonitor* monitor = &g_engine->monitors[session_id];
    #####:  559:    if (!monitor->is_active || monitor->session_id != session_id) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  560:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Session not active");
    #####:  561:        return NULL;
        -:  562:    }
        -:  563:    
        -:  564:    // Record end time and final metrics
    #####:  565:    monitor->end_time = mercury_get_timestamp();
    #####:  566:    monitor->memory_end_bytes = get_memory_usage();
call    0 never executed
        -:  567:    
        -:  568:    // Update peak memory if current is higher
    #####:  569:    if (monitor->memory_end_bytes > monitor->memory_peak_bytes) {
branch  0 never executed
branch  1 never executed
    #####:  570:        monitor->memory_peak_bytes = monitor->memory_end_bytes;
        -:  571:    }
        -:  572:    
        -:  573:    // Capture final Django hook counters
    #####:  574:    monitor->query_count_end = (uint32_t)atomic_load(&g_engine->global_query_count);
        -:  575:    
        -:  576:    // Check thresholds
    #####:  577:    uint64_t violations = 0;
        -:  578:    
        -:  579:    #ifdef USE_SIMD
    #####:  580:        check_thresholds_simd_impl(monitor, 1, &violations);
call    0 never executed
        -:  581:    #else
        -:  582:        check_thresholds_scalar(monitor, 1, &violations);
        -:  583:    #endif
        -:  584:    
    #####:  585:    monitor->violation_flags = violations;
    #####:  586:    if (violations > 0) {
branch  0 never executed
branch  1 never executed
    #####:  587:        atomic_fetch_add(&g_engine->violations_detected, 1);
        -:  588:    }
        -:  589:    
        -:  590:    // Create result metrics
    #####:  591:    MercuryMetrics* metrics = mercury_aligned_alloc(sizeof(MercuryMetrics), 64);
call    0 never executed
    #####:  592:    if (!metrics) {
branch  0 never executed
branch  1 never executed
    #####:  593:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate result metrics");
    #####:  594:        return NULL;
        -:  595:    }
        -:  596:    
        -:  597:    // Copy data to result
    #####:  598:    metrics->start_time = monitor->start_time;
    #####:  599:    metrics->end_time = monitor->end_time;
    #####:  600:    metrics->query_count = monitor->query_count_end - monitor->query_count_start;
    #####:  601:    metrics->cache_hits = monitor->cache_hits;
    #####:  602:    metrics->cache_misses = monitor->cache_misses;
    #####:  603:    metrics->memory_bytes = monitor->memory_peak_bytes;
    #####:  604:    metrics->violation_flags = monitor->violation_flags;
        -:  605:    
    #####:  606:    strncpy(metrics->operation_name, monitor->operation_name, sizeof(metrics->operation_name) - 1);
    #####:  607:    metrics->operation_name[sizeof(metrics->operation_name) - 1] = '\0';
    #####:  608:    strncpy(metrics->operation_type, monitor->operation_type, sizeof(metrics->operation_type) - 1);
    #####:  609:    metrics->operation_type[sizeof(metrics->operation_type) - 1] = '\0';
        -:  610:    
        -:  611:    // Deactivate monitor
    #####:  612:    monitor->is_active = false;
    #####:  613:    monitor->session_id = -1;
    #####:  614:    g_engine->monitor_count--;
        -:  615:    
    #####:  616:    return metrics;
        -:  617:}
------------------
stop_performance_monitoring_enhanced:
function stop_performance_monitoring_enhanced called 123 returned 100% blocks executed 90%
      123:  552:MercuryMetrics* stop_performance_monitoring_enhanced(int64_t session_id) {
      123:  553:    if (!g_engine || session_id < 0 || session_id >= (int64_t)g_engine->max_monitors) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 99% (fallthrough)
branch  3 taken 1%
branch  4 taken 1% (fallthrough)
branch  5 taken 99%
        2:  554:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid session ID");
        2:  555:        return NULL;
        -:  556:    }
        -:  557:    
      121:  558:    PerformanceMonitor* monitor = &g_engine->monitors[session_id];
      121:  559:    if (!monitor->is_active || monitor->session_id != session_id) {
branch  0 taken 77% (fallthrough)
branch  1 taken 23%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
       28:  560:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Session not active");
       28:  561:        return NULL;
        -:  562:    }
        -:  563:    
        -:  564:    // Record end time and final metrics
       93:  565:    monitor->end_time = mercury_get_timestamp();
       93:  566:    monitor->memory_end_bytes = get_memory_usage();
call    0 returned 100%
        -:  567:    
        -:  568:    // Update peak memory if current is higher
       93:  569:    if (monitor->memory_end_bytes > monitor->memory_peak_bytes) {
branch  0 taken 78% (fallthrough)
branch  1 taken 22%
       73:  570:        monitor->memory_peak_bytes = monitor->memory_end_bytes;
        -:  571:    }
        -:  572:    
        -:  573:    // Capture final Django hook counters
       93:  574:    monitor->query_count_end = (uint32_t)atomic_load(&g_engine->global_query_count);
        -:  575:    
        -:  576:    // Check thresholds
       93:  577:    uint64_t violations = 0;
        -:  578:    
        -:  579:    #ifdef USE_SIMD
       93:  580:        check_thresholds_simd_impl(monitor, 1, &violations);
call    0 returned 100%
        -:  581:    #else
        -:  582:        check_thresholds_scalar(monitor, 1, &violations);
        -:  583:    #endif
        -:  584:    
       93:  585:    monitor->violation_flags = violations;
       93:  586:    if (violations > 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  587:        atomic_fetch_add(&g_engine->violations_detected, 1);
        -:  588:    }
        -:  589:    
        -:  590:    // Create result metrics
       93:  591:    MercuryMetrics* metrics = mercury_aligned_alloc(sizeof(MercuryMetrics), 64);
call    0 returned 100%
       93:  592:    if (!metrics) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  593:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate result metrics");
    #####:  594:        return NULL;
        -:  595:    }
        -:  596:    
        -:  597:    // Copy data to result
       93:  598:    metrics->start_time = monitor->start_time;
       93:  599:    metrics->end_time = monitor->end_time;
       93:  600:    metrics->query_count = monitor->query_count_end - monitor->query_count_start;
       93:  601:    metrics->cache_hits = monitor->cache_hits;
       93:  602:    metrics->cache_misses = monitor->cache_misses;
       93:  603:    metrics->memory_bytes = monitor->memory_peak_bytes;
       93:  604:    metrics->violation_flags = monitor->violation_flags;
        -:  605:    
       93:  606:    strncpy(metrics->operation_name, monitor->operation_name, sizeof(metrics->operation_name) - 1);
       93:  607:    metrics->operation_name[sizeof(metrics->operation_name) - 1] = '\0';
       93:  608:    strncpy(metrics->operation_type, monitor->operation_type, sizeof(metrics->operation_type) - 1);
       93:  609:    metrics->operation_type[sizeof(metrics->operation_type) - 1] = '\0';
        -:  610:    
        -:  611:    // Deactivate monitor
       93:  612:    monitor->is_active = false;
       93:  613:    monitor->session_id = -1;
       93:  614:    g_engine->monitor_count--;
        -:  615:    
       93:  616:    return metrics;
        -:  617:}
------------------
        -:  618:
        -:  619:// Helper functions for Python integration
       2*:  620:double get_elapsed_time_ms(const MercuryMetrics* metrics) {
       2*:  621:    if (!metrics) return 0.0;
       2*:  622:    return mercury_ns_to_ms(metrics->end_time.nanoseconds - metrics->start_time.nanoseconds);
        -:  623:}
------------------
get_elapsed_time_ms:
function get_elapsed_time_ms called 0 returned 0% blocks executed 0%
    #####:  620:double get_elapsed_time_ms(const MercuryMetrics* metrics) {
    #####:  621:    if (!metrics) return 0.0;
branch  0 never executed
branch  1 never executed
    #####:  622:    return mercury_ns_to_ms(metrics->end_time.nanoseconds - metrics->start_time.nanoseconds);
        -:  623:}
------------------
get_elapsed_time_ms:
function get_elapsed_time_ms called 2 returned 100% blocks executed 100%
        2:  620:double get_elapsed_time_ms(const MercuryMetrics* metrics) {
        2:  621:    if (!metrics) return 0.0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  622:    return mercury_ns_to_ms(metrics->end_time.nanoseconds - metrics->start_time.nanoseconds);
        -:  623:}
------------------
        -:  624:
       1*:  625:double get_memory_usage_mb(const MercuryMetrics* metrics) {
       1*:  626:    if (!metrics) return 0.0;
       1*:  627:    return (double)metrics->memory_bytes / (1024.0 * 1024.0);
        -:  628:}
------------------
get_memory_usage_mb:
function get_memory_usage_mb called 0 returned 0% blocks executed 0%
    #####:  625:double get_memory_usage_mb(const MercuryMetrics* metrics) {
    #####:  626:    if (!metrics) return 0.0;
branch  0 never executed
branch  1 never executed
    #####:  627:    return (double)metrics->memory_bytes / (1024.0 * 1024.0);
        -:  628:}
------------------
get_memory_usage_mb:
function get_memory_usage_mb called 1 returned 100% blocks executed 100%
        1:  625:double get_memory_usage_mb(const MercuryMetrics* metrics) {
        1:  626:    if (!metrics) return 0.0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  627:    return (double)metrics->memory_bytes / (1024.0 * 1024.0);
        -:  628:}
------------------
        -:  629:
       1*:  630:uint32_t get_query_count(const MercuryMetrics* metrics) {
       1*:  631:    if (!metrics) return 0;
       1*:  632:    return metrics->query_count;
        -:  633:}
------------------
get_query_count:
function get_query_count called 0 returned 0% blocks executed 0%
    #####:  630:uint32_t get_query_count(const MercuryMetrics* metrics) {
    #####:  631:    if (!metrics) return 0;
branch  0 never executed
branch  1 never executed
    #####:  632:    return metrics->query_count;
        -:  633:}
------------------
get_query_count:
function get_query_count called 1 returned 100% blocks executed 100%
        1:  630:uint32_t get_query_count(const MercuryMetrics* metrics) {
        1:  631:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  632:    return metrics->query_count;
        -:  633:}
------------------
        -:  634:
       1*:  635:uint32_t get_cache_hit_count(const MercuryMetrics* metrics) {
       1*:  636:    if (!metrics) return 0;
       1*:  637:    return metrics->cache_hits;
        -:  638:}
------------------
get_cache_hit_count:
function get_cache_hit_count called 0 returned 0% blocks executed 0%
    #####:  635:uint32_t get_cache_hit_count(const MercuryMetrics* metrics) {
    #####:  636:    if (!metrics) return 0;
branch  0 never executed
branch  1 never executed
    #####:  637:    return metrics->cache_hits;
        -:  638:}
------------------
get_cache_hit_count:
function get_cache_hit_count called 1 returned 100% blocks executed 100%
        1:  635:uint32_t get_cache_hit_count(const MercuryMetrics* metrics) {
        1:  636:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  637:    return metrics->cache_hits;
        -:  638:}
------------------
        -:  639:
       1*:  640:uint32_t get_cache_miss_count(const MercuryMetrics* metrics) {
       1*:  641:    if (!metrics) return 0;
       1*:  642:    return metrics->cache_misses;
        -:  643:}
------------------
get_cache_miss_count:
function get_cache_miss_count called 0 returned 0% blocks executed 0%
    #####:  640:uint32_t get_cache_miss_count(const MercuryMetrics* metrics) {
    #####:  641:    if (!metrics) return 0;
branch  0 never executed
branch  1 never executed
    #####:  642:    return metrics->cache_misses;
        -:  643:}
------------------
get_cache_miss_count:
function get_cache_miss_count called 1 returned 100% blocks executed 100%
        1:  640:uint32_t get_cache_miss_count(const MercuryMetrics* metrics) {
        1:  641:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  642:    return metrics->cache_misses;
        -:  643:}
------------------
        -:  644:
       1*:  645:double get_cache_hit_ratio(const MercuryMetrics* metrics) {
       1*:  646:    if (!metrics) return 0.0;
       1*:  647:    uint32_t total = metrics->cache_hits + metrics->cache_misses;
       1*:  648:    return (total > 0) ? (double)metrics->cache_hits / (double)total : 0.0;
        -:  649:}
------------------
get_cache_hit_ratio:
function get_cache_hit_ratio called 0 returned 0% blocks executed 0%
    #####:  645:double get_cache_hit_ratio(const MercuryMetrics* metrics) {
    #####:  646:    if (!metrics) return 0.0;
branch  0 never executed
branch  1 never executed
    #####:  647:    uint32_t total = metrics->cache_hits + metrics->cache_misses;
    #####:  648:    return (total > 0) ? (double)metrics->cache_hits / (double)total : 0.0;
branch  0 never executed
branch  1 never executed
        -:  649:}
------------------
get_cache_hit_ratio:
function get_cache_hit_ratio called 1 returned 100% blocks executed 75%
        1:  645:double get_cache_hit_ratio(const MercuryMetrics* metrics) {
        1:  646:    if (!metrics) return 0.0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  647:    uint32_t total = metrics->cache_hits + metrics->cache_misses;
       1*:  648:    return (total > 0) ? (double)metrics->cache_hits / (double)total : 0.0;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  649:}
------------------
        -:  650:
        -:  651:// N+1 detection functions (would integrate with query analyzer)
    #####:  652:int has_n_plus_one_pattern(const MercuryMetrics* metrics) {
    #####:  653:    if (!metrics) return 0;
    #####:  654:    return (metrics->violation_flags & VIOLATION_N_PLUS_ONE) ? 1 : 0;
        -:  655:}
------------------
has_n_plus_one_pattern:
function has_n_plus_one_pattern called 0 returned 0% blocks executed 0%
    #####:  652:int has_n_plus_one_pattern(const MercuryMetrics* metrics) {
    #####:  653:    if (!metrics) return 0;
branch  0 never executed
branch  1 never executed
    #####:  654:    return (metrics->violation_flags & VIOLATION_N_PLUS_ONE) ? 1 : 0;
        -:  655:}
------------------
has_n_plus_one_pattern:
function has_n_plus_one_pattern called 0 returned 0% blocks executed 0%
    #####:  652:int has_n_plus_one_pattern(const MercuryMetrics* metrics) {
    #####:  653:    if (!metrics) return 0;
branch  0 never executed
branch  1 never executed
    #####:  654:    return (metrics->violation_flags & VIOLATION_N_PLUS_ONE) ? 1 : 0;
        -:  655:}
------------------
        -:  656:
    #####:  657:int detect_n_plus_one_severe(const MercuryMetrics* metrics) {
    #####:  658:    if (!metrics) return 0;
    #####:  659:    return (metrics->query_count > 50) ? 1 : 0;
        -:  660:}
------------------
detect_n_plus_one_severe:
function detect_n_plus_one_severe called 0 returned 0% blocks executed 0%
    #####:  657:int detect_n_plus_one_severe(const MercuryMetrics* metrics) {
    #####:  658:    if (!metrics) return 0;
branch  0 never executed
branch  1 never executed
    #####:  659:    return (metrics->query_count > 50) ? 1 : 0;
        -:  660:}
------------------
detect_n_plus_one_severe:
function detect_n_plus_one_severe called 0 returned 0% blocks executed 0%
    #####:  657:int detect_n_plus_one_severe(const MercuryMetrics* metrics) {
    #####:  658:    if (!metrics) return 0;
branch  0 never executed
branch  1 never executed
    #####:  659:    return (metrics->query_count > 50) ? 1 : 0;
        -:  660:}
------------------
        -:  661:
    #####:  662:int detect_n_plus_one_moderate(const MercuryMetrics* metrics) {
    #####:  663:    if (!metrics) return 0;
    #####:  664:    return (metrics->query_count > 20 && metrics->query_count <= 50) ? 1 : 0;
        -:  665:}
------------------
detect_n_plus_one_moderate:
function detect_n_plus_one_moderate called 0 returned 0% blocks executed 0%
    #####:  662:int detect_n_plus_one_moderate(const MercuryMetrics* metrics) {
    #####:  663:    if (!metrics) return 0;
branch  0 never executed
branch  1 never executed
    #####:  664:    return (metrics->query_count > 20 && metrics->query_count <= 50) ? 1 : 0;
        -:  665:}
------------------
detect_n_plus_one_moderate:
function detect_n_plus_one_moderate called 0 returned 0% blocks executed 0%
    #####:  662:int detect_n_plus_one_moderate(const MercuryMetrics* metrics) {
    #####:  663:    if (!metrics) return 0;
branch  0 never executed
branch  1 never executed
    #####:  664:    return (metrics->query_count > 20 && metrics->query_count <= 50) ? 1 : 0;
        -:  665:}
------------------
        -:  666:
        -:  667:// Free metrics memory
    #####:  668:void free_metrics(MercuryMetrics* metrics) {
    #####:  669:    if (metrics) {
    #####:  670:        mercury_aligned_free(metrics);
        -:  671:    }
    #####:  672:}
------------------
free_metrics:
function free_metrics called 0 returned 0% blocks executed 0%
    #####:  668:void free_metrics(MercuryMetrics* metrics) {
    #####:  669:    if (metrics) {
branch  0 never executed
branch  1 never executed
    #####:  670:        mercury_aligned_free(metrics);
call    0 never executed
        -:  671:    }
    #####:  672:}
------------------
free_metrics:
function free_metrics called 0 returned 0% blocks executed 0%
    #####:  668:void free_metrics(MercuryMetrics* metrics) {
    #####:  669:    if (metrics) {
branch  0 never executed
branch  1 never executed
    #####:  670:        mercury_aligned_free(metrics);
call    0 never executed
        -:  671:    }
    #####:  672:}
------------------
        -:  673:
        -:  674:// Increment counters (called by Django hooks)
    #####:  675:void increment_query_count(void) {
    #####:  676:    if (g_engine) {
    #####:  677:        atomic_fetch_add(&g_engine->global_query_count, 1);
        -:  678:    }
    #####:  679:}
------------------
increment_query_count:
function increment_query_count called 0 returned 0% blocks executed 0%
    #####:  675:void increment_query_count(void) {
    #####:  676:    if (g_engine) {
branch  0 never executed
branch  1 never executed
    #####:  677:        atomic_fetch_add(&g_engine->global_query_count, 1);
        -:  678:    }
    #####:  679:}
------------------
increment_query_count:
function increment_query_count called 0 returned 0% blocks executed 0%
    #####:  675:void increment_query_count(void) {
    #####:  676:    if (g_engine) {
branch  0 never executed
branch  1 never executed
    #####:  677:        atomic_fetch_add(&g_engine->global_query_count, 1);
        -:  678:    }
    #####:  679:}
------------------
        -:  680:
    #####:  681:void increment_cache_hits(void) {
    #####:  682:    if (g_engine) {
    #####:  683:        atomic_fetch_add(&g_engine->global_cache_hits, 1);
        -:  684:    }
    #####:  685:}
------------------
increment_cache_hits:
function increment_cache_hits called 0 returned 0% blocks executed 0%
    #####:  681:void increment_cache_hits(void) {
    #####:  682:    if (g_engine) {
branch  0 never executed
branch  1 never executed
    #####:  683:        atomic_fetch_add(&g_engine->global_cache_hits, 1);
        -:  684:    }
    #####:  685:}
------------------
increment_cache_hits:
function increment_cache_hits called 0 returned 0% blocks executed 0%
    #####:  681:void increment_cache_hits(void) {
    #####:  682:    if (g_engine) {
branch  0 never executed
branch  1 never executed
    #####:  683:        atomic_fetch_add(&g_engine->global_cache_hits, 1);
        -:  684:    }
    #####:  685:}
------------------
        -:  686:
    #####:  687:void increment_cache_misses(void) {
    #####:  688:    if (g_engine) {
    #####:  689:        atomic_fetch_add(&g_engine->global_cache_misses, 1);
        -:  690:    }
    #####:  691:}
------------------
increment_cache_misses:
function increment_cache_misses called 0 returned 0% blocks executed 0%
    #####:  687:void increment_cache_misses(void) {
    #####:  688:    if (g_engine) {
branch  0 never executed
branch  1 never executed
    #####:  689:        atomic_fetch_add(&g_engine->global_cache_misses, 1);
        -:  690:    }
    #####:  691:}
------------------
increment_cache_misses:
function increment_cache_misses called 0 returned 0% blocks executed 0%
    #####:  687:void increment_cache_misses(void) {
    #####:  688:    if (g_engine) {
branch  0 never executed
branch  1 never executed
    #####:  689:        atomic_fetch_add(&g_engine->global_cache_misses, 1);
        -:  690:    }
    #####:  691:}
------------------
        -:  692:
        -:  693:// Reset global counters (called before test execution)
    #####:  694:void reset_global_counters(void) {
    #####:  695:    if (g_engine) {
    #####:  696:        atomic_store(&g_engine->global_query_count, 0);
    #####:  697:        atomic_store(&g_engine->global_cache_hits, 0);
    #####:  698:        atomic_store(&g_engine->global_cache_misses, 0);
        -:  699:    }
    #####:  700:}
------------------
reset_global_counters:
function reset_global_counters called 0 returned 0% blocks executed 0%
    #####:  694:void reset_global_counters(void) {
    #####:  695:    if (g_engine) {
branch  0 never executed
branch  1 never executed
    #####:  696:        atomic_store(&g_engine->global_query_count, 0);
    #####:  697:        atomic_store(&g_engine->global_cache_hits, 0);
    #####:  698:        atomic_store(&g_engine->global_cache_misses, 0);
        -:  699:    }
    #####:  700:}
------------------
reset_global_counters:
function reset_global_counters called 0 returned 0% blocks executed 0%
    #####:  694:void reset_global_counters(void) {
    #####:  695:    if (g_engine) {
branch  0 never executed
branch  1 never executed
    #####:  696:        atomic_store(&g_engine->global_query_count, 0);
    #####:  697:        atomic_store(&g_engine->global_cache_hits, 0);
    #####:  698:        atomic_store(&g_engine->global_cache_misses, 0);
        -:  699:    }
    #####:  700:}
------------------
        -:  701:
        -:  702:// Get engine statistics
    #####:  703:void get_engine_statistics(uint64_t* total_sessions, uint64_t* violations_detected,
        -:  704:                          uint64_t* timing_overhead_ns, size_t* active_monitors) {
    #####:  705:    if (!g_engine) {
    #####:  706:        if (total_sessions) *total_sessions = 0;
    #####:  707:        if (violations_detected) *violations_detected = 0;
    #####:  708:        if (timing_overhead_ns) *timing_overhead_ns = 0;
    #####:  709:        if (active_monitors) *active_monitors = 0;
    #####:  710:        return;
        -:  711:    }
        -:  712:    
    #####:  713:    if (total_sessions) *total_sessions = atomic_load(&g_engine->total_sessions);
    #####:  714:    if (violations_detected) *violations_detected = atomic_load(&g_engine->violations_detected);
    #####:  715:    if (timing_overhead_ns) *timing_overhead_ns = atomic_load(&g_engine->timing_overhead_ns);
    #####:  716:    if (active_monitors) *active_monitors = g_engine->monitor_count;
        -:  717:}
------------------
get_engine_statistics:
function get_engine_statistics called 0 returned 0% blocks executed 0%
    #####:  703:void get_engine_statistics(uint64_t* total_sessions, uint64_t* violations_detected,
        -:  704:                          uint64_t* timing_overhead_ns, size_t* active_monitors) {
    #####:  705:    if (!g_engine) {
branch  0 never executed
branch  1 never executed
    #####:  706:        if (total_sessions) *total_sessions = 0;
branch  0 never executed
branch  1 never executed
    #####:  707:        if (violations_detected) *violations_detected = 0;
branch  0 never executed
branch  1 never executed
    #####:  708:        if (timing_overhead_ns) *timing_overhead_ns = 0;
branch  0 never executed
branch  1 never executed
    #####:  709:        if (active_monitors) *active_monitors = 0;
branch  0 never executed
branch  1 never executed
    #####:  710:        return;
        -:  711:    }
        -:  712:    
    #####:  713:    if (total_sessions) *total_sessions = atomic_load(&g_engine->total_sessions);
branch  0 never executed
branch  1 never executed
    #####:  714:    if (violations_detected) *violations_detected = atomic_load(&g_engine->violations_detected);
branch  0 never executed
branch  1 never executed
    #####:  715:    if (timing_overhead_ns) *timing_overhead_ns = atomic_load(&g_engine->timing_overhead_ns);
branch  0 never executed
branch  1 never executed
    #####:  716:    if (active_monitors) *active_monitors = g_engine->monitor_count;
branch  0 never executed
branch  1 never executed
        -:  717:}
------------------
get_engine_statistics:
function get_engine_statistics called 0 returned 0% blocks executed 0%
    #####:  703:void get_engine_statistics(uint64_t* total_sessions, uint64_t* violations_detected,
        -:  704:                          uint64_t* timing_overhead_ns, size_t* active_monitors) {
    #####:  705:    if (!g_engine) {
branch  0 never executed
branch  1 never executed
    #####:  706:        if (total_sessions) *total_sessions = 0;
branch  0 never executed
branch  1 never executed
    #####:  707:        if (violations_detected) *violations_detected = 0;
branch  0 never executed
branch  1 never executed
    #####:  708:        if (timing_overhead_ns) *timing_overhead_ns = 0;
branch  0 never executed
branch  1 never executed
    #####:  709:        if (active_monitors) *active_monitors = 0;
branch  0 never executed
branch  1 never executed
    #####:  710:        return;
        -:  711:    }
        -:  712:    
    #####:  713:    if (total_sessions) *total_sessions = atomic_load(&g_engine->total_sessions);
branch  0 never executed
branch  1 never executed
    #####:  714:    if (violations_detected) *violations_detected = atomic_load(&g_engine->violations_detected);
branch  0 never executed
branch  1 never executed
    #####:  715:    if (timing_overhead_ns) *timing_overhead_ns = atomic_load(&g_engine->timing_overhead_ns);
branch  0 never executed
branch  1 never executed
    #####:  716:    if (active_monitors) *active_monitors = g_engine->monitor_count;
branch  0 never executed
branch  1 never executed
        -:  717:}
------------------
        -:  718:
        -:  719:// === LIBRARY INITIALIZATION ===
        -:  720:
        -:  721:// Library constructor
        -:  722:__attribute__((constructor))
        -:  723:static void metrics_engine_init(void) {
        -:  724:    // MERCURY_INFO("libmetrics_engine.so loaded");  // Too verbose
        -:  725:}
        -:  726:
        -:  727:// Library destructor
        -:  728:__attribute__((destructor))
        2:  729:static void metrics_engine_cleanup(void) {
        2:  730:    cleanup_metrics_engine();
        -:  731:    // MERCURY_INFO("libmetrics_engine.so unloaded");  // Too verbose
        2:  732:}
------------------
metrics_engine_cleanup:
function metrics_engine_cleanup called 1 returned 100% blocks executed 100%
        1:  729:static void metrics_engine_cleanup(void) {
        1:  730:    cleanup_metrics_engine();
call    0 returned 100%
        -:  731:    // MERCURY_INFO("libmetrics_engine.so unloaded");  // Too verbose
        1:  732:}
------------------
metrics_engine_cleanup:
function metrics_engine_cleanup called 1 returned 100% blocks executed 100%
        1:  729:static void metrics_engine_cleanup(void) {
        1:  730:    cleanup_metrics_engine();
call    0 returned 100%
        -:  731:    // MERCURY_INFO("libmetrics_engine.so unloaded");  // Too verbose
        1:  732:}
------------------

        -:    0:Source:performance_monitor.c
        -:    0:Source is newer than graph
        -:    1:/**
        -:    2: * @file performance_monitor.c
        -:    3: * @brief Enhanced Performance Monitor with Django-aware capabilities for EduLite
        -:    4: * 
        -:    5: * This C library provides high-performance monitoring capabilities for Django applications
        -:    6: * with realistic thresholds for applications that have user profiles and related models.
        -:    7: * 
        -:    8: * Features:
        -:    9: * - Operation-aware scoring (DELETE operations get more lenient thresholds)
        -:   10: * - Realistic N+1 detection (12+ queries before flagging as N+1)
        -:   11: * - Comprehensive performance metrics collection
        -:   12: * - Django-specific query and cache tracking
        -:   13: */
        -:   14:
        -:   15:#include "common.h"
        -:   16:
        -:   17:/**
        -:   18: * @brief Performance metrics structure for enhanced monitoring
        -:   19: * 
        -:   20: * Contains comprehensive performance data including timing, memory usage,
        -:   21: * database queries, and cache statistics for Django operations.
        -:   22: * Uses per-session counters for proper concurrent session isolation.
        -:   23: */
        -:   24:typedef struct {
        -:   25:    uint64_t start_time_ns;          /**< Start time in nanoseconds */
        -:   26:    uint64_t end_time_ns;            /**< End time in nanoseconds */
        -:   27:    size_t memory_start_bytes;       /**< Initial memory usage in bytes */
        -:   28:    size_t memory_peak_bytes;        /**< Peak memory usage in bytes */
        -:   29:    size_t memory_end_bytes;         /**< Final memory usage in bytes */
        -:   30:    uint32_t session_query_count;    /**< Per-session database query count */
        -:   31:    uint32_t session_cache_hits;     /**< Per-session cache hits */
        -:   32:    uint32_t session_cache_misses;   /**< Per-session cache misses */
        -:   33:    char operation_name[256];        /**< Name of the operation */
        -:   34:    char operation_type[64];         /**< Type: view, model, serializer, query */
        -:   35:    pthread_mutex_t session_mutex;   /**< Mutex for thread-safe session updates */
        -:   36:    int64_t session_id;              /**< Unique session identifier */
        -:   37:} EnhancedPerformanceMetrics_t;
        -:   38:
        -:   39:// Global storage for active monitors
        -:   40:static EnhancedPerformanceMetrics_t* active_monitors[2048] = {NULL};
        -:   41:static int active_monitor_slots[2048] = {0};
        -:   42:
        -:   43:// Thread safety mutex for slot allocation
        -:   44:static pthread_mutex_t slot_mutex = PTHREAD_MUTEX_INITIALIZER;
        -:   45:
        -:   46:// Global counters for Django-specific metrics
        -:   47:static uint32_t global_query_count = 0;
        -:   48:static uint32_t global_cache_hits = 0;
        -:   49:static uint32_t global_cache_misses = 0;
        -:   50:
        -:   51:// Forward declarations for N+1 detection functions (exported to Python)
        -:   52:int detect_n_plus_one_severe(EnhancedPerformanceMetrics_t* metrics);
        -:   53:int detect_n_plus_one_moderate(EnhancedPerformanceMetrics_t* metrics);
        -:   54:int detect_n_plus_one_pattern_by_count(EnhancedPerformanceMetrics_t* metrics);
        -:   55:
        -:   56:// --- Internal Helper Functions ---
        -:   57:
        -:   58:/**
        -:   59: * @brief Get current time in nanoseconds using monotonic clock
        -:   60: * @return Current time in nanoseconds
        -:   61: */
        -:   62:static uint64_t get_current_time_ns(void) {
        -:   63:    struct timespec ts;
     7682:   64:    clock_gettime(CLOCK_MONOTONIC, &ts);
call    0 returned 100%
call    1 returned 100%
call    2 returned 100%
call    3 returned 100%
call    4 returned 100%
call    5 returned 100%
     7682:   65:    return (uint64_t)ts.tv_sec * 1000000000ULL + (uint64_t)ts.tv_nsec;
        -:   66:}
        -:   67:
        -:   68:/**
        -:   69: * @brief Get memory usage in bytes by reading /proc/self/status
        -:   70: * @return Memory usage in bytes (VmRSS)
        -:   71: */
     7682:   72:static size_t get_memory_usage_bytes(void) {
     7682:   73:    FILE *file = fopen("/proc/self/status", "r");
     7682:   74:    if (!file) return 0;
        -:   75:    
        -:   76:    char line[256];
     7682:   77:    size_t vmrss_kb = 0;
        -:   78:    
   176686:   79:    while (fgets(line, sizeof(line), file)) {
   169004:   80:        if (strncmp(line, "VmRSS:", 6) == 0) {
     7682:   81:            sscanf(line, "VmRSS: %zu kB", &vmrss_kb);
     7682:   82:            break;
        -:   83:        }
        -:   84:    }
        -:   85:    
     7682:   86:    fclose(file);
     7682:   87:    return vmrss_kb * 1024;
        -:   88:}
------------------
get_memory_usage_bytes:
function get_memory_usage_bytes called 30 returned 100% blocks executed 100%
       30:   72:static size_t get_memory_usage_bytes(void) {
       30:   73:    FILE *file = fopen("/proc/self/status", "r");
call    0 returned 100%
       30:   74:    if (!file) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   75:    
        -:   76:    char line[256];
       30:   77:    size_t vmrss_kb = 0;
        -:   78:    
      690:   79:    while (fgets(line, sizeof(line), file)) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
      660:   80:        if (strncmp(line, "VmRSS:", 6) == 0) {
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
       30:   81:            sscanf(line, "VmRSS: %zu kB", &vmrss_kb);
       30:   82:            break;
        -:   83:        }
        -:   84:    }
        -:   85:    
       30:   86:    fclose(file);
call    0 returned 100%
       30:   87:    return vmrss_kb * 1024;
        -:   88:}
------------------
get_memory_usage_bytes:
function get_memory_usage_bytes called 50 returned 100% blocks executed 100%
       50:   72:static size_t get_memory_usage_bytes(void) {
       50:   73:    FILE *file = fopen("/proc/self/status", "r");
call    0 returned 100%
       50:   74:    if (!file) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   75:    
        -:   76:    char line[256];
       50:   77:    size_t vmrss_kb = 0;
        -:   78:    
     1150:   79:    while (fgets(line, sizeof(line), file)) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
     1100:   80:        if (strncmp(line, "VmRSS:", 6) == 0) {
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
       50:   81:            sscanf(line, "VmRSS: %zu kB", &vmrss_kb);
       50:   82:            break;
        -:   83:        }
        -:   84:    }
        -:   85:    
       50:   86:    fclose(file);
call    0 returned 100%
       50:   87:    return vmrss_kb * 1024;
        -:   88:}
------------------
get_memory_usage_bytes:
function get_memory_usage_bytes called 7602 returned 100% blocks executed 100%
     7602:   72:static size_t get_memory_usage_bytes(void) {
     7602:   73:    FILE *file = fopen("/proc/self/status", "r");
call    0 returned 100%
     7602:   74:    if (!file) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   75:    
        -:   76:    char line[256];
     7602:   77:    size_t vmrss_kb = 0;
        -:   78:    
   174846:   79:    while (fgets(line, sizeof(line), file)) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
   167244:   80:        if (strncmp(line, "VmRSS:", 6) == 0) {
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
     7602:   81:            sscanf(line, "VmRSS: %zu kB", &vmrss_kb);
     7602:   82:            break;
        -:   83:        }
        -:   84:    }
        -:   85:    
     7602:   86:    fclose(file);
call    0 returned 100%
     7602:   87:    return vmrss_kb * 1024;
        -:   88:}
------------------
        -:   89:
        -:   90:// --- Django Hooks for Query and Cache Tracking ---
        -:   91:
        -:   92:/**
        -:   93: * @brief Reset global counters (called between tests)
        -:   94: */
       34:   95:void reset_global_counters(void) {
       34:   96:    global_query_count = 0;
       34:   97:    global_cache_hits = 0;
       34:   98:    global_cache_misses = 0;
       34:   99:}
------------------
reset_global_counters:
function reset_global_counters called 1 returned 100% blocks executed 100%
        1:   95:void reset_global_counters(void) {
        1:   96:    global_query_count = 0;
        1:   97:    global_cache_hits = 0;
        1:   98:    global_cache_misses = 0;
        1:   99:}
------------------
reset_global_counters:
function reset_global_counters called 20 returned 100% blocks executed 100%
       20:   95:void reset_global_counters(void) {
       20:   96:    global_query_count = 0;
       20:   97:    global_cache_hits = 0;
       20:   98:    global_cache_misses = 0;
       20:   99:}
------------------
reset_global_counters:
function reset_global_counters called 13 returned 100% blocks executed 100%
       13:   95:void reset_global_counters(void) {
       13:   96:    global_query_count = 0;
       13:   97:    global_cache_hits = 0;
       13:   98:    global_cache_misses = 0;
       13:   99:}
------------------
        -:  100:
        -:  101:// Thread-local storage for current session ID
        -:  102:static __thread int64_t current_session_id = 0;
        -:  103:
        -:  104:/**
        -:  105: * @brief Set the current session ID for this thread
        -:  106: * @param session_id The session ID to set as current for this thread
        -:  107: */
     3855:  108:void set_current_session_id(int64_t session_id) {
     3855:  109:    current_session_id = session_id;
     3855:  110:}
------------------
set_current_session_id:
function set_current_session_id called 15 returned 100% blocks executed 100%
       15:  108:void set_current_session_id(int64_t session_id) {
       15:  109:    current_session_id = session_id;
       15:  110:}
------------------
set_current_session_id:
function set_current_session_id called 29 returned 100% blocks executed 100%
       29:  108:void set_current_session_id(int64_t session_id) {
       29:  109:    current_session_id = session_id;
       29:  110:}
------------------
set_current_session_id:
function set_current_session_id called 3811 returned 100% blocks executed 100%
     3811:  108:void set_current_session_id(int64_t session_id) {
     3811:  109:    current_session_id = session_id;
     3811:  110:}
------------------
        -:  111:
        -:  112:/**
        -:  113: * @brief Get the current session ID for this thread
        -:  114: * @return Current session ID, 0 if none set
        -:  115: */
    #####:  116:int64_t get_current_session_id(void) {
    #####:  117:    return current_session_id;
        -:  118:}
------------------
get_current_session_id:
function get_current_session_id called 0 returned 0% blocks executed 0%
    #####:  116:int64_t get_current_session_id(void) {
    #####:  117:    return current_session_id;
        -:  118:}
------------------
get_current_session_id:
function get_current_session_id called 0 returned 0% blocks executed 0%
    #####:  116:int64_t get_current_session_id(void) {
    #####:  117:    return current_session_id;
        -:  118:}
------------------
get_current_session_id:
function get_current_session_id called 0 returned 0% blocks executed 0%
    #####:  116:int64_t get_current_session_id(void) {
    #####:  117:    return current_session_id;
        -:  118:}
------------------
        -:  119:
        -:  120:/**
        -:  121: * @brief Find active session by session ID
        -:  122: * @param session_id The session ID to find
        -:  123: * @return Pointer to session metrics, NULL if not found
        -:  124: */
    22554:  125:static EnhancedPerformanceMetrics_t* find_session_by_id(int64_t session_id) {
    22554:  126:    if (session_id <= 0) return NULL;
        -:  127:    
    22554:  128:    pthread_mutex_lock(&slot_mutex);
        -:  129:    
    22554:  130:    int slot = session_id - 1;  // Convert back to 0-based slot
        -:  131:    EnhancedPerformanceMetrics_t* session = NULL;
        -:  132:    
    22554:  133:    if (slot >= 0 && slot < 2048 && active_monitor_slots[slot] == 1 && active_monitors[slot] != NULL) {
        -:  134:        session = active_monitors[slot];
        -:  135:    }
        -:  136:    
    22554:  137:    pthread_mutex_unlock(&slot_mutex);
    22554:  138:    return session;
        -:  139:}
------------------
find_session_by_id:
function find_session_by_id called 207 returned 100% blocks executed 100%
      207:  125:static EnhancedPerformanceMetrics_t* find_session_by_id(int64_t session_id) {
      207:  126:    if (session_id <= 0) return NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  127:    
      207:  128:    pthread_mutex_lock(&slot_mutex);
call    0 returned 100%
        -:  129:    
      207:  130:    int slot = session_id - 1;  // Convert back to 0-based slot
        -:  131:    EnhancedPerformanceMetrics_t* session = NULL;
        -:  132:    
      207:  133:    if (slot >= 0 && slot < 2048 && active_monitor_slots[slot] == 1 && active_monitors[slot] != NULL) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 95% (fallthrough)
branch  3 taken 5%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -:  134:        session = active_monitors[slot];
        -:  135:    }
        -:  136:    
      207:  137:    pthread_mutex_unlock(&slot_mutex);
call    0 returned 100%
      207:  138:    return session;
        -:  139:}
------------------
find_session_by_id:
function find_session_by_id called 610 returned 100% blocks executed 100%
      610:  125:static EnhancedPerformanceMetrics_t* find_session_by_id(int64_t session_id) {
      610:  126:    if (session_id <= 0) return NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  127:    
      610:  128:    pthread_mutex_lock(&slot_mutex);
call    0 returned 100%
        -:  129:    
      610:  130:    int slot = session_id - 1;  // Convert back to 0-based slot
        -:  131:    EnhancedPerformanceMetrics_t* session = NULL;
        -:  132:    
      610:  133:    if (slot >= 0 && slot < 2048 && active_monitor_slots[slot] == 1 && active_monitors[slot] != NULL) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -:  134:        session = active_monitors[slot];
        -:  135:    }
        -:  136:    
      610:  137:    pthread_mutex_unlock(&slot_mutex);
call    0 returned 100%
      610:  138:    return session;
        -:  139:}
------------------
find_session_by_id:
function find_session_by_id called 21737 returned 100% blocks executed 100%
    21737:  125:static EnhancedPerformanceMetrics_t* find_session_by_id(int64_t session_id) {
    21737:  126:    if (session_id <= 0) return NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  127:    
    21737:  128:    pthread_mutex_lock(&slot_mutex);
call    0 returned 100%
        -:  129:    
    21737:  130:    int slot = session_id - 1;  // Convert back to 0-based slot
        -:  131:    EnhancedPerformanceMetrics_t* session = NULL;
        -:  132:    
    21737:  133:    if (slot >= 0 && slot < 2048 && active_monitor_slots[slot] == 1 && active_monitors[slot] != NULL) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
        -:  134:        session = active_monitors[slot];
        -:  135:    }
        -:  136:    
    21737:  137:    pthread_mutex_unlock(&slot_mutex);
call    0 returned 100%
    21737:  138:    return session;
        -:  139:}
------------------
        -:  140:
        -:  141:/**
        -:  142: * @brief Find active session for current thread using thread-local session ID
        -:  143: * @return Pointer to active session metrics, NULL if none found
        -:  144: */
        -:  145:static EnhancedPerformanceMetrics_t* find_current_session(void) {
    22554:  146:    return find_session_by_id(current_session_id);
        -:  147:}
        -:  148:
        -:  149:/**
        -:  150: * @brief Increment query counter for current active session (called from Django hooks)
        -:  151: */
    13468:  152:void increment_query_count(void) {
        -:  153:    // Update global counter for backward compatibility
    13468:  154:    global_query_count++;
        -:  155:    
        -:  156:    // Update current session counter for accurate per-session tracking
        -:  157:    EnhancedPerformanceMetrics_t* session = find_current_session();
    13468:  158:    if (session != NULL) {
    13463:  159:        pthread_mutex_lock(&session->session_mutex);
    13463:  160:        session->session_query_count++;
    13463:  161:        pthread_mutex_unlock(&session->session_mutex);
        -:  162:    }
    13468:  163:}
------------------
increment_query_count:
function increment_query_count called 164 returned 100% blocks executed 100%
      164:  152:void increment_query_count(void) {
        -:  153:    // Update global counter for backward compatibility
      164:  154:    global_query_count++;
call    0 returned 100%
        -:  155:    
        -:  156:    // Update current session counter for accurate per-session tracking
        -:  157:    EnhancedPerformanceMetrics_t* session = find_current_session();
      164:  158:    if (session != NULL) {
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
      159:  159:        pthread_mutex_lock(&session->session_mutex);
call    0 returned 100%
      159:  160:        session->session_query_count++;
      159:  161:        pthread_mutex_unlock(&session->session_mutex);
call    0 returned 100%
        -:  162:    }
      164:  163:}
------------------
increment_query_count:
function increment_query_count called 487 returned 100% blocks executed 100%
      487:  152:void increment_query_count(void) {
        -:  153:    // Update global counter for backward compatibility
      487:  154:    global_query_count++;
call    0 returned 100%
        -:  155:    
        -:  156:    // Update current session counter for accurate per-session tracking
        -:  157:    EnhancedPerformanceMetrics_t* session = find_current_session();
      487:  158:    if (session != NULL) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      487:  159:        pthread_mutex_lock(&session->session_mutex);
call    0 returned 100%
      487:  160:        session->session_query_count++;
      487:  161:        pthread_mutex_unlock(&session->session_mutex);
call    0 returned 100%
        -:  162:    }
      487:  163:}
------------------
increment_query_count:
function increment_query_count called 12817 returned 100% blocks executed 100%
    12817:  152:void increment_query_count(void) {
        -:  153:    // Update global counter for backward compatibility
    12817:  154:    global_query_count++;
call    0 returned 100%
        -:  155:    
        -:  156:    // Update current session counter for accurate per-session tracking
        -:  157:    EnhancedPerformanceMetrics_t* session = find_current_session();
    12817:  158:    if (session != NULL) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
    12817:  159:        pthread_mutex_lock(&session->session_mutex);
call    0 returned 100%
    12817:  160:        session->session_query_count++;
    12817:  161:        pthread_mutex_unlock(&session->session_mutex);
call    0 returned 100%
        -:  162:    }
    12817:  163:}
------------------
        -:  164:
        -:  165:/**
        -:  166: * @brief Increment cache hits counter for current active session (called from Django hooks)
        -:  167: */
     5683:  168:void increment_cache_hits(void) {
        -:  169:    // Update global counter for backward compatibility
     5683:  170:    global_cache_hits++;
        -:  171:    
        -:  172:    // Update current session counter for accurate per-session tracking
        -:  173:    EnhancedPerformanceMetrics_t* session = find_current_session();
     5683:  174:    if (session != NULL) {
     5680:  175:        pthread_mutex_lock(&session->session_mutex);
     5680:  176:        session->session_cache_hits++;
     5680:  177:        pthread_mutex_unlock(&session->session_mutex);
        -:  178:    }
     5683:  179:}
------------------
increment_cache_hits:
function increment_cache_hits called 38 returned 100% blocks executed 100%
       38:  168:void increment_cache_hits(void) {
        -:  169:    // Update global counter for backward compatibility
       38:  170:    global_cache_hits++;
call    0 returned 100%
        -:  171:    
        -:  172:    // Update current session counter for accurate per-session tracking
        -:  173:    EnhancedPerformanceMetrics_t* session = find_current_session();
       38:  174:    if (session != NULL) {
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
       35:  175:        pthread_mutex_lock(&session->session_mutex);
call    0 returned 100%
       35:  176:        session->session_cache_hits++;
       35:  177:        pthread_mutex_unlock(&session->session_mutex);
call    0 returned 100%
        -:  178:    }
       38:  179:}
------------------
increment_cache_hits:
function increment_cache_hits called 85 returned 100% blocks executed 100%
       85:  168:void increment_cache_hits(void) {
        -:  169:    // Update global counter for backward compatibility
       85:  170:    global_cache_hits++;
call    0 returned 100%
        -:  171:    
        -:  172:    // Update current session counter for accurate per-session tracking
        -:  173:    EnhancedPerformanceMetrics_t* session = find_current_session();
       85:  174:    if (session != NULL) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       85:  175:        pthread_mutex_lock(&session->session_mutex);
call    0 returned 100%
       85:  176:        session->session_cache_hits++;
       85:  177:        pthread_mutex_unlock(&session->session_mutex);
call    0 returned 100%
        -:  178:    }
       85:  179:}
------------------
increment_cache_hits:
function increment_cache_hits called 5560 returned 100% blocks executed 100%
     5560:  168:void increment_cache_hits(void) {
        -:  169:    // Update global counter for backward compatibility
     5560:  170:    global_cache_hits++;
call    0 returned 100%
        -:  171:    
        -:  172:    // Update current session counter for accurate per-session tracking
        -:  173:    EnhancedPerformanceMetrics_t* session = find_current_session();
     5560:  174:    if (session != NULL) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     5560:  175:        pthread_mutex_lock(&session->session_mutex);
call    0 returned 100%
     5560:  176:        session->session_cache_hits++;
     5560:  177:        pthread_mutex_unlock(&session->session_mutex);
call    0 returned 100%
        -:  178:    }
     5560:  179:}
------------------
        -:  180:
        -:  181:/**
        -:  182: * @brief Increment cache misses counter for current active session (called from Django hooks)
        -:  183: */
     3403:  184:void increment_cache_misses(void) {
        -:  185:    // Update global counter for backward compatibility  
     3403:  186:    global_cache_misses++;
        -:  187:    
        -:  188:    // Update current session counter for accurate per-session tracking
        -:  189:    EnhancedPerformanceMetrics_t* session = find_current_session();
     3403:  190:    if (session != NULL) {
     3401:  191:        pthread_mutex_lock(&session->session_mutex);
     3401:  192:        session->session_cache_misses++;
     3401:  193:        pthread_mutex_unlock(&session->session_mutex);
        -:  194:    }
     3403:  195:}
------------------
increment_cache_misses:
function increment_cache_misses called 5 returned 100% blocks executed 100%
        5:  184:void increment_cache_misses(void) {
        -:  185:    // Update global counter for backward compatibility  
        5:  186:    global_cache_misses++;
call    0 returned 100%
        -:  187:    
        -:  188:    // Update current session counter for accurate per-session tracking
        -:  189:    EnhancedPerformanceMetrics_t* session = find_current_session();
        5:  190:    if (session != NULL) {
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
        3:  191:        pthread_mutex_lock(&session->session_mutex);
call    0 returned 100%
        3:  192:        session->session_cache_misses++;
        3:  193:        pthread_mutex_unlock(&session->session_mutex);
call    0 returned 100%
        -:  194:    }
        5:  195:}
------------------
increment_cache_misses:
function increment_cache_misses called 38 returned 100% blocks executed 100%
       38:  184:void increment_cache_misses(void) {
        -:  185:    // Update global counter for backward compatibility  
       38:  186:    global_cache_misses++;
call    0 returned 100%
        -:  187:    
        -:  188:    // Update current session counter for accurate per-session tracking
        -:  189:    EnhancedPerformanceMetrics_t* session = find_current_session();
       38:  190:    if (session != NULL) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       38:  191:        pthread_mutex_lock(&session->session_mutex);
call    0 returned 100%
       38:  192:        session->session_cache_misses++;
       38:  193:        pthread_mutex_unlock(&session->session_mutex);
call    0 returned 100%
        -:  194:    }
       38:  195:}
------------------
increment_cache_misses:
function increment_cache_misses called 3360 returned 100% blocks executed 100%
     3360:  184:void increment_cache_misses(void) {
        -:  185:    // Update global counter for backward compatibility  
     3360:  186:    global_cache_misses++;
call    0 returned 100%
        -:  187:    
        -:  188:    // Update current session counter for accurate per-session tracking
        -:  189:    EnhancedPerformanceMetrics_t* session = find_current_session();
     3360:  190:    if (session != NULL) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     3360:  191:        pthread_mutex_lock(&session->session_mutex);
call    0 returned 100%
     3360:  192:        session->session_cache_misses++;
     3360:  193:        pthread_mutex_unlock(&session->session_mutex);
call    0 returned 100%
        -:  194:    }
     3360:  195:}
------------------
        -:  196:
        -:  197:// --- Performance Monitoring Lifecycle ---
        -:  198:
        -:  199:/**
        -:  200: * @brief Start enhanced performance monitoring for a Django operation
        -:  201: * 
        -:  202: * Initializes performance tracking with operation-specific context.
        -:  203: * Captures baseline metrics including memory, and Django counters.
        -:  204: * 
        -:  205: * @param operation_name Name of the operation being monitored
        -:  206: * @param operation_type Type of operation (view, model, serializer, query)
        -:  207: * @return Handle for the monitoring session, -1 on error
        -:  208: */
     3856:  209:int64_t start_performance_monitoring_enhanced(const char* operation_name, const char* operation_type) {
     3856:  210:    if (!operation_name || !operation_type) {
       3*:  211:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Operation name and type cannot be NULL");
       3*:  212:        return -1;
        -:  213:    }
        -:  214:    
        -:  215:    // Thread-safe slot allocation
     3853:  216:    pthread_mutex_lock(&slot_mutex);
        -:  217:    
        -:  218:    // Find next available slot and mark it as taken immediately
        -:  219:    int slot = -1;
  2131077:  220:    for (int i = 0; i < 2048; i++) {
  2131075:  221:        if (active_monitor_slots[i] == 0) {
        -:  222:            slot = i;
     3851:  223:            active_monitor_slots[i] = 1;  // Mark as taken immediately
     3851:  224:            break;
        -:  225:        }
        -:  226:    }
        -:  227:    
     3853:  228:    if (slot == -1) {
       2*:  229:        pthread_mutex_unlock(&slot_mutex);
       2*:  230:        return -1;  // No available slots
        -:  231:    }
        -:  232:    
     3851:  233:    pthread_mutex_unlock(&slot_mutex);
        -:  234:    
        -:  235:    // Allocate new metrics structure (outside the critical section)
     3851:  236:    EnhancedPerformanceMetrics_t* metrics = (EnhancedPerformanceMetrics_t*)calloc(1, sizeof(EnhancedPerformanceMetrics_t));
     3851:  237:    if (!metrics) {
        -:  238:        // Clean up the slot if allocation fails
    #####:  239:        pthread_mutex_lock(&slot_mutex);
    #####:  240:        active_monitor_slots[slot] = 0;
    #####:  241:        pthread_mutex_unlock(&slot_mutex);
    #####:  242:        return -1;
        -:  243:    }
        -:  244:    
        -:  245:    // Set the monitor pointer (no need for mutex as slot is already reserved)
     3851:  246:    active_monitors[slot] = metrics;
        -:  247:    
        -:  248:    // Initialize operation metadata
     3851:  249:    strncpy(metrics->operation_name, operation_name, sizeof(metrics->operation_name) - 1);
     3851:  250:    metrics->operation_name[sizeof(metrics->operation_name) - 1] = '\0';
        -:  251:    
     3851:  252:    strncpy(metrics->operation_type, operation_type, sizeof(metrics->operation_type) - 1);
     3851:  253:    metrics->operation_type[sizeof(metrics->operation_type) - 1] = '\0';
        -:  254:    
        -:  255:    // Initialize session-specific data
     3851:  256:    metrics->session_id = slot + 1;  // Use slot+1 as session ID
        -:  257:    
        -:  258:    // Initialize per-session mutex
     3851:  259:    if (pthread_mutex_init(&metrics->session_mutex, NULL) != 0) {
        -:  260:        // Clean up on mutex initialization failure
    #####:  261:        pthread_mutex_lock(&slot_mutex);
    #####:  262:        active_monitor_slots[slot] = 0;
    #####:  263:        pthread_mutex_unlock(&slot_mutex);
    #####:  264:        free(metrics);
    #####:  265:        return -1;
        -:  266:    }
        -:  267:    
        -:  268:    // Capture baseline metrics
     3851:  269:    metrics->start_time_ns = get_current_time_ns();
     3851:  270:    metrics->end_time_ns = 0;
     3851:  271:    metrics->memory_start_bytes = get_memory_usage_bytes();
     3851:  272:    metrics->memory_peak_bytes = metrics->memory_start_bytes;
     3851:  273:    metrics->memory_end_bytes = 0;
        -:  274:    
        -:  275:    // Initialize per-session counters (start at 0 for isolated tracking)
     3851:  276:    metrics->session_query_count = 0;
     3851:  277:    metrics->session_cache_hits = 0;
     3851:  278:    metrics->session_cache_misses = 0;
        -:  279:    
        -:  280:    // Set this session as the current session for this thread
        -:  281:    int64_t session_id = slot + 1;
     3851:  282:    set_current_session_id(session_id);
        -:  283:    
     3851:  284:    return session_id;  // Return 1-based handle
        -:  285:}
------------------
start_performance_monitoring_enhanced:
function start_performance_monitoring_enhanced called 17 returned 100% blocks executed 69%
       17:  209:int64_t start_performance_monitoring_enhanced(const char* operation_name, const char* operation_type) {
       17:  210:    if (!operation_name || !operation_type) {
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        2:  211:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Operation name and type cannot be NULL");
        2:  212:        return -1;
        -:  213:    }
        -:  214:    
        -:  215:    // Thread-safe slot allocation
       15:  216:    pthread_mutex_lock(&slot_mutex);
call    0 returned 100%
        -:  217:    
        -:  218:    // Find next available slot and mark it as taken immediately
        -:  219:    int slot = -1;
       25:  220:    for (int i = 0; i < 2048; i++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
       25:  221:        if (active_monitor_slots[i] == 0) {
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
        -:  222:            slot = i;
       15:  223:            active_monitor_slots[i] = 1;  // Mark as taken immediately
       15:  224:            break;
        -:  225:        }
        -:  226:    }
        -:  227:    
       15:  228:    if (slot == -1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  229:        pthread_mutex_unlock(&slot_mutex);
call    0 never executed
    #####:  230:        return -1;  // No available slots
        -:  231:    }
        -:  232:    
       15:  233:    pthread_mutex_unlock(&slot_mutex);
call    0 returned 100%
        -:  234:    
        -:  235:    // Allocate new metrics structure (outside the critical section)
       15:  236:    EnhancedPerformanceMetrics_t* metrics = (EnhancedPerformanceMetrics_t*)calloc(1, sizeof(EnhancedPerformanceMetrics_t));
       15:  237:    if (!metrics) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  238:        // Clean up the slot if allocation fails
    #####:  239:        pthread_mutex_lock(&slot_mutex);
call    0 never executed
    #####:  240:        active_monitor_slots[slot] = 0;
    #####:  241:        pthread_mutex_unlock(&slot_mutex);
call    0 never executed
    #####:  242:        return -1;
        -:  243:    }
        -:  244:    
        -:  245:    // Set the monitor pointer (no need for mutex as slot is already reserved)
       15:  246:    active_monitors[slot] = metrics;
        -:  247:    
        -:  248:    // Initialize operation metadata
       15:  249:    strncpy(metrics->operation_name, operation_name, sizeof(metrics->operation_name) - 1);
call    0 returned 100%
       15:  250:    metrics->operation_name[sizeof(metrics->operation_name) - 1] = '\0';
        -:  251:    
       15:  252:    strncpy(metrics->operation_type, operation_type, sizeof(metrics->operation_type) - 1);
       15:  253:    metrics->operation_type[sizeof(metrics->operation_type) - 1] = '\0';
        -:  254:    
        -:  255:    // Initialize session-specific data
       15:  256:    metrics->session_id = slot + 1;  // Use slot+1 as session ID
        -:  257:    
        -:  258:    // Initialize per-session mutex
       15:  259:    if (pthread_mutex_init(&metrics->session_mutex, NULL) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  260:        // Clean up on mutex initialization failure
    #####:  261:        pthread_mutex_lock(&slot_mutex);
call    0 never executed
    #####:  262:        active_monitor_slots[slot] = 0;
    #####:  263:        pthread_mutex_unlock(&slot_mutex);
call    0 never executed
    #####:  264:        free(metrics);
    #####:  265:        return -1;
        -:  266:    }
        -:  267:    
        -:  268:    // Capture baseline metrics
       15:  269:    metrics->start_time_ns = get_current_time_ns();
       15:  270:    metrics->end_time_ns = 0;
       15:  271:    metrics->memory_start_bytes = get_memory_usage_bytes();
call    0 returned 100%
       15:  272:    metrics->memory_peak_bytes = metrics->memory_start_bytes;
       15:  273:    metrics->memory_end_bytes = 0;
        -:  274:    
        -:  275:    // Initialize per-session counters (start at 0 for isolated tracking)
       15:  276:    metrics->session_query_count = 0;
       15:  277:    metrics->session_cache_hits = 0;
       15:  278:    metrics->session_cache_misses = 0;
        -:  279:    
        -:  280:    // Set this session as the current session for this thread
        -:  281:    int64_t session_id = slot + 1;
       15:  282:    set_current_session_id(session_id);
call    0 returned 100%
        -:  283:    
       15:  284:    return session_id;  // Return 1-based handle
        -:  285:}
------------------
start_performance_monitoring_enhanced:
function start_performance_monitoring_enhanced called 26 returned 100% blocks executed 69%
       26:  209:int64_t start_performance_monitoring_enhanced(const char* operation_name, const char* operation_type) {
       26:  210:    if (!operation_name || !operation_type) {
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        1:  211:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Operation name and type cannot be NULL");
        1:  212:        return -1;
        -:  213:    }
        -:  214:    
        -:  215:    // Thread-safe slot allocation
       25:  216:    pthread_mutex_lock(&slot_mutex);
call    0 returned 100%
        -:  217:    
        -:  218:    // Find next available slot and mark it as taken immediately
        -:  219:    int slot = -1;
       31:  220:    for (int i = 0; i < 2048; i++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
       31:  221:        if (active_monitor_slots[i] == 0) {
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
        -:  222:            slot = i;
       25:  223:            active_monitor_slots[i] = 1;  // Mark as taken immediately
       25:  224:            break;
        -:  225:        }
        -:  226:    }
        -:  227:    
       25:  228:    if (slot == -1) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  229:        pthread_mutex_unlock(&slot_mutex);
call    0 never executed
    #####:  230:        return -1;  // No available slots
        -:  231:    }
        -:  232:    
       25:  233:    pthread_mutex_unlock(&slot_mutex);
call    0 returned 100%
        -:  234:    
        -:  235:    // Allocate new metrics structure (outside the critical section)
       25:  236:    EnhancedPerformanceMetrics_t* metrics = (EnhancedPerformanceMetrics_t*)calloc(1, sizeof(EnhancedPerformanceMetrics_t));
       25:  237:    if (!metrics) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  238:        // Clean up the slot if allocation fails
    #####:  239:        pthread_mutex_lock(&slot_mutex);
call    0 never executed
    #####:  240:        active_monitor_slots[slot] = 0;
    #####:  241:        pthread_mutex_unlock(&slot_mutex);
call    0 never executed
    #####:  242:        return -1;
        -:  243:    }
        -:  244:    
        -:  245:    // Set the monitor pointer (no need for mutex as slot is already reserved)
       25:  246:    active_monitors[slot] = metrics;
        -:  247:    
        -:  248:    // Initialize operation metadata
       25:  249:    strncpy(metrics->operation_name, operation_name, sizeof(metrics->operation_name) - 1);
call    0 returned 100%
       25:  250:    metrics->operation_name[sizeof(metrics->operation_name) - 1] = '\0';
        -:  251:    
       25:  252:    strncpy(metrics->operation_type, operation_type, sizeof(metrics->operation_type) - 1);
       25:  253:    metrics->operation_type[sizeof(metrics->operation_type) - 1] = '\0';
        -:  254:    
        -:  255:    // Initialize session-specific data
       25:  256:    metrics->session_id = slot + 1;  // Use slot+1 as session ID
        -:  257:    
        -:  258:    // Initialize per-session mutex
       25:  259:    if (pthread_mutex_init(&metrics->session_mutex, NULL) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  260:        // Clean up on mutex initialization failure
    #####:  261:        pthread_mutex_lock(&slot_mutex);
call    0 never executed
    #####:  262:        active_monitor_slots[slot] = 0;
    #####:  263:        pthread_mutex_unlock(&slot_mutex);
call    0 never executed
    #####:  264:        free(metrics);
    #####:  265:        return -1;
        -:  266:    }
        -:  267:    
        -:  268:    // Capture baseline metrics
       25:  269:    metrics->start_time_ns = get_current_time_ns();
       25:  270:    metrics->end_time_ns = 0;
       25:  271:    metrics->memory_start_bytes = get_memory_usage_bytes();
call    0 returned 100%
       25:  272:    metrics->memory_peak_bytes = metrics->memory_start_bytes;
       25:  273:    metrics->memory_end_bytes = 0;
        -:  274:    
        -:  275:    // Initialize per-session counters (start at 0 for isolated tracking)
       25:  276:    metrics->session_query_count = 0;
       25:  277:    metrics->session_cache_hits = 0;
       25:  278:    metrics->session_cache_misses = 0;
        -:  279:    
        -:  280:    // Set this session as the current session for this thread
        -:  281:    int64_t session_id = slot + 1;
       25:  282:    set_current_session_id(session_id);
call    0 returned 100%
        -:  283:    
       25:  284:    return session_id;  // Return 1-based handle
        -:  285:}
------------------
start_performance_monitoring_enhanced:
function start_performance_monitoring_enhanced called 3813 returned 100% blocks executed 73%
     3813:  209:int64_t start_performance_monitoring_enhanced(const char* operation_name, const char* operation_type) {
     3813:  210:    if (!operation_name || !operation_type) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  211:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Operation name and type cannot be NULL");
    #####:  212:        return -1;
        -:  213:    }
        -:  214:    
        -:  215:    // Thread-safe slot allocation
     3813:  216:    pthread_mutex_lock(&slot_mutex);
call    0 returned 100%
        -:  217:    
        -:  218:    // Find next available slot and mark it as taken immediately
        -:  219:    int slot = -1;
  2131021:  220:    for (int i = 0; i < 2048; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
  2131019:  221:        if (active_monitor_slots[i] == 0) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  222:            slot = i;
     3811:  223:            active_monitor_slots[i] = 1;  // Mark as taken immediately
     3811:  224:            break;
        -:  225:        }
        -:  226:    }
        -:  227:    
     3813:  228:    if (slot == -1) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        2:  229:        pthread_mutex_unlock(&slot_mutex);
call    0 returned 100%
        2:  230:        return -1;  // No available slots
        -:  231:    }
        -:  232:    
     3811:  233:    pthread_mutex_unlock(&slot_mutex);
call    0 returned 100%
        -:  234:    
        -:  235:    // Allocate new metrics structure (outside the critical section)
     3811:  236:    EnhancedPerformanceMetrics_t* metrics = (EnhancedPerformanceMetrics_t*)calloc(1, sizeof(EnhancedPerformanceMetrics_t));
     3811:  237:    if (!metrics) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  238:        // Clean up the slot if allocation fails
    #####:  239:        pthread_mutex_lock(&slot_mutex);
call    0 never executed
    #####:  240:        active_monitor_slots[slot] = 0;
    #####:  241:        pthread_mutex_unlock(&slot_mutex);
call    0 never executed
    #####:  242:        return -1;
        -:  243:    }
        -:  244:    
        -:  245:    // Set the monitor pointer (no need for mutex as slot is already reserved)
     3811:  246:    active_monitors[slot] = metrics;
        -:  247:    
        -:  248:    // Initialize operation metadata
     3811:  249:    strncpy(metrics->operation_name, operation_name, sizeof(metrics->operation_name) - 1);
call    0 returned 100%
     3811:  250:    metrics->operation_name[sizeof(metrics->operation_name) - 1] = '\0';
        -:  251:    
     3811:  252:    strncpy(metrics->operation_type, operation_type, sizeof(metrics->operation_type) - 1);
     3811:  253:    metrics->operation_type[sizeof(metrics->operation_type) - 1] = '\0';
        -:  254:    
        -:  255:    // Initialize session-specific data
     3811:  256:    metrics->session_id = slot + 1;  // Use slot+1 as session ID
        -:  257:    
        -:  258:    // Initialize per-session mutex
     3811:  259:    if (pthread_mutex_init(&metrics->session_mutex, NULL) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  260:        // Clean up on mutex initialization failure
    #####:  261:        pthread_mutex_lock(&slot_mutex);
call    0 never executed
    #####:  262:        active_monitor_slots[slot] = 0;
    #####:  263:        pthread_mutex_unlock(&slot_mutex);
call    0 never executed
    #####:  264:        free(metrics);
    #####:  265:        return -1;
        -:  266:    }
        -:  267:    
        -:  268:    // Capture baseline metrics
     3811:  269:    metrics->start_time_ns = get_current_time_ns();
     3811:  270:    metrics->end_time_ns = 0;
     3811:  271:    metrics->memory_start_bytes = get_memory_usage_bytes();
call    0 returned 100%
     3811:  272:    metrics->memory_peak_bytes = metrics->memory_start_bytes;
     3811:  273:    metrics->memory_end_bytes = 0;
        -:  274:    
        -:  275:    // Initialize per-session counters (start at 0 for isolated tracking)
     3811:  276:    metrics->session_query_count = 0;
     3811:  277:    metrics->session_cache_hits = 0;
     3811:  278:    metrics->session_cache_misses = 0;
        -:  279:    
        -:  280:    // Set this session as the current session for this thread
        -:  281:    int64_t session_id = slot + 1;
     3811:  282:    set_current_session_id(session_id);
call    0 returned 100%
        -:  283:    
     3811:  284:    return session_id;  // Return 1-based handle
        -:  285:}
------------------
        -:  286:
        -:  287:/**
        -:  288: * @brief Stop enhanced performance monitoring and finalize metrics
        -:  289: * 
        -:  290: * Captures final performance metrics and calculates deltas.
        -:  291: * Returns pointer to metrics structure for analysis.
        -:  292: * 
        -:  293: * @param handle Handle returned by start_performance_monitoring_enhanced
        -:  294: * @return Pointer to metrics structure, NULL on error
        -:  295: */
     3843:  296:EnhancedPerformanceMetrics_t* stop_performance_monitoring_enhanced(int64_t handle) {
     3843:  297:    if (handle <= 0) return NULL;
        -:  298:    
     3836:  299:    int slot = handle - 1;
        -:  300:    
        -:  301:    // Thread-safe slot validation and retrieval
     3836:  302:    pthread_mutex_lock(&slot_mutex);
        -:  303:    
     3836:  304:    if (slot < 0 || slot >= 2048 || active_monitor_slots[slot] == 0) {
       5*:  305:        pthread_mutex_unlock(&slot_mutex);
       5*:  306:        return NULL;
        -:  307:    }
        -:  308:    
     3831:  309:    EnhancedPerformanceMetrics_t* metrics = active_monitors[slot];
     3831:  310:    if (!metrics) {
    #####:  311:        pthread_mutex_unlock(&slot_mutex);
    #####:  312:        return NULL;
        -:  313:    }
        -:  314:    
     3831:  315:    pthread_mutex_unlock(&slot_mutex);
        -:  316:    
        -:  317:    // Capture final metrics
     3831:  318:    metrics->end_time_ns = get_current_time_ns();
     3831:  319:    metrics->memory_end_bytes = get_memory_usage_bytes();
        -:  320:    
        -:  321:    // Update peak memory if current is higher
     3831:  322:    if (metrics->memory_end_bytes > metrics->memory_peak_bytes) {
    1632*:  323:        metrics->memory_peak_bytes = metrics->memory_end_bytes;
        -:  324:    }
        -:  325:    
        -:  326:    // Session counters are already accurate (no delta calculation needed)
        -:  327:    // The session-specific counters already contain the correct isolated values
        -:  328:    
        -:  329:    // Thread-safe slot clearing
     3831:  330:    pthread_mutex_lock(&slot_mutex);
     3831:  331:    active_monitor_slots[slot] = 0;
     3831:  332:    active_monitors[slot] = NULL;
     3831:  333:    pthread_mutex_unlock(&slot_mutex);
        -:  334:    
     3831:  335:    return metrics;  // Return the allocated metrics for caller to free
        -:  336:}
------------------
stop_performance_monitoring_enhanced:
function stop_performance_monitoring_enhanced called 16 returned 100% blocks executed 72%
       16:  296:EnhancedPerformanceMetrics_t* stop_performance_monitoring_enhanced(int64_t handle) {
       16:  297:    if (handle <= 0) return NULL;
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        -:  298:    
       15:  299:    int slot = handle - 1;
        -:  300:    
        -:  301:    // Thread-safe slot validation and retrieval
       15:  302:    pthread_mutex_lock(&slot_mutex);
call    0 returned 100%
        -:  303:    
       15:  304:    if (slot < 0 || slot >= 2048 || active_monitor_slots[slot] == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  305:        pthread_mutex_unlock(&slot_mutex);
call    0 never executed
    #####:  306:        return NULL;
        -:  307:    }
        -:  308:    
       15:  309:    EnhancedPerformanceMetrics_t* metrics = active_monitors[slot];
       15:  310:    if (!metrics) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  311:        pthread_mutex_unlock(&slot_mutex);
call    0 never executed
    #####:  312:        return NULL;
        -:  313:    }
        -:  314:    
       15:  315:    pthread_mutex_unlock(&slot_mutex);
call    0 returned 100%
        -:  316:    
        -:  317:    // Capture final metrics
       15:  318:    metrics->end_time_ns = get_current_time_ns();
       15:  319:    metrics->memory_end_bytes = get_memory_usage_bytes();
call    0 returned 100%
        -:  320:    
        -:  321:    // Update peak memory if current is higher
       15:  322:    if (metrics->memory_end_bytes > metrics->memory_peak_bytes) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  323:        metrics->memory_peak_bytes = metrics->memory_end_bytes;
        -:  324:    }
        -:  325:    
        -:  326:    // Session counters are already accurate (no delta calculation needed)
        -:  327:    // The session-specific counters already contain the correct isolated values
        -:  328:    
        -:  329:    // Thread-safe slot clearing
       15:  330:    pthread_mutex_lock(&slot_mutex);
call    0 returned 100%
       15:  331:    active_monitor_slots[slot] = 0;
       15:  332:    active_monitors[slot] = NULL;
       15:  333:    pthread_mutex_unlock(&slot_mutex);
call    0 returned 100%
        -:  334:    
       15:  335:    return metrics;  // Return the allocated metrics for caller to free
        -:  336:}
------------------
stop_performance_monitoring_enhanced:
function stop_performance_monitoring_enhanced called 27 returned 100% blocks executed 78%
       27:  296:EnhancedPerformanceMetrics_t* stop_performance_monitoring_enhanced(int64_t handle) {
       27:  297:    if (handle <= 0) return NULL;
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
        -:  298:    
       25:  299:    int slot = handle - 1;
        -:  300:    
        -:  301:    // Thread-safe slot validation and retrieval
       25:  302:    pthread_mutex_lock(&slot_mutex);
call    0 returned 100%
        -:  303:    
       25:  304:    if (slot < 0 || slot >= 2048 || active_monitor_slots[slot] == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  305:        pthread_mutex_unlock(&slot_mutex);
call    0 never executed
    #####:  306:        return NULL;
        -:  307:    }
        -:  308:    
       25:  309:    EnhancedPerformanceMetrics_t* metrics = active_monitors[slot];
       25:  310:    if (!metrics) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  311:        pthread_mutex_unlock(&slot_mutex);
call    0 never executed
    #####:  312:        return NULL;
        -:  313:    }
        -:  314:    
       25:  315:    pthread_mutex_unlock(&slot_mutex);
call    0 returned 100%
        -:  316:    
        -:  317:    // Capture final metrics
       25:  318:    metrics->end_time_ns = get_current_time_ns();
       25:  319:    metrics->memory_end_bytes = get_memory_usage_bytes();
call    0 returned 100%
        -:  320:    
        -:  321:    // Update peak memory if current is higher
       25:  322:    if (metrics->memory_end_bytes > metrics->memory_peak_bytes) {
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        1:  323:        metrics->memory_peak_bytes = metrics->memory_end_bytes;
        -:  324:    }
        -:  325:    
        -:  326:    // Session counters are already accurate (no delta calculation needed)
        -:  327:    // The session-specific counters already contain the correct isolated values
        -:  328:    
        -:  329:    // Thread-safe slot clearing
       25:  330:    pthread_mutex_lock(&slot_mutex);
call    0 returned 100%
       25:  331:    active_monitor_slots[slot] = 0;
       25:  332:    active_monitors[slot] = NULL;
       25:  333:    pthread_mutex_unlock(&slot_mutex);
call    0 returned 100%
        -:  334:    
       25:  335:    return metrics;  // Return the allocated metrics for caller to free
        -:  336:}
------------------
stop_performance_monitoring_enhanced:
function stop_performance_monitoring_enhanced called 3800 returned 100% blocks executed 89%
     3800:  296:EnhancedPerformanceMetrics_t* stop_performance_monitoring_enhanced(int64_t handle) {
     3800:  297:    if (handle <= 0) return NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:  298:    
     3796:  299:    int slot = handle - 1;
        -:  300:    
        -:  301:    // Thread-safe slot validation and retrieval
     3796:  302:    pthread_mutex_lock(&slot_mutex);
call    0 returned 100%
        -:  303:    
     3796:  304:    if (slot < 0 || slot >= 2048 || active_monitor_slots[slot] == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
branch  2 taken 1% (fallthrough)
branch  3 taken 100%
        5:  305:        pthread_mutex_unlock(&slot_mutex);
call    0 returned 100%
        5:  306:        return NULL;
        -:  307:    }
        -:  308:    
     3791:  309:    EnhancedPerformanceMetrics_t* metrics = active_monitors[slot];
     3791:  310:    if (!metrics) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  311:        pthread_mutex_unlock(&slot_mutex);
call    0 never executed
    #####:  312:        return NULL;
        -:  313:    }
        -:  314:    
     3791:  315:    pthread_mutex_unlock(&slot_mutex);
call    0 returned 100%
        -:  316:    
        -:  317:    // Capture final metrics
     3791:  318:    metrics->end_time_ns = get_current_time_ns();
     3791:  319:    metrics->memory_end_bytes = get_memory_usage_bytes();
call    0 returned 100%
        -:  320:    
        -:  321:    // Update peak memory if current is higher
     3791:  322:    if (metrics->memory_end_bytes > metrics->memory_peak_bytes) {
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
     1631:  323:        metrics->memory_peak_bytes = metrics->memory_end_bytes;
        -:  324:    }
        -:  325:    
        -:  326:    // Session counters are already accurate (no delta calculation needed)
        -:  327:    // The session-specific counters already contain the correct isolated values
        -:  328:    
        -:  329:    // Thread-safe slot clearing
     3791:  330:    pthread_mutex_lock(&slot_mutex);
call    0 returned 100%
     3791:  331:    active_monitor_slots[slot] = 0;
     3791:  332:    active_monitors[slot] = NULL;
     3791:  333:    pthread_mutex_unlock(&slot_mutex);
call    0 returned 100%
        -:  334:    
     3791:  335:    return metrics;  // Return the allocated metrics for caller to free
        -:  336:}
------------------
        -:  337:
        -:  338:/**
        -:  339: * @brief Free metrics structure memory
        -:  340: * @param metrics Pointer to metrics structure allocated by stop_performance_monitoring_enhanced
        -:  341: */
     3832:  342:void free_metrics(EnhancedPerformanceMetrics_t* metrics) {
     3832:  343:    if (metrics) {
        -:  344:        // Clean up the session mutex before freeing
     3831:  345:        pthread_mutex_destroy(&metrics->session_mutex);
     3831:  346:        free(metrics);
        -:  347:    }
     3832:  348:}
------------------
free_metrics:
function free_metrics called 16 returned 100% blocks executed 100%
       16:  342:void free_metrics(EnhancedPerformanceMetrics_t* metrics) {
       16:  343:    if (metrics) {
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        -:  344:        // Clean up the session mutex before freeing
       15:  345:        pthread_mutex_destroy(&metrics->session_mutex);
call    0 returned 100%
       15:  346:        free(metrics);
        -:  347:    }
       16:  348:}
------------------
free_metrics:
function free_metrics called 25 returned 100% blocks executed 100%
       25:  342:void free_metrics(EnhancedPerformanceMetrics_t* metrics) {
       25:  343:    if (metrics) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  344:        // Clean up the session mutex before freeing
       25:  345:        pthread_mutex_destroy(&metrics->session_mutex);
call    0 returned 100%
       25:  346:        free(metrics);
        -:  347:    }
       25:  348:}
------------------
free_metrics:
function free_metrics called 3791 returned 100% blocks executed 100%
     3791:  342:void free_metrics(EnhancedPerformanceMetrics_t* metrics) {
     3791:  343:    if (metrics) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  344:        // Clean up the session mutex before freeing
     3791:  345:        pthread_mutex_destroy(&metrics->session_mutex);
call    0 returned 100%
     3791:  346:        free(metrics);
        -:  347:    }
     3791:  348:}
------------------
        -:  349:
        -:  350:// --- Performance Metric Accessors ---
        -:  351:
        -:  352:/**
        -:  353: * @brief Get elapsed time in milliseconds
        -:  354: * @param metrics Pointer to performance metrics structure
        -:  355: * @return Elapsed time in milliseconds, -1.0 on error
        -:  356: */
      494:  357:double get_elapsed_time_ms(EnhancedPerformanceMetrics_t* metrics) {
      494:  358:    if (!metrics || metrics->end_time_ns == 0) return -1.0;
        -:  359:    
      494:  360:    uint64_t elapsed_ns = metrics->end_time_ns - metrics->start_time_ns;
      494:  361:    return (double)elapsed_ns / 1000000.0;
        -:  362:}
------------------
get_elapsed_time_ms:
function get_elapsed_time_ms called 10 returned 100% blocks executed 100%
       10:  357:double get_elapsed_time_ms(EnhancedPerformanceMetrics_t* metrics) {
       10:  358:    if (!metrics || metrics->end_time_ns == 0) return -1.0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  359:    
       10:  360:    uint64_t elapsed_ns = metrics->end_time_ns - metrics->start_time_ns;
       10:  361:    return (double)elapsed_ns / 1000000.0;
        -:  362:}
------------------
get_elapsed_time_ms:
function get_elapsed_time_ms called 47 returned 100% blocks executed 100%
       47:  357:double get_elapsed_time_ms(EnhancedPerformanceMetrics_t* metrics) {
       47:  358:    if (!metrics || metrics->end_time_ns == 0) return -1.0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  359:    
       47:  360:    uint64_t elapsed_ns = metrics->end_time_ns - metrics->start_time_ns;
       47:  361:    return (double)elapsed_ns / 1000000.0;
        -:  362:}
------------------
get_elapsed_time_ms:
function get_elapsed_time_ms called 437 returned 100% blocks executed 100%
      437:  357:double get_elapsed_time_ms(EnhancedPerformanceMetrics_t* metrics) {
      437:  358:    if (!metrics || metrics->end_time_ns == 0) return -1.0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  359:    
      437:  360:    uint64_t elapsed_ns = metrics->end_time_ns - metrics->start_time_ns;
      437:  361:    return (double)elapsed_ns / 1000000.0;
        -:  362:}
------------------
        -:  363:
        -:  364:/**
        -:  365: * @brief Get peak memory usage in megabytes
        -:  366: * @param metrics Pointer to performance metrics structure
        -:  367: * @return Peak memory usage in MB, -1.0 on error
        -:  368: */
       3*:  369:double get_memory_usage_mb(EnhancedPerformanceMetrics_t* metrics) {
       3*:  370:    if (!metrics) return -1.0;
       3*:  371:    return (double)metrics->memory_peak_bytes / (1024.0 * 1024.0);
        -:  372:}
------------------
get_memory_usage_mb:
function get_memory_usage_mb called 0 returned 0% blocks executed 0%
    #####:  369:double get_memory_usage_mb(EnhancedPerformanceMetrics_t* metrics) {
    #####:  370:    if (!metrics) return -1.0;
branch  0 never executed
branch  1 never executed
    #####:  371:    return (double)metrics->memory_peak_bytes / (1024.0 * 1024.0);
        -:  372:}
------------------
get_memory_usage_mb:
function get_memory_usage_mb called 3 returned 100% blocks executed 100%
        3:  369:double get_memory_usage_mb(EnhancedPerformanceMetrics_t* metrics) {
        3:  370:    if (!metrics) return -1.0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  371:    return (double)metrics->memory_peak_bytes / (1024.0 * 1024.0);
        -:  372:}
------------------
get_memory_usage_mb:
function get_memory_usage_mb called 0 returned 0% blocks executed 0%
    #####:  369:double get_memory_usage_mb(EnhancedPerformanceMetrics_t* metrics) {
    #####:  370:    if (!metrics) return -1.0;
branch  0 never executed
branch  1 never executed
    #####:  371:    return (double)metrics->memory_peak_bytes / (1024.0 * 1024.0);
        -:  372:}
------------------
        -:  373:
        -:  374:/**
        -:  375: * @brief Get memory usage delta in megabytes
        -:  376: * @param metrics Pointer to performance metrics structure
        -:  377: * @return Memory delta in MB (end - start), can be negative
        -:  378: */
       3*:  379:double get_memory_delta_mb(EnhancedPerformanceMetrics_t* metrics) {
       3*:  380:    if (!metrics) return -1.0;
       3*:  381:    int64_t delta = (int64_t)metrics->memory_end_bytes - (int64_t)metrics->memory_start_bytes;
       3*:  382:    return (double)delta / (1024.0 * 1024.0);
        -:  383:}
------------------
get_memory_delta_mb:
function get_memory_delta_mb called 0 returned 0% blocks executed 0%
    #####:  379:double get_memory_delta_mb(EnhancedPerformanceMetrics_t* metrics) {
    #####:  380:    if (!metrics) return -1.0;
branch  0 never executed
branch  1 never executed
    #####:  381:    int64_t delta = (int64_t)metrics->memory_end_bytes - (int64_t)metrics->memory_start_bytes;
    #####:  382:    return (double)delta / (1024.0 * 1024.0);
        -:  383:}
------------------
get_memory_delta_mb:
function get_memory_delta_mb called 3 returned 100% blocks executed 100%
        3:  379:double get_memory_delta_mb(EnhancedPerformanceMetrics_t* metrics) {
        3:  380:    if (!metrics) return -1.0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  381:    int64_t delta = (int64_t)metrics->memory_end_bytes - (int64_t)metrics->memory_start_bytes;
        3:  382:    return (double)delta / (1024.0 * 1024.0);
        -:  383:}
------------------
get_memory_delta_mb:
function get_memory_delta_mb called 0 returned 0% blocks executed 0%
    #####:  379:double get_memory_delta_mb(EnhancedPerformanceMetrics_t* metrics) {
    #####:  380:    if (!metrics) return -1.0;
branch  0 never executed
branch  1 never executed
    #####:  381:    int64_t delta = (int64_t)metrics->memory_end_bytes - (int64_t)metrics->memory_start_bytes;
    #####:  382:    return (double)delta / (1024.0 * 1024.0);
        -:  383:}
------------------
        -:  384:
        -:  385:/**
        -:  386: * @brief Get number of database queries executed during operation
        -:  387: * @param metrics Pointer to performance metrics structure
        -:  388: * @return Number of queries, 0 on error
        -:  389: */
      530:  390:uint32_t get_query_count(EnhancedPerformanceMetrics_t* metrics) {
      530:  391:    if (!metrics) return 0;
        -:  392:    // Return the session-specific query count (no delta calculation needed)
      529:  393:    return metrics->session_query_count;
        -:  394:}
------------------
get_query_count:
function get_query_count called 21 returned 100% blocks executed 100%
       21:  390:uint32_t get_query_count(EnhancedPerformanceMetrics_t* metrics) {
       21:  391:    if (!metrics) return 0;
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
        -:  392:    // Return the session-specific query count (no delta calculation needed)
       20:  393:    return metrics->session_query_count;
        -:  394:}
------------------
get_query_count:
function get_query_count called 82 returned 100% blocks executed 100%
       82:  390:uint32_t get_query_count(EnhancedPerformanceMetrics_t* metrics) {
       82:  391:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  392:    // Return the session-specific query count (no delta calculation needed)
       82:  393:    return metrics->session_query_count;
        -:  394:}
------------------
get_query_count:
function get_query_count called 427 returned 100% blocks executed 100%
      427:  390:uint32_t get_query_count(EnhancedPerformanceMetrics_t* metrics) {
      427:  391:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  392:    // Return the session-specific query count (no delta calculation needed)
      427:  393:    return metrics->session_query_count;
        -:  394:}
------------------
        -:  395:
        -:  396:/**
        -:  397: * @brief Get number of cache hits during operation
        -:  398: * @param metrics Pointer to performance metrics structure
        -:  399: * @return Number of cache hits, 0 on error
        -:  400: */
       3*:  401:uint32_t get_cache_hit_count(EnhancedPerformanceMetrics_t* metrics) {
       3*:  402:    if (!metrics) return 0;
        -:  403:    // Return the session-specific cache hits
       2*:  404:    return metrics->session_cache_hits;
        -:  405:}
------------------
get_cache_hit_count:
function get_cache_hit_count called 2 returned 100% blocks executed 100%
        2:  401:uint32_t get_cache_hit_count(EnhancedPerformanceMetrics_t* metrics) {
        2:  402:    if (!metrics) return 0;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  403:    // Return the session-specific cache hits
        1:  404:    return metrics->session_cache_hits;
        -:  405:}
------------------
get_cache_hit_count:
function get_cache_hit_count called 1 returned 100% blocks executed 100%
        1:  401:uint32_t get_cache_hit_count(EnhancedPerformanceMetrics_t* metrics) {
        1:  402:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  403:    // Return the session-specific cache hits
        1:  404:    return metrics->session_cache_hits;
        -:  405:}
------------------
get_cache_hit_count:
function get_cache_hit_count called 0 returned 0% blocks executed 0%
    #####:  401:uint32_t get_cache_hit_count(EnhancedPerformanceMetrics_t* metrics) {
    #####:  402:    if (!metrics) return 0;
branch  0 never executed
branch  1 never executed
        -:  403:    // Return the session-specific cache hits
    #####:  404:    return metrics->session_cache_hits;
        -:  405:}
------------------
        -:  406:
        -:  407:/**
        -:  408: * @brief Get number of cache misses during operation
        -:  409: * @param metrics Pointer to performance metrics structure
        -:  410: * @return Number of cache misses, 0 on error
        -:  411: */
       3*:  412:uint32_t get_cache_miss_count(EnhancedPerformanceMetrics_t* metrics) {
       3*:  413:    if (!metrics) return 0;
        -:  414:    // Return the session-specific cache misses
       2*:  415:    return metrics->session_cache_misses;
        -:  416:}
------------------
get_cache_miss_count:
function get_cache_miss_count called 2 returned 100% blocks executed 100%
        2:  412:uint32_t get_cache_miss_count(EnhancedPerformanceMetrics_t* metrics) {
        2:  413:    if (!metrics) return 0;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  414:    // Return the session-specific cache misses
        1:  415:    return metrics->session_cache_misses;
        -:  416:}
------------------
get_cache_miss_count:
function get_cache_miss_count called 1 returned 100% blocks executed 100%
        1:  412:uint32_t get_cache_miss_count(EnhancedPerformanceMetrics_t* metrics) {
        1:  413:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  414:    // Return the session-specific cache misses
        1:  415:    return metrics->session_cache_misses;
        -:  416:}
------------------
get_cache_miss_count:
function get_cache_miss_count called 0 returned 0% blocks executed 0%
    #####:  412:uint32_t get_cache_miss_count(EnhancedPerformanceMetrics_t* metrics) {
    #####:  413:    if (!metrics) return 0;
branch  0 never executed
branch  1 never executed
        -:  414:    // Return the session-specific cache misses
    #####:  415:    return metrics->session_cache_misses;
        -:  416:}
------------------
        -:  417:
        -:  418:/**
        -:  419: * @brief Get cache hit ratio for the operation
        -:  420: * @param metrics Pointer to performance metrics structure
        -:  421: * @return Cache hit ratio (0.0-1.0), -1.0 on error, 0.0 if no cache ops
        -:  422: */
      10*:  423:double get_cache_hit_ratio(EnhancedPerformanceMetrics_t* metrics) {
      10*:  424:    if (!metrics) return -1.0;
        -:  425:    
      10*:  426:    uint32_t total_cache_ops = metrics->session_cache_hits + metrics->session_cache_misses;
      10*:  427:    if (total_cache_ops == 0) return 0.0;
        -:  428:    
       7*:  429:    return (double)metrics->session_cache_hits / (double)total_cache_ops;
        -:  430:}
------------------
get_cache_hit_ratio:
function get_cache_hit_ratio called 0 returned 0% blocks executed 0%
    #####:  423:double get_cache_hit_ratio(EnhancedPerformanceMetrics_t* metrics) {
    #####:  424:    if (!metrics) return -1.0;
branch  0 never executed
branch  1 never executed
        -:  425:    
    #####:  426:    uint32_t total_cache_ops = metrics->session_cache_hits + metrics->session_cache_misses;
    #####:  427:    if (total_cache_ops == 0) return 0.0;
branch  0 never executed
branch  1 never executed
        -:  428:    
    #####:  429:    return (double)metrics->session_cache_hits / (double)total_cache_ops;
        -:  430:}
------------------
get_cache_hit_ratio:
function get_cache_hit_ratio called 10 returned 100% blocks executed 100%
       10:  423:double get_cache_hit_ratio(EnhancedPerformanceMetrics_t* metrics) {
       10:  424:    if (!metrics) return -1.0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  425:    
       10:  426:    uint32_t total_cache_ops = metrics->session_cache_hits + metrics->session_cache_misses;
       10:  427:    if (total_cache_ops == 0) return 0.0;
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
        -:  428:    
        7:  429:    return (double)metrics->session_cache_hits / (double)total_cache_ops;
        -:  430:}
------------------
get_cache_hit_ratio:
function get_cache_hit_ratio called 0 returned 0% blocks executed 0%
    #####:  423:double get_cache_hit_ratio(EnhancedPerformanceMetrics_t* metrics) {
    #####:  424:    if (!metrics) return -1.0;
branch  0 never executed
branch  1 never executed
        -:  425:    
    #####:  426:    uint32_t total_cache_ops = metrics->session_cache_hits + metrics->session_cache_misses;
    #####:  427:    if (total_cache_ops == 0) return 0.0;
branch  0 never executed
branch  1 never executed
        -:  428:    
    #####:  429:    return (double)metrics->session_cache_hits / (double)total_cache_ops;
        -:  430:}
------------------
        -:  431:
        -:  432:// --- Performance Analysis Functions ---
        -:  433:
        -:  434:/**
        -:  435: * @brief Check if operation has N+1 query pattern
        -:  436: * 
        -:  437: * Uses advanced detection combining severe, moderate, and count-based analysis
        -:  438: * with realistic thresholds for Django applications.
        -:  439: * 
        -:  440: * @param metrics Pointer to performance metrics structure
        -:  441: * @return 1 if N+1 pattern detected, 0 otherwise
        -:  442: */
       29:  443:int has_n_plus_one_pattern(EnhancedPerformanceMetrics_t* metrics) {
       29:  444:    if (!metrics) return 0;
        -:  445:    
       28:  446:    uint32_t query_count = get_query_count(metrics);
        -:  447:    
        -:  448:    // No N+1 pattern possible with fewer than 3 queries
       28:  449:    if (query_count < 3) return 0;
        -:  450:    
       41:  451:    return detect_n_plus_one_severe(metrics) || 
       37:  452:           detect_n_plus_one_moderate(metrics) || 
       11:  453:           detect_n_plus_one_pattern_by_count(metrics);
        -:  454:}
------------------
has_n_plus_one_pattern:
function has_n_plus_one_pattern called 4 returned 100% blocks executed 91%
        4:  443:int has_n_plus_one_pattern(EnhancedPerformanceMetrics_t* metrics) {
        4:  444:    if (!metrics) return 0;
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  445:    
        3:  446:    uint32_t query_count = get_query_count(metrics);
call    0 returned 100%
        -:  447:    
        -:  448:    // No N+1 pattern possible with fewer than 3 queries
        3:  449:    if (query_count < 3) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  450:    
        4:  451:    return detect_n_plus_one_severe(metrics) || 
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        4:  452:           detect_n_plus_one_moderate(metrics) || 
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
call    2 returned 100%
branch  3 taken 0% (fallthrough)
branch  4 taken 100%
        1:  453:           detect_n_plus_one_pattern_by_count(metrics);
call    0 returned 100%
        -:  454:}
------------------
has_n_plus_one_pattern:
function has_n_plus_one_pattern called 14 returned 100% blocks executed 100%
       14:  443:int has_n_plus_one_pattern(EnhancedPerformanceMetrics_t* metrics) {
       14:  444:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  445:    
       14:  446:    uint32_t query_count = get_query_count(metrics);
call    0 returned 100%
        -:  447:    
        -:  448:    // No N+1 pattern possible with fewer than 3 queries
       14:  449:    if (query_count < 3) return 0;
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
        -:  450:    
       22:  451:    return detect_n_plus_one_severe(metrics) || 
call    0 returned 100%
branch  1 taken 56% (fallthrough)
branch  2 taken 44%
       18:  452:           detect_n_plus_one_moderate(metrics) || 
branch  0 taken 69% (fallthrough)
branch  1 taken 31%
call    2 returned 100%
branch  3 taken 40% (fallthrough)
branch  4 taken 60%
        5:  453:           detect_n_plus_one_pattern_by_count(metrics);
call    0 returned 100%
        -:  454:}
------------------
has_n_plus_one_pattern:
function has_n_plus_one_pattern called 11 returned 100% blocks executed 100%
       11:  443:int has_n_plus_one_pattern(EnhancedPerformanceMetrics_t* metrics) {
       11:  444:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  445:    
       11:  446:    uint32_t query_count = get_query_count(metrics);
call    0 returned 100%
        -:  447:    
        -:  448:    // No N+1 pattern possible with fewer than 3 queries
       11:  449:    if (query_count < 3) return 0;
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
        -:  450:    
       15:  451:    return detect_n_plus_one_severe(metrics) || 
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
       15:  452:           detect_n_plus_one_moderate(metrics) || 
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
call    2 returned 100%
branch  3 taken 80% (fallthrough)
branch  4 taken 20%
        5:  453:           detect_n_plus_one_pattern_by_count(metrics);
call    0 returned 100%
        -:  454:}
------------------
        -:  455:
        -:  456:/**
        -:  457: * @brief Detect severe N+1 query patterns
        -:  458: * 
        -:  459: * Identifies clearly problematic query patterns that indicate N+1 issues.
        -:  460: * 
        -:  461: * @param metrics Pointer to performance metrics structure
        -:  462: * @return 1 if severe N+1 detected, 0 otherwise
        -:  463: */
       32:  464:int detect_n_plus_one_severe(EnhancedPerformanceMetrics_t* metrics) {
       32:  465:    if (!metrics) return 0;
        -:  466:    
       31:  467:    uint32_t query_count = get_query_count(metrics);
       31:  468:    double response_time = get_elapsed_time_ms(metrics);
        -:  469:    
        -:  470:    // Debug logging for false positives
       31:  471:    if (query_count == 0) {
    #####:  472:        fprintf(stderr, "DEBUG: detect_n_plus_one_severe called with 0 queries\n");
    #####:  473:        fprintf(stderr, "  session_query_count=%u\n", 
        -:  474:                metrics->session_query_count);
    #####:  475:        return 0;  // No N+1 possible with 0 queries
        -:  476:    }
        -:  477:    
        -:  478:    // SEVERE N+1: More than 20 queries is almost certainly N+1
       31:  479:    if (query_count > 20) return 1;
        -:  480:    
        -:  481:    // SEVERE N+1: More than 10 queries with reasonable response time
      18*:  482:    if (query_count > 10 && response_time > 10) return 1;
        -:  483:    
        -:  484:    return 0;
        -:  485:}
------------------
detect_n_plus_one_severe:
function detect_n_plus_one_severe called 7 returned 100% blocks executed 64%
        7:  464:int detect_n_plus_one_severe(EnhancedPerformanceMetrics_t* metrics) {
        7:  465:    if (!metrics) return 0;
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
        -:  466:    
        6:  467:    uint32_t query_count = get_query_count(metrics);
call    0 returned 100%
        6:  468:    double response_time = get_elapsed_time_ms(metrics);
call    0 returned 100%
        -:  469:    
        -:  470:    // Debug logging for false positives
        6:  471:    if (query_count == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  472:        fprintf(stderr, "DEBUG: detect_n_plus_one_severe called with 0 queries\n");
call    0 never executed
    #####:  473:        fprintf(stderr, "  session_query_count=%u\n", 
call    0 never executed
        -:  474:                metrics->session_query_count);
    #####:  475:        return 0;  // No N+1 possible with 0 queries
        -:  476:    }
        -:  477:    
        -:  478:    // SEVERE N+1: More than 20 queries is almost certainly N+1
        6:  479:    if (query_count > 20) return 1;
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:  480:    
        -:  481:    // SEVERE N+1: More than 10 queries with reasonable response time
       2*:  482:    if (query_count > 10 && response_time > 10) return 1;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  483:    
        -:  484:    return 0;
        -:  485:}
------------------
detect_n_plus_one_severe:
function detect_n_plus_one_severe called 15 returned 100% blocks executed 73%
       15:  464:int detect_n_plus_one_severe(EnhancedPerformanceMetrics_t* metrics) {
       15:  465:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  466:    
       15:  467:    uint32_t query_count = get_query_count(metrics);
call    0 returned 100%
       15:  468:    double response_time = get_elapsed_time_ms(metrics);
call    0 returned 100%
        -:  469:    
        -:  470:    // Debug logging for false positives
       15:  471:    if (query_count == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  472:        fprintf(stderr, "DEBUG: detect_n_plus_one_severe called with 0 queries\n");
call    0 never executed
    #####:  473:        fprintf(stderr, "  session_query_count=%u\n", 
call    0 never executed
        -:  474:                metrics->session_query_count);
    #####:  475:        return 0;  // No N+1 possible with 0 queries
        -:  476:    }
        -:  477:    
        -:  478:    // SEVERE N+1: More than 20 queries is almost certainly N+1
       15:  479:    if (query_count > 20) return 1;
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
        -:  480:    
        -:  481:    // SEVERE N+1: More than 10 queries with reasonable response time
       11:  482:    if (query_count > 10 && response_time > 10) return 1;
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
        -:  483:    
        -:  484:    return 0;
        -:  485:}
------------------
detect_n_plus_one_severe:
function detect_n_plus_one_severe called 10 returned 100% blocks executed 64%
       10:  464:int detect_n_plus_one_severe(EnhancedPerformanceMetrics_t* metrics) {
       10:  465:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  466:    
       10:  467:    uint32_t query_count = get_query_count(metrics);
call    0 returned 100%
       10:  468:    double response_time = get_elapsed_time_ms(metrics);
call    0 returned 100%
        -:  469:    
        -:  470:    // Debug logging for false positives
       10:  471:    if (query_count == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  472:        fprintf(stderr, "DEBUG: detect_n_plus_one_severe called with 0 queries\n");
call    0 never executed
    #####:  473:        fprintf(stderr, "  session_query_count=%u\n", 
call    0 never executed
        -:  474:                metrics->session_query_count);
    #####:  475:        return 0;  // No N+1 possible with 0 queries
        -:  476:    }
        -:  477:    
        -:  478:    // SEVERE N+1: More than 20 queries is almost certainly N+1
       10:  479:    if (query_count > 20) return 1;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  480:    
        -:  481:    // SEVERE N+1: More than 10 queries with reasonable response time
       5*:  482:    if (query_count > 10 && response_time > 10) return 1;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  483:    
        -:  484:    return 0;
        -:  485:}
------------------
        -:  486:
        -:  487:/**
        -:  488: * @brief Detect moderate N+1 query patterns
        -:  489: * 
        -:  490: * Identifies potential N+1 issues based on query count vs response time scaling.
        -:  491: * 
        -:  492: * @param metrics Pointer to performance metrics structure
        -:  493: * @return 1 if moderate N+1 detected, 0 otherwise
        -:  494: */
       19:  495:int detect_n_plus_one_moderate(EnhancedPerformanceMetrics_t* metrics) {
       19:  496:    if (!metrics) return 0;
        -:  497:    
       18:  498:    uint32_t query_count = get_query_count(metrics);
       18:  499:    double response_time = get_elapsed_time_ms(metrics);
        -:  500:    
        -:  501:    // MODERATE N+1: 5-20 queries for a simple operation
       18:  502:    if (query_count >= 5 && query_count <= 20) {
        -:  503:        // If response time scales with query count, likely N+1
       15:  504:        double time_per_query = response_time / query_count;
      15*:  505:        if (time_per_query > 0.5) return 1;  // More than 0.5ms per query suggests individual queries
        -:  506:    }
        -:  507:    
        -:  508:    return 0;
        -:  509:}
------------------
detect_n_plus_one_moderate:
function detect_n_plus_one_moderate called 5 returned 100% blocks executed 86%
        5:  495:int detect_n_plus_one_moderate(EnhancedPerformanceMetrics_t* metrics) {
        5:  496:    if (!metrics) return 0;
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -:  497:    
        4:  498:    uint32_t query_count = get_query_count(metrics);
call    0 returned 100%
        4:  499:    double response_time = get_elapsed_time_ms(metrics);
call    0 returned 100%
        -:  500:    
        -:  501:    // MODERATE N+1: 5-20 queries for a simple operation
        4:  502:    if (query_count >= 5 && query_count <= 20) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  503:        // If response time scales with query count, likely N+1
        2:  504:        double time_per_query = response_time / query_count;
       2*:  505:        if (time_per_query > 0.5) return 1;  // More than 0.5ms per query suggests individual queries
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  506:    }
        -:  507:    
        -:  508:    return 0;
        -:  509:}
------------------
detect_n_plus_one_moderate:
function detect_n_plus_one_moderate called 9 returned 100% blocks executed 100%
        9:  495:int detect_n_plus_one_moderate(EnhancedPerformanceMetrics_t* metrics) {
        9:  496:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  497:    
        9:  498:    uint32_t query_count = get_query_count(metrics);
call    0 returned 100%
        9:  499:    double response_time = get_elapsed_time_ms(metrics);
call    0 returned 100%
        -:  500:    
        -:  501:    // MODERATE N+1: 5-20 queries for a simple operation
        9:  502:    if (query_count >= 5 && query_count <= 20) {
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
        -:  503:        // If response time scales with query count, likely N+1
        8:  504:        double time_per_query = response_time / query_count;
        8:  505:        if (time_per_query > 0.5) return 1;  // More than 0.5ms per query suggests individual queries
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  506:    }
        -:  507:    
        -:  508:    return 0;
        -:  509:}
------------------
detect_n_plus_one_moderate:
function detect_n_plus_one_moderate called 5 returned 100% blocks executed 86%
        5:  495:int detect_n_plus_one_moderate(EnhancedPerformanceMetrics_t* metrics) {
        5:  496:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  497:    
        5:  498:    uint32_t query_count = get_query_count(metrics);
call    0 returned 100%
        5:  499:    double response_time = get_elapsed_time_ms(metrics);
call    0 returned 100%
        -:  500:    
        -:  501:    // MODERATE N+1: 5-20 queries for a simple operation
        5:  502:    if (query_count >= 5 && query_count <= 20) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  503:        // If response time scales with query count, likely N+1
        5:  504:        double time_per_query = response_time / query_count;
       5*:  505:        if (time_per_query > 0.5) return 1;  // More than 0.5ms per query suggests individual queries
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  506:    }
        -:  507:    
        -:  508:    return 0;
        -:  509:}
------------------
        -:  510:
        -:  511:/**
        -:  512: * @brief Detect N+1 patterns based on realistic query count thresholds
        -:  513: * 
        -:  514: * Uses realistic thresholds for Django apps with user profiles and permissions.
        -:  515: * 12+ queries are required before flagging as N+1 to avoid false positives.
        -:  516: * 
        -:  517: * @param metrics Pointer to performance metrics structure
        -:  518: * @return 1 if N+1 pattern detected by count, 0 otherwise
        -:  519: */
       11:  520:int detect_n_plus_one_pattern_by_count(EnhancedPerformanceMetrics_t* metrics) {
       11:  521:    if (!metrics) return 0;
        -:  522:    
       11:  523:    uint32_t query_count = get_query_count(metrics);
        -:  524:    
        -:  525:    // Debug logging for false positives
       11:  526:    if (query_count == 0) {
    #####:  527:        fprintf(stderr, "DEBUG: detect_n_plus_one_pattern_by_count called with 0 queries\n");
    #####:  528:        return 0;  // No N+1 possible with 0 queries
        -:  529:    }
        -:  530:    
        -:  531:    // Pattern detection for list views with individual queries
       11:  532:    if (query_count >= 21 && query_count <= 101) {
        -:  533:        // Likely pattern: 1 query for list + N queries for related data
        -:  534:        // Common in paginated views: 1 + 10, 1 + 20, 1 + 50, etc.
    #####:  535:        if ((query_count - 1) % 10 == 0 || 
    #####:  536:            (query_count - 1) % 20 == 0 ||
    #####:  537:            (query_count - 1) % 25 == 0) {
        -:  538:            return 1;
        -:  539:        }
        -:  540:    }
        -:  541:    
        -:  542:    // Realistic N+1 detection: Django user apps with profiles/permissions typically need 4-8 queries
        -:  543:    // Only flag as N+1 if significantly above normal Django patterns
      11*:  544:    if (query_count >= 12) return 1;  // Raised from 3 to 12 for realistic Django apps
        -:  545:    
        -:  546:    return 0;
        -:  547:}
------------------
detect_n_plus_one_pattern_by_count:
function detect_n_plus_one_pattern_by_count called 1 returned 100% blocks executed 50%
        1:  520:int detect_n_plus_one_pattern_by_count(EnhancedPerformanceMetrics_t* metrics) {
        1:  521:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  522:    
        1:  523:    uint32_t query_count = get_query_count(metrics);
call    0 returned 100%
        -:  524:    
        -:  525:    // Debug logging for false positives
        1:  526:    if (query_count == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  527:        fprintf(stderr, "DEBUG: detect_n_plus_one_pattern_by_count called with 0 queries\n");
call    0 never executed
    #####:  528:        return 0;  // No N+1 possible with 0 queries
        -:  529:    }
        -:  530:    
        -:  531:    // Pattern detection for list views with individual queries
        1:  532:    if (query_count >= 21 && query_count <= 101) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  533:        // Likely pattern: 1 query for list + N queries for related data
        -:  534:        // Common in paginated views: 1 + 10, 1 + 20, 1 + 50, etc.
    #####:  535:        if ((query_count - 1) % 10 == 0 || 
branch  0 never executed
branch  1 never executed
    #####:  536:            (query_count - 1) % 20 == 0 ||
branch  0 never executed
branch  1 never executed
    #####:  537:            (query_count - 1) % 25 == 0) {
branch  0 never executed
branch  1 never executed
        -:  538:            return 1;
        -:  539:        }
        -:  540:    }
        -:  541:    
        -:  542:    // Realistic N+1 detection: Django user apps with profiles/permissions typically need 4-8 queries
        -:  543:    // Only flag as N+1 if significantly above normal Django patterns
       1*:  544:    if (query_count >= 12) return 1;  // Raised from 3 to 12 for realistic Django apps
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  545:    
        -:  546:    return 0;
        -:  547:}
------------------
detect_n_plus_one_pattern_by_count:
function detect_n_plus_one_pattern_by_count called 5 returned 100% blocks executed 58%
        5:  520:int detect_n_plus_one_pattern_by_count(EnhancedPerformanceMetrics_t* metrics) {
        5:  521:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  522:    
        5:  523:    uint32_t query_count = get_query_count(metrics);
call    0 returned 100%
        -:  524:    
        -:  525:    // Debug logging for false positives
        5:  526:    if (query_count == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  527:        fprintf(stderr, "DEBUG: detect_n_plus_one_pattern_by_count called with 0 queries\n");
call    0 never executed
    #####:  528:        return 0;  // No N+1 possible with 0 queries
        -:  529:    }
        -:  530:    
        -:  531:    // Pattern detection for list views with individual queries
        5:  532:    if (query_count >= 21 && query_count <= 101) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  533:        // Likely pattern: 1 query for list + N queries for related data
        -:  534:        // Common in paginated views: 1 + 10, 1 + 20, 1 + 50, etc.
    #####:  535:        if ((query_count - 1) % 10 == 0 || 
branch  0 never executed
branch  1 never executed
    #####:  536:            (query_count - 1) % 20 == 0 ||
branch  0 never executed
branch  1 never executed
    #####:  537:            (query_count - 1) % 25 == 0) {
branch  0 never executed
branch  1 never executed
        -:  538:            return 1;
        -:  539:        }
        -:  540:    }
        -:  541:    
        -:  542:    // Realistic N+1 detection: Django user apps with profiles/permissions typically need 4-8 queries
        -:  543:    // Only flag as N+1 if significantly above normal Django patterns
        5:  544:    if (query_count >= 12) return 1;  // Raised from 3 to 12 for realistic Django apps
branch  0 taken 40% (fallthrough)
branch  1 taken 60%
        -:  545:    
        -:  546:    return 0;
        -:  547:}
------------------
detect_n_plus_one_pattern_by_count:
function detect_n_plus_one_pattern_by_count called 5 returned 100% blocks executed 58%
        5:  520:int detect_n_plus_one_pattern_by_count(EnhancedPerformanceMetrics_t* metrics) {
        5:  521:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  522:    
        5:  523:    uint32_t query_count = get_query_count(metrics);
call    0 returned 100%
        -:  524:    
        -:  525:    // Debug logging for false positives
        5:  526:    if (query_count == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  527:        fprintf(stderr, "DEBUG: detect_n_plus_one_pattern_by_count called with 0 queries\n");
call    0 never executed
    #####:  528:        return 0;  // No N+1 possible with 0 queries
        -:  529:    }
        -:  530:    
        -:  531:    // Pattern detection for list views with individual queries
        5:  532:    if (query_count >= 21 && query_count <= 101) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  533:        // Likely pattern: 1 query for list + N queries for related data
        -:  534:        // Common in paginated views: 1 + 10, 1 + 20, 1 + 50, etc.
    #####:  535:        if ((query_count - 1) % 10 == 0 || 
branch  0 never executed
branch  1 never executed
    #####:  536:            (query_count - 1) % 20 == 0 ||
branch  0 never executed
branch  1 never executed
    #####:  537:            (query_count - 1) % 25 == 0) {
branch  0 never executed
branch  1 never executed
        -:  538:            return 1;
        -:  539:        }
        -:  540:    }
        -:  541:    
        -:  542:    // Realistic N+1 detection: Django user apps with profiles/permissions typically need 4-8 queries
        -:  543:    // Only flag as N+1 if significantly above normal Django patterns
        5:  544:    if (query_count >= 12) return 1;  // Raised from 3 to 12 for realistic Django apps
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -:  545:    
        -:  546:    return 0;
        -:  547:}
------------------
        -:  548:
        -:  549:/**
        -:  550: * @brief Calculate N+1 severity level with realistic thresholds
        -:  551: * 
        -:  552: * Returns severity level from 0-5 based on query count, adjusted for
        -:  553: * Django applications with complex user models and relationships.
        -:  554: * 
        -:  555: * @param metrics Pointer to performance metrics structure
        -:  556: * @return Severity level (0=none, 1=mild, 2=moderate, 3=high, 4=severe, 5=critical)
        -:  557: */
      24*:  558:int calculate_n_plus_one_severity(EnhancedPerformanceMetrics_t* metrics) {
      24*:  559:    if (!metrics) return 0;
        -:  560:    
      24*:  561:    uint32_t query_count = get_query_count(metrics);
        -:  562:    
        -:  563:    // No N+1 issues for 0 queries (static/cached responses)
      24*:  564:    if (query_count == 0) return 0;
        -:  565:    
        -:  566:    // Adjusted thresholds to align with realistic Django app needs
      22*:  567:    if (query_count >= 50) return 5;  // CRITICAL - extreme N+1 
      18*:  568:    if (query_count >= 35) return 4;  // SEVERE - very high query count
      16*:  569:    if (query_count >= 25) return 3;  // HIGH - high query count 
      14*:  570:    if (query_count >= 18) return 2;  // MODERATE - moderate N+1 issue
      10*:  571:    if (query_count >= 12) return 1;  // MILD - potential N+1, investigate
        -:  572:    
        -:  573:    return 0;  // NONE - acceptable for Django apps with profiles/permissions
        -:  574:}
------------------
calculate_n_plus_one_severity:
function calculate_n_plus_one_severity called 0 returned 0% blocks executed 0%
    #####:  558:int calculate_n_plus_one_severity(EnhancedPerformanceMetrics_t* metrics) {
    #####:  559:    if (!metrics) return 0;
branch  0 never executed
branch  1 never executed
        -:  560:    
    #####:  561:    uint32_t query_count = get_query_count(metrics);
call    0 never executed
        -:  562:    
        -:  563:    // No N+1 issues for 0 queries (static/cached responses)
    #####:  564:    if (query_count == 0) return 0;
branch  0 never executed
branch  1 never executed
        -:  565:    
        -:  566:    // Adjusted thresholds to align with realistic Django app needs
    #####:  567:    if (query_count >= 50) return 5;  // CRITICAL - extreme N+1 
branch  0 never executed
branch  1 never executed
    #####:  568:    if (query_count >= 35) return 4;  // SEVERE - very high query count
branch  0 never executed
branch  1 never executed
    #####:  569:    if (query_count >= 25) return 3;  // HIGH - high query count 
branch  0 never executed
branch  1 never executed
    #####:  570:    if (query_count >= 18) return 2;  // MODERATE - moderate N+1 issue
branch  0 never executed
branch  1 never executed
    #####:  571:    if (query_count >= 12) return 1;  // MILD - potential N+1, investigate
branch  0 never executed
branch  1 never executed
        -:  572:    
        -:  573:    return 0;  // NONE - acceptable for Django apps with profiles/permissions
        -:  574:}
------------------
calculate_n_plus_one_severity:
function calculate_n_plus_one_severity called 13 returned 100% blocks executed 100%
       13:  558:int calculate_n_plus_one_severity(EnhancedPerformanceMetrics_t* metrics) {
       13:  559:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  560:    
       13:  561:    uint32_t query_count = get_query_count(metrics);
call    0 returned 100%
        -:  562:    
        -:  563:    // No N+1 issues for 0 queries (static/cached responses)
       13:  564:    if (query_count == 0) return 0;
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
        -:  565:    
        -:  566:    // Adjusted thresholds to align with realistic Django app needs
       12:  567:    if (query_count >= 50) return 5;  // CRITICAL - extreme N+1 
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
       11:  568:    if (query_count >= 35) return 4;  // SEVERE - very high query count
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
       10:  569:    if (query_count >= 25) return 3;  // HIGH - high query count 
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        8:  570:    if (query_count >= 18) return 2;  // MODERATE - moderate N+1 issue
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        7:  571:    if (query_count >= 12) return 1;  // MILD - potential N+1, investigate
branch  0 taken 43% (fallthrough)
branch  1 taken 57%
        -:  572:    
        -:  573:    return 0;  // NONE - acceptable for Django apps with profiles/permissions
        -:  574:}
------------------
calculate_n_plus_one_severity:
function calculate_n_plus_one_severity called 11 returned 100% blocks executed 100%
       11:  558:int calculate_n_plus_one_severity(EnhancedPerformanceMetrics_t* metrics) {
       11:  559:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  560:    
       11:  561:    uint32_t query_count = get_query_count(metrics);
call    0 returned 100%
        -:  562:    
        -:  563:    // No N+1 issues for 0 queries (static/cached responses)
       11:  564:    if (query_count == 0) return 0;
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
        -:  565:    
        -:  566:    // Adjusted thresholds to align with realistic Django app needs
       10:  567:    if (query_count >= 50) return 5;  // CRITICAL - extreme N+1 
branch  0 taken 70% (fallthrough)
branch  1 taken 30%
        7:  568:    if (query_count >= 35) return 4;  // SEVERE - very high query count
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
        6:  569:    if (query_count >= 25) return 3;  // HIGH - high query count 
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6:  570:    if (query_count >= 18) return 2;  // MODERATE - moderate N+1 issue
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        3:  571:    if (query_count >= 12) return 1;  // MILD - potential N+1, investigate
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -:  572:    
        -:  573:    return 0;  // NONE - acceptable for Django apps with profiles/permissions
        -:  574:}
------------------
        -:  575:
        -:  576:/**
        -:  577: * @brief Estimate the likely cause of N+1 queries
        -:  578: * 
        -:  579: * Analyzes query patterns to determine the most probable cause of N+1 issues.
        -:  580: * 
        -:  581: * @param metrics Pointer to performance metrics structure
        -:  582: * @return Cause code (0=none, 1=serializer, 2=related_model, 3=foreign_key, 4=complex)
        -:  583: */
      11*:  584:int estimate_n_plus_one_cause(EnhancedPerformanceMetrics_t* metrics) {
      11*:  585:    if (!metrics) return 0;
        -:  586:    
      11*:  587:    uint32_t query_count = get_query_count(metrics);
      11*:  588:    double response_time = get_elapsed_time_ms(metrics);
        -:  589:    
        -:  590:    // Cause classification:
        -:  591:    // 0 = No N+1
        -:  592:    // 1 = Serializer N+1 (many quick queries)
        -:  593:    // 2 = Related model N+1 (moderate queries)
        -:  594:    // 3 = Foreign key N+1 (many queries, slow)
        -:  595:    // 4 = Complex relationship N+1 (very many queries)
        -:  596:    
        -:  597:    // No N+1 issues for 0 queries (static/cached responses) or low query counts
      11*:  598:    if (query_count == 0 || query_count < 12) return 0;
        -:  599:    
      11*:  600:    double avg_query_time = response_time / query_count;
        -:  601:    
      11*:  602:    if (query_count >= 50) return 4;  // Complex relationship N+1
       9*:  603:    if (query_count >= 30 && avg_query_time > 2.0) return 3;  // Foreign key N+1
       9*:  604:    if (query_count >= 20 && avg_query_time < 2.0) return 1;  // Serializer N+1
       2*:  605:    if (query_count >= 12) return 2;   // Related model N+1
        -:  606:    
        -:  607:    return 0;
        -:  608:}
------------------
estimate_n_plus_one_cause:
function estimate_n_plus_one_cause called 0 returned 0% blocks executed 0%
    #####:  584:int estimate_n_plus_one_cause(EnhancedPerformanceMetrics_t* metrics) {
    #####:  585:    if (!metrics) return 0;
branch  0 never executed
branch  1 never executed
        -:  586:    
    #####:  587:    uint32_t query_count = get_query_count(metrics);
call    0 never executed
    #####:  588:    double response_time = get_elapsed_time_ms(metrics);
call    0 never executed
        -:  589:    
        -:  590:    // Cause classification:
        -:  591:    // 0 = No N+1
        -:  592:    // 1 = Serializer N+1 (many quick queries)
        -:  593:    // 2 = Related model N+1 (moderate queries)
        -:  594:    // 3 = Foreign key N+1 (many queries, slow)
        -:  595:    // 4 = Complex relationship N+1 (very many queries)
        -:  596:    
        -:  597:    // No N+1 issues for 0 queries (static/cached responses) or low query counts
    #####:  598:    if (query_count == 0 || query_count < 12) return 0;
branch  0 never executed
branch  1 never executed
        -:  599:    
    #####:  600:    double avg_query_time = response_time / query_count;
        -:  601:    
    #####:  602:    if (query_count >= 50) return 4;  // Complex relationship N+1
branch  0 never executed
branch  1 never executed
    #####:  603:    if (query_count >= 30 && avg_query_time > 2.0) return 3;  // Foreign key N+1
branch  0 never executed
branch  1 never executed
    #####:  604:    if (query_count >= 20 && avg_query_time < 2.0) return 1;  // Serializer N+1
branch  0 never executed
branch  1 never executed
    #####:  605:    if (query_count >= 12) return 2;   // Related model N+1
        -:  606:    
        -:  607:    return 0;
        -:  608:}
------------------
estimate_n_plus_one_cause:
function estimate_n_plus_one_cause called 11 returned 100% blocks executed 100%
       11:  584:int estimate_n_plus_one_cause(EnhancedPerformanceMetrics_t* metrics) {
       11:  585:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  586:    
       11:  587:    uint32_t query_count = get_query_count(metrics);
call    0 returned 100%
       11:  588:    double response_time = get_elapsed_time_ms(metrics);
call    0 returned 100%
        -:  589:    
        -:  590:    // Cause classification:
        -:  591:    // 0 = No N+1
        -:  592:    // 1 = Serializer N+1 (many quick queries)
        -:  593:    // 2 = Related model N+1 (moderate queries)
        -:  594:    // 3 = Foreign key N+1 (many queries, slow)
        -:  595:    // 4 = Complex relationship N+1 (very many queries)
        -:  596:    
        -:  597:    // No N+1 issues for 0 queries (static/cached responses) or low query counts
       11:  598:    if (query_count == 0 || query_count < 12) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  599:    
       11:  600:    double avg_query_time = response_time / query_count;
        -:  601:    
       11:  602:    if (query_count >= 50) return 4;  // Complex relationship N+1
branch  0 taken 82% (fallthrough)
branch  1 taken 18%
        9:  603:    if (query_count >= 30 && avg_query_time > 2.0) return 3;  // Foreign key N+1
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        9:  604:    if (query_count >= 20 && avg_query_time < 2.0) return 1;  // Serializer N+1
branch  0 taken 22% (fallthrough)
branch  1 taken 78%
        2:  605:    if (query_count >= 12) return 2;   // Related model N+1
        -:  606:    
        -:  607:    return 0;
        -:  608:}
------------------
estimate_n_plus_one_cause:
function estimate_n_plus_one_cause called 0 returned 0% blocks executed 0%
    #####:  584:int estimate_n_plus_one_cause(EnhancedPerformanceMetrics_t* metrics) {
    #####:  585:    if (!metrics) return 0;
branch  0 never executed
branch  1 never executed
        -:  586:    
    #####:  587:    uint32_t query_count = get_query_count(metrics);
call    0 never executed
    #####:  588:    double response_time = get_elapsed_time_ms(metrics);
call    0 never executed
        -:  589:    
        -:  590:    // Cause classification:
        -:  591:    // 0 = No N+1
        -:  592:    // 1 = Serializer N+1 (many quick queries)
        -:  593:    // 2 = Related model N+1 (moderate queries)
        -:  594:    // 3 = Foreign key N+1 (many queries, slow)
        -:  595:    // 4 = Complex relationship N+1 (very many queries)
        -:  596:    
        -:  597:    // No N+1 issues for 0 queries (static/cached responses) or low query counts
    #####:  598:    if (query_count == 0 || query_count < 12) return 0;
branch  0 never executed
branch  1 never executed
        -:  599:    
    #####:  600:    double avg_query_time = response_time / query_count;
        -:  601:    
    #####:  602:    if (query_count >= 50) return 4;  // Complex relationship N+1
branch  0 never executed
branch  1 never executed
    #####:  603:    if (query_count >= 30 && avg_query_time > 2.0) return 3;  // Foreign key N+1
branch  0 never executed
branch  1 never executed
    #####:  604:    if (query_count >= 20 && avg_query_time < 2.0) return 1;  // Serializer N+1
branch  0 never executed
branch  1 never executed
    #####:  605:    if (query_count >= 12) return 2;   // Related model N+1
        -:  606:    
        -:  607:    return 0;
        -:  608:}
------------------
        -:  609:
        -:  610:/**
        -:  611: * @brief Get suggested fix for detected N+1 pattern
        -:  612: * 
        -:  613: * Returns human-readable suggestion based on estimated cause of N+1 queries.
        -:  614: * 
        -:  615: * @param metrics Pointer to performance metrics structure
        -:  616: * @return String with optimization suggestion
        -:  617: */
       5*:  618:const char* get_n_plus_one_fix_suggestion(EnhancedPerformanceMetrics_t* metrics) {
       5*:  619:    if (!metrics) return "No metrics available";
        -:  620:    
       5*:  621:    int cause = estimate_n_plus_one_cause(metrics);
        -:  622:    
       5*:  623:    switch (cause) {
        -:  624:        case 0:
        -:  625:            return "No N+1 detected";
       3*:  626:        case 1:
       3*:  627:            return "Serializer N+1: Check SerializerMethodField usage, use prefetch_related()";
       1*:  628:        case 2:
       1*:  629:            return "Related model N+1: Add select_related() for ForeignKey fields";
    #####:  630:        case 3:
    #####:  631:            return "Foreign key N+1: Use select_related() and check for nested relationship access";
       1*:  632:        case 4:
       1*:  633:            return "Complex N+1: Review QuerySet optimization, consider using raw SQL or database views";
    #####:  634:        default:
    #####:  635:            return "Add select_related() and prefetch_related() to your QuerySet";
        -:  636:    }
        -:  637:}
------------------
get_n_plus_one_fix_suggestion:
function get_n_plus_one_fix_suggestion called 0 returned 0% blocks executed 0%
    #####:  618:const char* get_n_plus_one_fix_suggestion(EnhancedPerformanceMetrics_t* metrics) {
    #####:  619:    if (!metrics) return "No metrics available";
branch  0 never executed
branch  1 never executed
        -:  620:    
    #####:  621:    int cause = estimate_n_plus_one_cause(metrics);
call    0 never executed
        -:  622:    
    #####:  623:    switch (cause) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  624:        case 0:
        -:  625:            return "No N+1 detected";
    #####:  626:        case 1:
    #####:  627:            return "Serializer N+1: Check SerializerMethodField usage, use prefetch_related()";
    #####:  628:        case 2:
    #####:  629:            return "Related model N+1: Add select_related() for ForeignKey fields";
    #####:  630:        case 3:
    #####:  631:            return "Foreign key N+1: Use select_related() and check for nested relationship access";
    #####:  632:        case 4:
    #####:  633:            return "Complex N+1: Review QuerySet optimization, consider using raw SQL or database views";
    #####:  634:        default:
    #####:  635:            return "Add select_related() and prefetch_related() to your QuerySet";
        -:  636:    }
        -:  637:}
------------------
get_n_plus_one_fix_suggestion:
function get_n_plus_one_fix_suggestion called 5 returned 100% blocks executed 78%
        5:  618:const char* get_n_plus_one_fix_suggestion(EnhancedPerformanceMetrics_t* metrics) {
        5:  619:    if (!metrics) return "No metrics available";
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  620:    
        5:  621:    int cause = estimate_n_plus_one_cause(metrics);
call    0 returned 100%
        -:  622:    
        5:  623:    switch (cause) {
branch  0 taken 60%
branch  1 taken 20%
branch  2 taken 0%
branch  3 taken 20%
branch  4 taken 0%
branch  5 taken 0%
        -:  624:        case 0:
        -:  625:            return "No N+1 detected";
        3:  626:        case 1:
        3:  627:            return "Serializer N+1: Check SerializerMethodField usage, use prefetch_related()";
        1:  628:        case 2:
        1:  629:            return "Related model N+1: Add select_related() for ForeignKey fields";
    #####:  630:        case 3:
    #####:  631:            return "Foreign key N+1: Use select_related() and check for nested relationship access";
        1:  632:        case 4:
        1:  633:            return "Complex N+1: Review QuerySet optimization, consider using raw SQL or database views";
    #####:  634:        default:
    #####:  635:            return "Add select_related() and prefetch_related() to your QuerySet";
        -:  636:    }
        -:  637:}
------------------
get_n_plus_one_fix_suggestion:
function get_n_plus_one_fix_suggestion called 0 returned 0% blocks executed 0%
    #####:  618:const char* get_n_plus_one_fix_suggestion(EnhancedPerformanceMetrics_t* metrics) {
    #####:  619:    if (!metrics) return "No metrics available";
branch  0 never executed
branch  1 never executed
        -:  620:    
    #####:  621:    int cause = estimate_n_plus_one_cause(metrics);
call    0 never executed
        -:  622:    
    #####:  623:    switch (cause) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  624:        case 0:
        -:  625:            return "No N+1 detected";
    #####:  626:        case 1:
    #####:  627:            return "Serializer N+1: Check SerializerMethodField usage, use prefetch_related()";
    #####:  628:        case 2:
    #####:  629:            return "Related model N+1: Add select_related() for ForeignKey fields";
    #####:  630:        case 3:
    #####:  631:            return "Foreign key N+1: Use select_related() and check for nested relationship access";
    #####:  632:        case 4:
    #####:  633:            return "Complex N+1: Review QuerySet optimization, consider using raw SQL or database views";
    #####:  634:        default:
    #####:  635:            return "Add select_related() and prefetch_related() to your QuerySet";
        -:  636:    }
        -:  637:}
------------------
        -:  638:
        -:  639:/**
        -:  640: * @brief Check if operation is memory intensive
        -:  641: * 
        -:  642: * Determines if memory usage exceeds reasonable thresholds for Django operations.
        -:  643: * 
        -:  644: * @param metrics Pointer to performance metrics structure
        -:  645: * @return 1 if memory intensive, 0 otherwise
        -:  646: */
       2*:  647:int is_memory_intensive(EnhancedPerformanceMetrics_t* metrics) {
       2*:  648:    if (!metrics) return 0;
        -:  649:    
       2*:  650:    double memory_delta = get_memory_delta_mb(metrics);
       2*:  651:    double peak_memory = get_memory_usage_mb(metrics);
        -:  652:    
        -:  653:    // Memory intensive if delta > 50MB or peak > 200MB
       2*:  654:    return (memory_delta > 50.0 || peak_memory > 200.0);
        -:  655:}
------------------
is_memory_intensive:
function is_memory_intensive called 0 returned 0% blocks executed 0%
    #####:  647:int is_memory_intensive(EnhancedPerformanceMetrics_t* metrics) {
    #####:  648:    if (!metrics) return 0;
branch  0 never executed
branch  1 never executed
        -:  649:    
    #####:  650:    double memory_delta = get_memory_delta_mb(metrics);
call    0 never executed
    #####:  651:    double peak_memory = get_memory_usage_mb(metrics);
call    0 never executed
        -:  652:    
        -:  653:    // Memory intensive if delta > 50MB or peak > 200MB
    #####:  654:    return (memory_delta > 50.0 || peak_memory > 200.0);
        -:  655:}
------------------
is_memory_intensive:
function is_memory_intensive called 2 returned 100% blocks executed 100%
        2:  647:int is_memory_intensive(EnhancedPerformanceMetrics_t* metrics) {
        2:  648:    if (!metrics) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  649:    
        2:  650:    double memory_delta = get_memory_delta_mb(metrics);
call    0 returned 100%
        2:  651:    double peak_memory = get_memory_usage_mb(metrics);
call    0 returned 100%
        -:  652:    
        -:  653:    // Memory intensive if delta > 50MB or peak > 200MB
        2:  654:    return (memory_delta > 50.0 || peak_memory > 200.0);
        -:  655:}
------------------
is_memory_intensive:
function is_memory_intensive called 0 returned 0% blocks executed 0%
    #####:  647:int is_memory_intensive(EnhancedPerformanceMetrics_t* metrics) {
    #####:  648:    if (!metrics) return 0;
branch  0 never executed
branch  1 never executed
        -:  649:    
    #####:  650:    double memory_delta = get_memory_delta_mb(metrics);
call    0 never executed
    #####:  651:    double peak_memory = get_memory_usage_mb(metrics);
call    0 never executed
        -:  652:    
        -:  653:    // Memory intensive if delta > 50MB or peak > 200MB
    #####:  654:    return (memory_delta > 50.0 || peak_memory > 200.0);
        -:  655:}
------------------
        -:  656:
        -:  657:/**
        -:  658: * @brief Check if operation has poor cache performance
        -:  659: * 
        -:  660: * Determines if cache hit ratio is below acceptable thresholds.
        -:  661: * 
        -:  662: * @param metrics Pointer to performance metrics structure
        -:  663: * @return 1 if poor cache performance, 0 otherwise
        -:  664: */
       3*:  665:int has_poor_cache_performance(EnhancedPerformanceMetrics_t* metrics) {
       3*:  666:    if (!metrics) return 0;
        -:  667:    
       3*:  668:    double hit_ratio = get_cache_hit_ratio(metrics);
       3*:  669:    uint32_t total_ops = metrics->session_cache_hits + metrics->session_cache_misses;
        -:  670:    
        -:  671:    // Poor cache performance if hit ratio < 70% and significant cache usage
       3*:  672:    return (hit_ratio >= 0 && hit_ratio < 0.7 && total_ops > 5);
        -:  673:}

        -:    0:Source:query_analyzer.c
        -:    0:Source is newer than graph
        -:    1:/**
        -:    2: * @file query_analyzer.c
        -:    3: * @brief High-Performance SQL Query Analysis Engine
        -:    4: * 
        -:    5: * This library implements a high-performance SQL query analysis engine for the
        -:    6: * Mercury Performance Testing Framework. It replaces the Python-based query
        -:    7: * analysis in django_hooks.py with optimized C implementations.
        -:    8: *
        -:    9: * Key Features:
        -:   10: * - Boyer-Moore pattern matching for N+1 query detection
        -:   11: * - Hash-based query similarity analysis using FNV-1a
        -:   12: * - Lightweight SQL tokenization with finite state machine
        -:   13: * - Memory-efficient ring buffer for query history
        -:   14: * - Real-time N+1 severity calculation and optimization suggestions
        -:   15: *
        -:   16: * Performance Target: 75% reduction in SQL analysis overhead
        -:   17: * Memory Usage: Fixed 1MB allocation for query history buffer
        -:   18: */
        -:   19:
        -:   20:/* Suppress deprecation warnings on Windows */
        -:   21:#ifdef _MSC_VER
        -:   22:    #define _CRT_SECURE_NO_WARNINGS
        -:   23:#endif
        -:   24:
        -:   25:#include "common.h"
        -:   26:#include <stdlib.h>  /* For malloc, free, realloc */
        -:   27:#include <string.h>  /* For strcpy, strncpy, strlen, memcpy, memmove */
        -:   28:#include <math.h>
        -:   29:#include <ctype.h>
        -:   30:
        -:   31:/* Platform-specific string function includes */
        -:   32:#ifdef _WIN32
        -:   33:    #include <windows.h>  /* For Windows types */
        -:   34:    #define strncasecmp _strnicmp  /* Windows equivalent */
        -:   35:#else
        -:   36:    #include <strings.h>  /* For strncasecmp on macOS/POSIX systems */
        -:   37:#endif
        -:   38:
        -:   39:/* Ensure SIZE_MAX is defined */
        -:   40:#ifndef SIZE_MAX
        -:   41:    #define SIZE_MAX ((size_t)-1)
        -:   42:#endif
        -:   43:
        -:   44:// === CONSTANTS ===
        -:   45:
        -:   46:#define MAX_QUERY_HISTORY 1000
        -:   47:#define MAX_PATTERN_CACHE 50
        -:   48:#define SIMILARITY_THRESHOLD 0.8
        -:   49:#define N_PLUS_ONE_THRESHOLD 12  // Mercury's realistic threshold
        -:   50:
        -:   51:/**
        -:   52: * @enum SqlQueryType
        -:   53: * @brief SQL query type classification
        -:   54: */
        -:   55:typedef enum {
        -:   56:    SQL_UNKNOWN = 0,  /**< Unknown or unparsed query type */
        -:   57:    SQL_SELECT = 1,   /**< SELECT query */
        -:   58:    SQL_INSERT = 2,   /**< INSERT query */
        -:   59:    SQL_UPDATE = 3,   /**< UPDATE query */
        -:   60:    SQL_DELETE = 4,   /**< DELETE query */
        -:   61:    SQL_CREATE = 5,   /**< CREATE TABLE/INDEX/VIEW */
        -:   62:    SQL_DROP = 6,     /**< DROP TABLE/INDEX/VIEW */
        -:   63:    SQL_ALTER = 7     /**< ALTER TABLE */
        -:   64:} SqlQueryType;
        -:   65:
        -:   66:/**
        -:   67: * @enum NPlusOneSeverity
        -:   68: * @brief N+1 query pattern severity levels
        -:   69: */
        -:   70:typedef enum {
        -:   71:    N_PLUS_ONE_NONE = 0,     /**< No N+1 pattern detected */
        -:   72:    N_PLUS_ONE_MILD = 1,     /**< 5-11 queries (acceptable) */
        -:   73:    N_PLUS_ONE_MODERATE = 2, /**< 12-24 queries (needs attention) */
        -:   74:    N_PLUS_ONE_HIGH = 3,     /**< 25-49 queries (problematic) */
        -:   75:    N_PLUS_ONE_SEVERE = 4,   /**< 50-99 queries (severe) */
        -:   76:    N_PLUS_ONE_CRITICAL = 5  /**< 100+ queries (critical) */
        -:   77:} NPlusOneSeverity;
        -:   78:
        -:   79:// === DATA STRUCTURES ===
        -:   80:
        -:   81:// Pre-compiled SQL patterns for fast detection
        -:   82:typedef struct {
        -:   83:    MercuryBoyerMoore* pattern_matcher;
        -:   84:    char pattern_text[256];
        -:   85:    SqlQueryType query_type;
        -:   86:    int priority;  // Higher priority patterns checked first
        -:   87:} SqlPattern;
        -:   88:
        -:   89:// Query similarity cluster for N+1 detection
        -:   90:typedef struct {
        -:   91:    uint64_t pattern_hash;
        -:   92:    int query_count;
        -:   93:    double total_time;
        -:   94:    double avg_time;
        -:   95:    char representative_query[512];
        -:   96:    MercuryTimestamp first_seen;
        -:   97:    MercuryTimestamp last_seen;
        -:   98:} QueryCluster;
        -:   99:
        -:  100:// Main query analyzer structure
        -:  101:typedef struct {
        -:  102:    MercuryRingBuffer* query_history;
        -:  103:    SqlPattern* patterns;
        -:  104:    size_t pattern_count;
        -:  105:    QueryCluster* clusters;
        -:  106:    size_t cluster_count;
        -:  107:    size_t max_clusters;
        -:  108:    
        -:  109:    // Memory pool for query text storage
        -:  110:    memory_pool_t query_text_pool;
        -:  111:    
        -:  112:    // Thread safety
        -:  113:    pthread_mutex_t cluster_mutex;  // Protects cluster array access
        -:  114:    pthread_mutex_t history_mutex;  // Protects ring buffer access
        -:  115:    
        -:  116:    // Statistics
        -:  117:    uint64_t total_queries_analyzed;
        -:  118:    uint64_t n_plus_one_patterns_detected;
        -:  119:    uint64_t similar_queries_found;
        -:  120:    
        -:  121:    // Current analysis state
        -:  122:    NPlusOneSeverity current_severity;
        -:  123:    int estimated_cause;
        -:  124:    char optimization_suggestion[512];
        -:  125:} QueryAnalyzer;
        -:  126:
        -:  127:// Global analyzer instance
        -:  128:static QueryAnalyzer* g_analyzer = NULL;
        -:  129:
        -:  130:// === SQL PATTERN DEFINITIONS ===
        -:  131:
        -:  132:static const char* sql_patterns[] = {
        -:  133:    // High-priority N+1 indicators
        -:  134:    "SELECT * FROM",
        -:  135:    "SELECT .* FROM .* WHERE .*id = ",
        -:  136:    "SELECT .* FROM .* WHERE .*_id = ",
        -:  137:    "SELECT .* FROM .* WHERE .*pk = ",
        -:  138:    
        -:  139:    // Django ORM patterns
        -:  140:    "SELECT .* FROM \".*_.*\" WHERE \".*\".\"id\" = ",
        -:  141:    "SELECT .* FROM \".*\" WHERE \".*\".\".*_id\" = ",
        -:  142:    
        -:  143:    // JOIN patterns (good - indicates optimized queries)
        -:  144:    "SELECT .* FROM .* JOIN .* ON",
        -:  145:    "SELECT .* FROM .* LEFT JOIN .* ON",
        -:  146:    "SELECT .* FROM .* INNER JOIN .* ON",
        -:  147:    
        -:  148:    // Foreign key access patterns
        -:  149:    "SELECT .* FROM \".*\" WHERE \".*\".\".*\" IN (",
        -:  150:    
        -:  151:    // Bulk operations (usually good)
        -:  152:    "SELECT .* FROM .* WHERE .*id.* IN (",
        -:  153:    "INSERT INTO .* VALUES",
        -:  154:    "UPDATE .* SET .* WHERE .*id.* IN (",
        -:  155:    "DELETE FROM .* WHERE .*id.* IN (",
        -:  156:    
        -:  157:    // Migration patterns
        -:  158:    "CREATE TABLE",
        -:  159:    "ALTER TABLE",
        -:  160:    "DROP TABLE",
        -:  161:    "CREATE INDEX",
        -:  162:    "DROP INDEX"
        -:  163:};
        -:  164:
        -:  165:static const SqlQueryType pattern_types[] = {
        -:  166:    SQL_SELECT, SQL_SELECT, SQL_SELECT, SQL_SELECT,
        -:  167:    SQL_SELECT, SQL_SELECT,
        -:  168:    SQL_SELECT, SQL_SELECT, SQL_SELECT,
        -:  169:    SQL_SELECT,
        -:  170:    SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE,
        -:  171:    SQL_CREATE, SQL_ALTER, SQL_DROP, SQL_CREATE, SQL_DROP
        -:  172:};
        -:  173:
        -:  174:// === UTILITY FUNCTIONS ===
        -:  175:
        -:  176:// Safe string allocation using memory pool
     3278:  177:static char* pool_strdup(const char* str) {
     3278:  178:    if (!str || !g_analyzer) return NULL;
        -:  179:    
     3278:  180:    size_t len = strlen(str);
     3278:  181:    if (len >= 4096) {
        -:  182:        // String too long for our pool blocks - truncate
        -:  183:        len = 4095;
       1*:  184:        MERCURY_WARN("Query string truncated to fit memory pool (original length: %zu)", strlen(str));
        -:  185:    }
        -:  186:    
     3278:  187:    char* pool_str = memory_pool_alloc(&g_analyzer->query_text_pool);
     3278:  188:    if (pool_str) {
        -:  189:        strncpy(pool_str, str, len);
     3278:  190:        pool_str[len] = '\0';
        -:  191:    } else {
    #####:  192:        MERCURY_ERROR("Failed to allocate query text from memory pool");
        -:  193:    }
        -:  194:    
        -:  195:    return pool_str;
        -:  196:}
------------------
pool_strdup:
function pool_strdup called 173 returned 100% blocks executed 64%
      173:  177:static char* pool_strdup(const char* str) {
      173:  178:    if (!str || !g_analyzer) return NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  179:    
      173:  180:    size_t len = strlen(str);
      173:  181:    if (len >= 4096) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  182:        // String too long for our pool blocks - truncate
        -:  183:        len = 4095;
    #####:  184:        MERCURY_WARN("Query string truncated to fit memory pool (original length: %zu)", strlen(str));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  185:    }
        -:  186:    
      173:  187:    char* pool_str = memory_pool_alloc(&g_analyzer->query_text_pool);
call    0 returned 100%
      173:  188:    if (pool_str) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  189:        strncpy(pool_str, str, len);
      173:  190:        pool_str[len] = '\0';
        -:  191:    } else {
    #####:  192:        MERCURY_ERROR("Failed to allocate query text from memory pool");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  193:    }
        -:  194:    
        -:  195:    return pool_str;
        -:  196:}
------------------
pool_strdup:
function pool_strdup called 3105 returned 100% blocks executed 82%
     3105:  177:static char* pool_strdup(const char* str) {
     3105:  178:    if (!str || !g_analyzer) return NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  179:    
     3105:  180:    size_t len = strlen(str);
     3105:  181:    if (len >= 4096) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:  182:        // String too long for our pool blocks - truncate
        -:  183:        len = 4095;
        1:  184:        MERCURY_WARN("Query string truncated to fit memory pool (original length: %zu)", strlen(str));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  185:    }
        -:  186:    
     3105:  187:    char* pool_str = memory_pool_alloc(&g_analyzer->query_text_pool);
call    0 returned 100%
     3105:  188:    if (pool_str) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  189:        strncpy(pool_str, str, len);
     3105:  190:        pool_str[len] = '\0';
        -:  191:    } else {
    #####:  192:        MERCURY_ERROR("Failed to allocate query text from memory pool");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  193:    }
        -:  194:    
        -:  195:    return pool_str;
        -:  196:}
------------------
        -:  197:
        -:  198:// Safe string deallocation using memory pool
        -:  199:static void pool_strfree(char* str) {
    3278*:  200:    if (str && g_analyzer) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 never executed
branch  3 never executed
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 100% (fallthrough)
branch  7 taken 0%
    3278*:  201:        memory_pool_free(&g_analyzer->query_text_pool, str);
call    0 returned 100%
call    1 never executed
call    2 returned 100%
call    3 returned 100%
        -:  202:    }
        -:  203:}
        -:  204:
        -:  205:// Fast SQL query type detection
     3278:  206:static SqlQueryType detect_query_type(const char* query) {
     3278:  207:    if (!query) return SQL_UNKNOWN;
        -:  208:    
        -:  209:    // Skip whitespace
    3285*:  210:    while (isspace(*query)) query++;
        -:  211:    
        -:  212:    // Convert first word to uppercase and compare
     3278:  213:    if (strncasecmp(query, "SELECT", 6) == 0) return SQL_SELECT;
      607:  214:    if (strncasecmp(query, "INSERT", 6) == 0) return SQL_INSERT;
      407:  215:    if (strncasecmp(query, "UPDATE", 6) == 0) return SQL_UPDATE;
      198:  216:    if (strncasecmp(query, "DELETE", 6) == 0) return SQL_DELETE;
       4*:  217:    if (strncasecmp(query, "CREATE", 6) == 0) return SQL_CREATE;
       3*:  218:    if (strncasecmp(query, "DROP", 4) == 0) return SQL_DROP;
       2*:  219:    if (strncasecmp(query, "ALTER", 5) == 0) return SQL_ALTER;
        -:  220:    
        -:  221:    return SQL_UNKNOWN;
        -:  222:}
------------------
detect_query_type:
function detect_query_type called 173 returned 100% blocks executed 58%
      173:  206:static SqlQueryType detect_query_type(const char* query) {
      173:  207:    if (!query) return SQL_UNKNOWN;
branch  0 taken 100%
branch  1 taken 0%
        -:  208:    
        -:  209:    // Skip whitespace
     173*:  210:    while (isspace(*query)) query++;
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        -:  211:    
        -:  212:    // Convert first word to uppercase and compare
      173:  213:    if (strncasecmp(query, "SELECT", 6) == 0) return SQL_SELECT;
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
        3:  214:    if (strncasecmp(query, "INSERT", 6) == 0) return SQL_INSERT;
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        2:  215:    if (strncasecmp(query, "UPDATE", 6) == 0) return SQL_UPDATE;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:  216:    if (strncasecmp(query, "DELETE", 6) == 0) return SQL_DELETE;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  217:    if (strncasecmp(query, "CREATE", 6) == 0) return SQL_CREATE;
branch  0 never executed
branch  1 never executed
    #####:  218:    if (strncasecmp(query, "DROP", 4) == 0) return SQL_DROP;
branch  0 never executed
branch  1 never executed
    #####:  219:    if (strncasecmp(query, "ALTER", 5) == 0) return SQL_ALTER;
branch  0 never executed
branch  1 never executed
        -:  220:    
        -:  221:    return SQL_UNKNOWN;
        -:  222:}
------------------
detect_query_type:
function detect_query_type called 3105 returned 100% blocks executed 100%
     3105:  206:static SqlQueryType detect_query_type(const char* query) {
     3105:  207:    if (!query) return SQL_UNKNOWN;
branch  0 taken 100%
branch  1 taken 0%
        -:  208:    
        -:  209:    // Skip whitespace
     3112:  210:    while (isspace(*query)) query++;
branch  0 taken 1%
branch  1 taken 100% (fallthrough)
        -:  211:    
        -:  212:    // Convert first word to uppercase and compare
     3105:  213:    if (strncasecmp(query, "SELECT", 6) == 0) return SQL_SELECT;
branch  0 taken 19% (fallthrough)
branch  1 taken 81%
      604:  214:    if (strncasecmp(query, "INSERT", 6) == 0) return SQL_INSERT;
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
      405:  215:    if (strncasecmp(query, "UPDATE", 6) == 0) return SQL_UPDATE;
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
      197:  216:    if (strncasecmp(query, "DELETE", 6) == 0) return SQL_DELETE;
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
        4:  217:    if (strncasecmp(query, "CREATE", 6) == 0) return SQL_CREATE;
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        3:  218:    if (strncasecmp(query, "DROP", 4) == 0) return SQL_DROP;
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        2:  219:    if (strncasecmp(query, "ALTER", 5) == 0) return SQL_ALTER;
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  220:    
        -:  221:    return SQL_UNKNOWN;
        -:  222:}
------------------
        -:  223:
        -:  224:// Normalize query for similarity comparison
     3278:  225:static void normalize_query(const char* query, char* normalized, size_t max_len) {
     3278:  226:    if (!query || !normalized || max_len == 0) return;
        -:  227:    
        -:  228:    size_t i = 0, j = 0;
        -:  229:    bool in_quotes = false;
        -:  230:    bool prev_space = false;
        -:  231:    
   226309:  232:    while (query[i] && j < max_len - 1) {
        -:  233:        char c = query[i];
        -:  234:        
        -:  235:        // Handle quoted strings
   223031:  236:        if (c == '\'' || c == '"') {
        5:  237:            in_quotes = !in_quotes;
        5:  238:            normalized[j++] = '?';  // Replace quoted content with placeholder
       25:  239:            while (query[++i] && query[i] != c && j < max_len - 1) {
        -:  240:                // Skip quoted content
        -:  241:            }
        5:  242:            if (query[i] == c) i++;  // Skip closing quote
        5:  243:            continue;
        -:  244:        }
        -:  245:        
   223026:  246:        if (!in_quotes) {
        -:  247:            // Replace numbers with placeholder
   222997:  248:            if (isdigit(c)) {
    12395:  249:                normalized[j++] = '?';
    50527:  250:                while (query[i] && isdigit(query[i])) i++;
    12395:  251:                continue;
        -:  252:            }
        -:  253:            
        -:  254:            // Normalize whitespace
   210602:  255:            if (isspace(c)) {
    24543:  256:                if (!prev_space) {
    24262:  257:                    normalized[j++] = ' ';
        -:  258:                    prev_space = true;
        -:  259:                }
    24543:  260:                i++;
    24543:  261:                continue;
        -:  262:            }
        -:  263:            
        -:  264:            prev_space = false;
   186059:  265:            normalized[j++] = tolower(c);
        -:  266:        }
        -:  267:        
   186088:  268:        i++;
        -:  269:    }
        -:  270:    
     3278:  271:    normalized[j] = '\0';
        -:  272:    
        -:  273:    // Trim trailing whitespace
     3283:  274:    while (j > 0 && isspace(normalized[j-1])) {
       5*:  275:        normalized[--j] = '\0';
        -:  276:    }
        -:  277:}
------------------
normalize_query:
function normalize_query called 173 returned 100% blocks executed 97%
      173:  225:static void normalize_query(const char* query, char* normalized, size_t max_len) {
      173:  226:    if (!query || !normalized || max_len == 0) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -:  227:    
        -:  228:    size_t i = 0, j = 0;
        -:  229:    bool in_quotes = false;
        -:  230:    bool prev_space = false;
        -:  231:    
     7199:  232:    while (query[i] && j < max_len - 1) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
        -:  233:        char c = query[i];
        -:  234:        
        -:  235:        // Handle quoted strings
     7026:  236:        if (c == '\'' || c == '"') {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        2:  237:            in_quotes = !in_quotes;
        2:  238:            normalized[j++] = '?';  // Replace quoted content with placeholder
       10:  239:            while (query[++i] && query[i] != c && j < max_len - 1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 80% (fallthrough)
branch  3 taken 20%
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
        -:  240:                // Skip quoted content
        -:  241:            }
        2:  242:            if (query[i] == c) i++;  // Skip closing quote
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  243:            continue;
        -:  244:        }
        -:  245:        
     7024:  246:        if (!in_quotes) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:  247:            // Replace numbers with placeholder
     7010:  248:            if (isdigit(c)) {
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
      309:  249:                normalized[j++] = '?';
      809:  250:                while (query[i] && isdigit(query[i])) i++;
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
branch  2 taken 68%
branch  3 taken 32% (fallthrough)
      309:  251:                continue;
        -:  252:            }
        -:  253:            
        -:  254:            // Normalize whitespace
     6701:  255:            if (isspace(c)) {
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
     1198:  256:                if (!prev_space) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     1198:  257:                    normalized[j++] = ' ';
        -:  258:                    prev_space = true;
        -:  259:                }
     1198:  260:                i++;
     1198:  261:                continue;
        -:  262:            }
        -:  263:            
        -:  264:            prev_space = false;
     5503:  265:            normalized[j++] = tolower(c);
        -:  266:        }
        -:  267:        
     5517:  268:        i++;
        -:  269:    }
        -:  270:    
      173:  271:    normalized[j] = '\0';
        -:  272:    
        -:  273:    // Trim trailing whitespace
      173:  274:    while (j > 0 && isspace(normalized[j-1])) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
    #####:  275:        normalized[--j] = '\0';
        -:  276:    }
        -:  277:}
------------------
normalize_query:
function normalize_query called 3105 returned 100% blocks executed 100%
     3105:  225:static void normalize_query(const char* query, char* normalized, size_t max_len) {
     3105:  226:    if (!query || !normalized || max_len == 0) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -:  227:    
        -:  228:    size_t i = 0, j = 0;
        -:  229:    bool in_quotes = false;
        -:  230:    bool prev_space = false;
        -:  231:    
   219110:  232:    while (query[i] && j < max_len - 1) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 100%
branch  3 taken 1% (fallthrough)
        -:  233:        char c = query[i];
        -:  234:        
        -:  235:        // Handle quoted strings
   216005:  236:        if (c == '\'' || c == '"') {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        3:  237:            in_quotes = !in_quotes;
        3:  238:            normalized[j++] = '?';  // Replace quoted content with placeholder
       15:  239:            while (query[++i] && query[i] != c && j < max_len - 1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 80% (fallthrough)
branch  3 taken 20%
branch  4 taken 100%
branch  5 taken 0% (fallthrough)
        -:  240:                // Skip quoted content
        -:  241:            }
        3:  242:            if (query[i] == c) i++;  // Skip closing quote
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3:  243:            continue;
        -:  244:        }
        -:  245:        
   216002:  246:        if (!in_quotes) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:  247:            // Replace numbers with placeholder
   215987:  248:            if (isdigit(c)) {
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
    12086:  249:                normalized[j++] = '?';
    49718:  250:                while (query[i] && isdigit(query[i])) i++;
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
branch  2 taken 80%
branch  3 taken 20% (fallthrough)
    12086:  251:                continue;
        -:  252:            }
        -:  253:            
        -:  254:            // Normalize whitespace
   203901:  255:            if (isspace(c)) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
    23345:  256:                if (!prev_space) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
    23064:  257:                    normalized[j++] = ' ';
        -:  258:                    prev_space = true;
        -:  259:                }
    23345:  260:                i++;
    23345:  261:                continue;
        -:  262:            }
        -:  263:            
        -:  264:            prev_space = false;
   180556:  265:            normalized[j++] = tolower(c);
        -:  266:        }
        -:  267:        
   180571:  268:        i++;
        -:  269:    }
        -:  270:    
     3105:  271:    normalized[j] = '\0';
        -:  272:    
        -:  273:    // Trim trailing whitespace
     3110:  274:    while (j > 0 && isspace(normalized[j-1])) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
branch  2 taken 1%
branch  3 taken 100% (fallthrough)
        5:  275:        normalized[--j] = '\0';
        -:  276:    }
        -:  277:}
------------------
        -:  278:
        -:  279:// Calculate Jaccard similarity between two normalized queries
        -:  280:#ifdef ENABLE_UNUSED_FUNCTIONS
        -:  281:static double calculate_jaccard_similarity(const char* query1, const char* query2) {
        -:  282:    if (!query1 || !query2) return 0.0;
        -:  283:    
        -:  284:    // This is a simplified similarity calculation that avoids memory allocation
        -:  285:    // In practice, you'd use a more sophisticated algorithm
        -:  286:    int len1 = strlen(query1);
        -:  287:    int len2 = strlen(query2);
        -:  288:    int max_len = (len1 > len2) ? len1 : len2;
        -:  289:    int min_len = (len1 < len2) ? len1 : len2;
        -:  290:    
        -:  291:    if (max_len == 0) {
        -:  292:        return 0.0;
        -:  293:    }
        -:  294:    
        -:  295:    // Calculate similarity based on common subsequences
        -:  296:    double similarity = (double)min_len / max_len;
        -:  297:    
        -:  298:    // Boost similarity if queries have same structure
        -:  299:    if (strstr(query1, "select") && strstr(query2, "select")) {
        -:  300:        similarity *= 1.2;
        -:  301:    }
        -:  302:    if (strstr(query1, "where") && strstr(query2, "where")) {
        -:  303:        similarity *= 1.1;
        -:  304:    }
        -:  305:    
        -:  306:    return (similarity > 1.0) ? 1.0 : similarity;
        -:  307:}
        -:  308:#endif
        -:  309:
        -:  310:// === CORE ANALYZER FUNCTIONS ===
        -:  311:
        -:  312:// Initialize query analyzer
        2:  313:static MercuryError init_query_analyzer(void) {
        2:  314:    if (g_analyzer) {
        -:  315:        return MERCURY_SUCCESS;  // Already initialized
        -:  316:    }
        -:  317:    
        2:  318:    g_analyzer = mercury_aligned_alloc(sizeof(QueryAnalyzer), 64);
        2:  319:    if (!g_analyzer) {
    #####:  320:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate query analyzer");
    #####:  321:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  322:    }
        -:  323:    
        -:  324:    // Zero-initialize the entire structure
        -:  325:    memset(g_analyzer, 0, sizeof(QueryAnalyzer));
        -:  326:    
        -:  327:    // Initialize ring buffer for query history
        2:  328:    g_analyzer->query_history = mercury_ring_buffer_create(sizeof(MercuryQueryRecord), MAX_QUERY_HISTORY);
        2:  329:    if (!g_analyzer->query_history) {
    #####:  330:        mercury_aligned_free(g_analyzer);
    #####:  331:        g_analyzer = NULL;
    #####:  332:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  333:    }
        -:  334:    
        -:  335:    // Initialize SQL patterns
        -:  336:    size_t num_patterns = sizeof(sql_patterns) / sizeof(sql_patterns[0]);
        2:  337:    g_analyzer->patterns = malloc(num_patterns * sizeof(SqlPattern));
        2:  338:    if (!g_analyzer->patterns) {
    #####:  339:        mercury_ring_buffer_destroy(g_analyzer->query_history);
    #####:  340:        mercury_aligned_free(g_analyzer);
    #####:  341:        g_analyzer = NULL;
    #####:  342:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate SQL patterns");
    #####:  343:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  344:    }
        -:  345:    
        2:  346:    g_analyzer->pattern_count = num_patterns;
        -:  347:    
        -:  348:    // Initialize Boyer-Moore patterns
       40:  349:    for (size_t i = 0; i < num_patterns; i++) {
       38:  350:        strncpy(g_analyzer->patterns[i].pattern_text, sql_patterns[i], sizeof(g_analyzer->patterns[i].pattern_text) - 1);
       38:  351:        g_analyzer->patterns[i].pattern_text[sizeof(g_analyzer->patterns[i].pattern_text) - 1] = '\0';
       38:  352:        g_analyzer->patterns[i].pattern_matcher = mercury_boyer_moore_create(sql_patterns[i]);
       38:  353:        g_analyzer->patterns[i].query_type = pattern_types[i];
       64:  354:        g_analyzer->patterns[i].priority = (i < 6) ? 10 : 5;  // High priority for N+1 patterns
        -:  355:    }
        -:  356:    
        -:  357:    // Initialize memory pool for query text storage (4KB blocks, 2500 blocks = ~10MB)
        2:  358:    memory_pool_init(&g_analyzer->query_text_pool, 4096, 2500);
        -:  359:    
        -:  360:    // Initialize query clusters
        2:  361:    g_analyzer->max_clusters = 100;
        2:  362:    g_analyzer->clusters = malloc(g_analyzer->max_clusters * sizeof(QueryCluster));
        2:  363:    if (!g_analyzer->clusters) {
        -:  364:        // Cleanup on failure
    #####:  365:        memory_pool_destroy(&g_analyzer->query_text_pool);
    #####:  366:        for (size_t i = 0; i < num_patterns; i++) {
    #####:  367:            mercury_boyer_moore_destroy(g_analyzer->patterns[i].pattern_matcher);
        -:  368:        }
    #####:  369:        free(g_analyzer->patterns);
    #####:  370:        mercury_ring_buffer_destroy(g_analyzer->query_history);
    #####:  371:        mercury_aligned_free(g_analyzer);
    #####:  372:        g_analyzer = NULL;
    #####:  373:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate query clusters");
    #####:  374:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  375:    }
        -:  376:    
        2:  377:    g_analyzer->cluster_count = 0;
        -:  378:    
        -:  379:    // Initialize thread safety mutexes
        2:  380:    if (pthread_mutex_init(&g_analyzer->cluster_mutex, NULL) != 0) {
        -:  381:        // Cleanup on failure
    #####:  382:        free(g_analyzer->clusters);
    #####:  383:        memory_pool_destroy(&g_analyzer->query_text_pool);
    #####:  384:        for (size_t i = 0; i < num_patterns; i++) {
    #####:  385:            mercury_boyer_moore_destroy(g_analyzer->patterns[i].pattern_matcher);
        -:  386:        }
    #####:  387:        free(g_analyzer->patterns);
    #####:  388:        mercury_ring_buffer_destroy(g_analyzer->query_history);
    #####:  389:        mercury_aligned_free(g_analyzer);
    #####:  390:        g_analyzer = NULL;
    #####:  391:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to initialize cluster mutex");
    #####:  392:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  393:    }
        -:  394:    
        2:  395:    if (pthread_mutex_init(&g_analyzer->history_mutex, NULL) != 0) {
        -:  396:        // Cleanup on failure
    #####:  397:        pthread_mutex_destroy(&g_analyzer->cluster_mutex);
    #####:  398:        free(g_analyzer->clusters);
    #####:  399:        memory_pool_destroy(&g_analyzer->query_text_pool);
    #####:  400:        for (size_t i = 0; i < num_patterns; i++) {
    #####:  401:            mercury_boyer_moore_destroy(g_analyzer->patterns[i].pattern_matcher);
        -:  402:        }
    #####:  403:        free(g_analyzer->patterns);
    #####:  404:        mercury_ring_buffer_destroy(g_analyzer->query_history);
    #####:  405:        mercury_aligned_free(g_analyzer);
    #####:  406:        g_analyzer = NULL;
    #####:  407:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to initialize history mutex");
    #####:  408:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  409:    }
        -:  410:    
        -:  411:    // Initialize statistics
        2:  412:    g_analyzer->total_queries_analyzed = 0;
        2:  413:    g_analyzer->n_plus_one_patterns_detected = 0;
        2:  414:    g_analyzer->similar_queries_found = 0;
        -:  415:    
        2:  416:    g_analyzer->current_severity = N_PLUS_ONE_NONE;
        2:  417:    g_analyzer->estimated_cause = 0;
        2:  418:    strcpy(g_analyzer->optimization_suggestion, "No optimization needed");
        -:  419:    
        -:  420:    // MERCURY_INFO("Query analyzer initialized with %zu patterns", num_patterns);  // Too verbose
        2:  421:    return MERCURY_SUCCESS;
        -:  422:}
------------------
init_query_analyzer:
function init_query_analyzer called 1 returned 100% blocks executed 39%
        1:  313:static MercuryError init_query_analyzer(void) {
        1:  314:    if (g_analyzer) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  315:        return MERCURY_SUCCESS;  // Already initialized
        -:  316:    }
        -:  317:    
        1:  318:    g_analyzer = mercury_aligned_alloc(sizeof(QueryAnalyzer), 64);
call    0 returned 100%
        1:  319:    if (!g_analyzer) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  320:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate query analyzer");
    #####:  321:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  322:    }
        -:  323:    
        -:  324:    // Zero-initialize the entire structure
        -:  325:    memset(g_analyzer, 0, sizeof(QueryAnalyzer));
        -:  326:    
        -:  327:    // Initialize ring buffer for query history
        1:  328:    g_analyzer->query_history = mercury_ring_buffer_create(sizeof(MercuryQueryRecord), MAX_QUERY_HISTORY);
call    0 returned 100%
        1:  329:    if (!g_analyzer->query_history) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  330:        mercury_aligned_free(g_analyzer);
call    0 never executed
    #####:  331:        g_analyzer = NULL;
    #####:  332:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  333:    }
        -:  334:    
        -:  335:    // Initialize SQL patterns
        -:  336:    size_t num_patterns = sizeof(sql_patterns) / sizeof(sql_patterns[0]);
        1:  337:    g_analyzer->patterns = malloc(num_patterns * sizeof(SqlPattern));
        1:  338:    if (!g_analyzer->patterns) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  339:        mercury_ring_buffer_destroy(g_analyzer->query_history);
call    0 never executed
    #####:  340:        mercury_aligned_free(g_analyzer);
call    0 never executed
    #####:  341:        g_analyzer = NULL;
    #####:  342:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate SQL patterns");
    #####:  343:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  344:    }
        -:  345:    
        1:  346:    g_analyzer->pattern_count = num_patterns;
        -:  347:    
        -:  348:    // Initialize Boyer-Moore patterns
       20:  349:    for (size_t i = 0; i < num_patterns; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       19:  350:        strncpy(g_analyzer->patterns[i].pattern_text, sql_patterns[i], sizeof(g_analyzer->patterns[i].pattern_text) - 1);
call    0 returned 100%
       19:  351:        g_analyzer->patterns[i].pattern_text[sizeof(g_analyzer->patterns[i].pattern_text) - 1] = '\0';
       19:  352:        g_analyzer->patterns[i].pattern_matcher = mercury_boyer_moore_create(sql_patterns[i]);
call    0 returned 100%
       19:  353:        g_analyzer->patterns[i].query_type = pattern_types[i];
       32:  354:        g_analyzer->patterns[i].priority = (i < 6) ? 10 : 5;  // High priority for N+1 patterns
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
        -:  355:    }
        -:  356:    
        -:  357:    // Initialize memory pool for query text storage (4KB blocks, 2500 blocks = ~10MB)
        1:  358:    memory_pool_init(&g_analyzer->query_text_pool, 4096, 2500);
call    0 returned 100%
        -:  359:    
        -:  360:    // Initialize query clusters
        1:  361:    g_analyzer->max_clusters = 100;
        1:  362:    g_analyzer->clusters = malloc(g_analyzer->max_clusters * sizeof(QueryCluster));
        1:  363:    if (!g_analyzer->clusters) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  364:        // Cleanup on failure
    #####:  365:        memory_pool_destroy(&g_analyzer->query_text_pool);
call    0 never executed
    #####:  366:        for (size_t i = 0; i < num_patterns; i++) {
branch  0 never executed
branch  1 never executed
    #####:  367:            mercury_boyer_moore_destroy(g_analyzer->patterns[i].pattern_matcher);
call    0 never executed
        -:  368:        }
    #####:  369:        free(g_analyzer->patterns);
    #####:  370:        mercury_ring_buffer_destroy(g_analyzer->query_history);
call    0 never executed
    #####:  371:        mercury_aligned_free(g_analyzer);
call    0 never executed
    #####:  372:        g_analyzer = NULL;
    #####:  373:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate query clusters");
    #####:  374:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  375:    }
        -:  376:    
        1:  377:    g_analyzer->cluster_count = 0;
        -:  378:    
        -:  379:    // Initialize thread safety mutexes
        1:  380:    if (pthread_mutex_init(&g_analyzer->cluster_mutex, NULL) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  381:        // Cleanup on failure
    #####:  382:        free(g_analyzer->clusters);
    #####:  383:        memory_pool_destroy(&g_analyzer->query_text_pool);
call    0 never executed
    #####:  384:        for (size_t i = 0; i < num_patterns; i++) {
branch  0 never executed
branch  1 never executed
    #####:  385:            mercury_boyer_moore_destroy(g_analyzer->patterns[i].pattern_matcher);
call    0 never executed
        -:  386:        }
    #####:  387:        free(g_analyzer->patterns);
    #####:  388:        mercury_ring_buffer_destroy(g_analyzer->query_history);
call    0 never executed
    #####:  389:        mercury_aligned_free(g_analyzer);
call    0 never executed
    #####:  390:        g_analyzer = NULL;
    #####:  391:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to initialize cluster mutex");
    #####:  392:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  393:    }
        -:  394:    
        1:  395:    if (pthread_mutex_init(&g_analyzer->history_mutex, NULL) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  396:        // Cleanup on failure
    #####:  397:        pthread_mutex_destroy(&g_analyzer->cluster_mutex);
call    0 never executed
    #####:  398:        free(g_analyzer->clusters);
    #####:  399:        memory_pool_destroy(&g_analyzer->query_text_pool);
call    0 never executed
    #####:  400:        for (size_t i = 0; i < num_patterns; i++) {
branch  0 never executed
branch  1 never executed
    #####:  401:            mercury_boyer_moore_destroy(g_analyzer->patterns[i].pattern_matcher);
call    0 never executed
        -:  402:        }
    #####:  403:        free(g_analyzer->patterns);
    #####:  404:        mercury_ring_buffer_destroy(g_analyzer->query_history);
call    0 never executed
    #####:  405:        mercury_aligned_free(g_analyzer);
call    0 never executed
    #####:  406:        g_analyzer = NULL;
    #####:  407:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to initialize history mutex");
    #####:  408:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  409:    }
        -:  410:    
        -:  411:    // Initialize statistics
        1:  412:    g_analyzer->total_queries_analyzed = 0;
        1:  413:    g_analyzer->n_plus_one_patterns_detected = 0;
        1:  414:    g_analyzer->similar_queries_found = 0;
        -:  415:    
        1:  416:    g_analyzer->current_severity = N_PLUS_ONE_NONE;
        1:  417:    g_analyzer->estimated_cause = 0;
        1:  418:    strcpy(g_analyzer->optimization_suggestion, "No optimization needed");
        -:  419:    
        -:  420:    // MERCURY_INFO("Query analyzer initialized with %zu patterns", num_patterns);  // Too verbose
        1:  421:    return MERCURY_SUCCESS;
        -:  422:}
------------------
init_query_analyzer:
function init_query_analyzer called 1 returned 100% blocks executed 39%
        1:  313:static MercuryError init_query_analyzer(void) {
        1:  314:    if (g_analyzer) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  315:        return MERCURY_SUCCESS;  // Already initialized
        -:  316:    }
        -:  317:    
        1:  318:    g_analyzer = mercury_aligned_alloc(sizeof(QueryAnalyzer), 64);
call    0 returned 100%
        1:  319:    if (!g_analyzer) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  320:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate query analyzer");
    #####:  321:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  322:    }
        -:  323:    
        -:  324:    // Zero-initialize the entire structure
        -:  325:    memset(g_analyzer, 0, sizeof(QueryAnalyzer));
        -:  326:    
        -:  327:    // Initialize ring buffer for query history
        1:  328:    g_analyzer->query_history = mercury_ring_buffer_create(sizeof(MercuryQueryRecord), MAX_QUERY_HISTORY);
call    0 returned 100%
        1:  329:    if (!g_analyzer->query_history) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  330:        mercury_aligned_free(g_analyzer);
call    0 never executed
    #####:  331:        g_analyzer = NULL;
    #####:  332:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  333:    }
        -:  334:    
        -:  335:    // Initialize SQL patterns
        -:  336:    size_t num_patterns = sizeof(sql_patterns) / sizeof(sql_patterns[0]);
        1:  337:    g_analyzer->patterns = malloc(num_patterns * sizeof(SqlPattern));
        1:  338:    if (!g_analyzer->patterns) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  339:        mercury_ring_buffer_destroy(g_analyzer->query_history);
call    0 never executed
    #####:  340:        mercury_aligned_free(g_analyzer);
call    0 never executed
    #####:  341:        g_analyzer = NULL;
    #####:  342:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate SQL patterns");
    #####:  343:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  344:    }
        -:  345:    
        1:  346:    g_analyzer->pattern_count = num_patterns;
        -:  347:    
        -:  348:    // Initialize Boyer-Moore patterns
       20:  349:    for (size_t i = 0; i < num_patterns; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       19:  350:        strncpy(g_analyzer->patterns[i].pattern_text, sql_patterns[i], sizeof(g_analyzer->patterns[i].pattern_text) - 1);
call    0 returned 100%
       19:  351:        g_analyzer->patterns[i].pattern_text[sizeof(g_analyzer->patterns[i].pattern_text) - 1] = '\0';
       19:  352:        g_analyzer->patterns[i].pattern_matcher = mercury_boyer_moore_create(sql_patterns[i]);
call    0 returned 100%
       19:  353:        g_analyzer->patterns[i].query_type = pattern_types[i];
       32:  354:        g_analyzer->patterns[i].priority = (i < 6) ? 10 : 5;  // High priority for N+1 patterns
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
        -:  355:    }
        -:  356:    
        -:  357:    // Initialize memory pool for query text storage (4KB blocks, 2500 blocks = ~10MB)
        1:  358:    memory_pool_init(&g_analyzer->query_text_pool, 4096, 2500);
call    0 returned 100%
        -:  359:    
        -:  360:    // Initialize query clusters
        1:  361:    g_analyzer->max_clusters = 100;
        1:  362:    g_analyzer->clusters = malloc(g_analyzer->max_clusters * sizeof(QueryCluster));
        1:  363:    if (!g_analyzer->clusters) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  364:        // Cleanup on failure
    #####:  365:        memory_pool_destroy(&g_analyzer->query_text_pool);
call    0 never executed
    #####:  366:        for (size_t i = 0; i < num_patterns; i++) {
branch  0 never executed
branch  1 never executed
    #####:  367:            mercury_boyer_moore_destroy(g_analyzer->patterns[i].pattern_matcher);
call    0 never executed
        -:  368:        }
    #####:  369:        free(g_analyzer->patterns);
    #####:  370:        mercury_ring_buffer_destroy(g_analyzer->query_history);
call    0 never executed
    #####:  371:        mercury_aligned_free(g_analyzer);
call    0 never executed
    #####:  372:        g_analyzer = NULL;
    #####:  373:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate query clusters");
    #####:  374:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  375:    }
        -:  376:    
        1:  377:    g_analyzer->cluster_count = 0;
        -:  378:    
        -:  379:    // Initialize thread safety mutexes
        1:  380:    if (pthread_mutex_init(&g_analyzer->cluster_mutex, NULL) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  381:        // Cleanup on failure
    #####:  382:        free(g_analyzer->clusters);
    #####:  383:        memory_pool_destroy(&g_analyzer->query_text_pool);
call    0 never executed
    #####:  384:        for (size_t i = 0; i < num_patterns; i++) {
branch  0 never executed
branch  1 never executed
    #####:  385:            mercury_boyer_moore_destroy(g_analyzer->patterns[i].pattern_matcher);
call    0 never executed
        -:  386:        }
    #####:  387:        free(g_analyzer->patterns);
    #####:  388:        mercury_ring_buffer_destroy(g_analyzer->query_history);
call    0 never executed
    #####:  389:        mercury_aligned_free(g_analyzer);
call    0 never executed
    #####:  390:        g_analyzer = NULL;
    #####:  391:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to initialize cluster mutex");
    #####:  392:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  393:    }
        -:  394:    
        1:  395:    if (pthread_mutex_init(&g_analyzer->history_mutex, NULL) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  396:        // Cleanup on failure
    #####:  397:        pthread_mutex_destroy(&g_analyzer->cluster_mutex);
call    0 never executed
    #####:  398:        free(g_analyzer->clusters);
    #####:  399:        memory_pool_destroy(&g_analyzer->query_text_pool);
call    0 never executed
    #####:  400:        for (size_t i = 0; i < num_patterns; i++) {
branch  0 never executed
branch  1 never executed
    #####:  401:            mercury_boyer_moore_destroy(g_analyzer->patterns[i].pattern_matcher);
call    0 never executed
        -:  402:        }
    #####:  403:        free(g_analyzer->patterns);
    #####:  404:        mercury_ring_buffer_destroy(g_analyzer->query_history);
call    0 never executed
    #####:  405:        mercury_aligned_free(g_analyzer);
call    0 never executed
    #####:  406:        g_analyzer = NULL;
    #####:  407:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to initialize history mutex");
    #####:  408:        return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  409:    }
        -:  410:    
        -:  411:    // Initialize statistics
        1:  412:    g_analyzer->total_queries_analyzed = 0;
        1:  413:    g_analyzer->n_plus_one_patterns_detected = 0;
        1:  414:    g_analyzer->similar_queries_found = 0;
        -:  415:    
        1:  416:    g_analyzer->current_severity = N_PLUS_ONE_NONE;
        1:  417:    g_analyzer->estimated_cause = 0;
        1:  418:    strcpy(g_analyzer->optimization_suggestion, "No optimization needed");
        -:  419:    
        -:  420:    // MERCURY_INFO("Query analyzer initialized with %zu patterns", num_patterns);  // Too verbose
        1:  421:    return MERCURY_SUCCESS;
        -:  422:}
------------------
        -:  423:
        -:  424:// Cleanup query analyzer
        2:  425:static void cleanup_query_analyzer(void) {
        2:  426:    if (!g_analyzer) return;
        -:  427:    
        -:  428:    // Cleanup patterns
       40:  429:    for (size_t i = 0; i < g_analyzer->pattern_count; i++) {
       38:  430:        mercury_boyer_moore_destroy(g_analyzer->patterns[i].pattern_matcher);
        -:  431:    }
        2:  432:    free(g_analyzer->patterns);
        -:  433:    
        -:  434:    // Cleanup clusters
        2:  435:    free(g_analyzer->clusters);
        -:  436:    
        -:  437:    // Cleanup memory pool
        2:  438:    memory_pool_destroy(&g_analyzer->query_text_pool);
        -:  439:    
        -:  440:    // Cleanup thread safety mutexes
        2:  441:    pthread_mutex_destroy(&g_analyzer->cluster_mutex);
        2:  442:    pthread_mutex_destroy(&g_analyzer->history_mutex);
        -:  443:    
        -:  444:    // Cleanup ring buffer
        2:  445:    mercury_ring_buffer_destroy(g_analyzer->query_history);
        -:  446:    
        2:  447:    mercury_aligned_free(g_analyzer);
        2:  448:    g_analyzer = NULL;
        -:  449:    
        -:  450:    // MERCURY_INFO("Query analyzer cleaned up");  // Too verbose
        -:  451:}
------------------
cleanup_query_analyzer:
function cleanup_query_analyzer called 1 returned 100% blocks executed 100%
        1:  425:static void cleanup_query_analyzer(void) {
        1:  426:    if (!g_analyzer) return;
branch  0 taken 100%
branch  1 taken 0%
        -:  427:    
        -:  428:    // Cleanup patterns
       20:  429:    for (size_t i = 0; i < g_analyzer->pattern_count; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       19:  430:        mercury_boyer_moore_destroy(g_analyzer->patterns[i].pattern_matcher);
call    0 returned 100%
        -:  431:    }
        1:  432:    free(g_analyzer->patterns);
        -:  433:    
        -:  434:    // Cleanup clusters
        1:  435:    free(g_analyzer->clusters);
        -:  436:    
        -:  437:    // Cleanup memory pool
        1:  438:    memory_pool_destroy(&g_analyzer->query_text_pool);
call    0 returned 100%
        -:  439:    
        -:  440:    // Cleanup thread safety mutexes
        1:  441:    pthread_mutex_destroy(&g_analyzer->cluster_mutex);
call    0 returned 100%
        1:  442:    pthread_mutex_destroy(&g_analyzer->history_mutex);
call    0 returned 100%
        -:  443:    
        -:  444:    // Cleanup ring buffer
        1:  445:    mercury_ring_buffer_destroy(g_analyzer->query_history);
call    0 returned 100%
        -:  446:    
        1:  447:    mercury_aligned_free(g_analyzer);
call    0 returned 100%
        1:  448:    g_analyzer = NULL;
        -:  449:    
        -:  450:    // MERCURY_INFO("Query analyzer cleaned up");  // Too verbose
        -:  451:}
------------------
cleanup_query_analyzer:
function cleanup_query_analyzer called 1 returned 100% blocks executed 100%
        1:  425:static void cleanup_query_analyzer(void) {
        1:  426:    if (!g_analyzer) return;
branch  0 taken 100%
branch  1 taken 0%
        -:  427:    
        -:  428:    // Cleanup patterns
       20:  429:    for (size_t i = 0; i < g_analyzer->pattern_count; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
       19:  430:        mercury_boyer_moore_destroy(g_analyzer->patterns[i].pattern_matcher);
call    0 returned 100%
        -:  431:    }
        1:  432:    free(g_analyzer->patterns);
        -:  433:    
        -:  434:    // Cleanup clusters
        1:  435:    free(g_analyzer->clusters);
        -:  436:    
        -:  437:    // Cleanup memory pool
        1:  438:    memory_pool_destroy(&g_analyzer->query_text_pool);
call    0 returned 100%
        -:  439:    
        -:  440:    // Cleanup thread safety mutexes
        1:  441:    pthread_mutex_destroy(&g_analyzer->cluster_mutex);
call    0 returned 100%
        1:  442:    pthread_mutex_destroy(&g_analyzer->history_mutex);
call    0 returned 100%
        -:  443:    
        -:  444:    // Cleanup ring buffer
        1:  445:    mercury_ring_buffer_destroy(g_analyzer->query_history);
call    0 returned 100%
        -:  446:    
        1:  447:    mercury_aligned_free(g_analyzer);
call    0 returned 100%
        1:  448:    g_analyzer = NULL;
        -:  449:    
        -:  450:    // MERCURY_INFO("Query analyzer cleaned up");  // Too verbose
        -:  451:}
------------------
        -:  452:
        -:  453:// Find or create query cluster (thread-safe)
     3278:  454:static QueryCluster* find_or_create_cluster(uint64_t pattern_hash, const char* query) {
     3278:  455:    if (!query || !g_analyzer || !g_analyzer->clusters) {
    #####:  456:        MERCURY_ERROR("Invalid arguments or analyzer state in find_or_create_cluster");
    #####:  457:        return NULL;
        -:  458:    }
        -:  459:    
     3278:  460:    pthread_mutex_lock(&g_analyzer->cluster_mutex);
        -:  461:    
        -:  462:    // Look for existing cluster with bounds checking
     4806:  463:    for (size_t i = 0; i < g_analyzer->cluster_count && i < g_analyzer->max_clusters; i++) {
     4753:  464:        if (g_analyzer->clusters[i].pattern_hash == pattern_hash) {
     3225:  465:            pthread_mutex_unlock(&g_analyzer->cluster_mutex);
     3225:  466:            return &g_analyzer->clusters[i];
        -:  467:        }
        -:  468:    }
        -:  469:    
        -:  470:    // Create new cluster - resize array if needed
       53:  471:    if (g_analyzer->cluster_count >= g_analyzer->max_clusters) {
        -:  472:        // Try to resize cluster array (double the size) with overflow protection
        -:  473:        size_t current_max = g_analyzer->max_clusters;
    #####:  474:        if (current_max > SIZE_MAX / 2 || current_max > 10000) {
        -:  475:            // Prevent overflow and limit maximum clusters to reasonable size
    #####:  476:            MERCURY_WARN("Cluster array at maximum size (%zu), attempting eviction", current_max);
        -:  477:        } else {
    #####:  478:            size_t new_max = current_max * 2;
        -:  479:            // Save old pointer in case realloc fails - prevents memory leak
    #####:  480:            QueryCluster* old_clusters = g_analyzer->clusters;
    #####:  481:            QueryCluster* new_clusters = realloc(old_clusters, new_max * sizeof(QueryCluster));
        -:  482:            
    #####:  483:            if (new_clusters) {
    #####:  484:                g_analyzer->clusters = new_clusters;
    #####:  485:                g_analyzer->max_clusters = new_max;
        -:  486:                MERCURY_DEBUG("Resized cluster array to %zu entries", new_max);
        -:  487:            } else {
        -:  488:                // realloc failed - old_clusters is still valid and unchanged
    #####:  489:                g_analyzer->clusters = old_clusters;  // Restore original pointer
    #####:  490:                MERCURY_WARN("Failed to resize cluster array from %zu to %zu entries", current_max, new_max);
        -:  491:            }
        -:  492:        }
        -:  493:        
        -:  494:        // If we still don't have space after attempted resize, try eviction
    #####:  495:        if (g_analyzer->cluster_count >= g_analyzer->max_clusters) {
        -:  496:            // Try to evict oldest cluster to make space
    #####:  497:            if (g_analyzer->cluster_count > 0) {
        -:  498:                // Find oldest cluster (with earliest first_seen timestamp) with bounds checking
        -:  499:                size_t oldest_idx = 0;
    #####:  500:                uint64_t oldest_time = g_analyzer->clusters[0].first_seen.nanoseconds;
        -:  501:                
    #####:  502:                for (size_t i = 1; i < g_analyzer->cluster_count && i < g_analyzer->max_clusters; i++) {
    #####:  503:                    if (g_analyzer->clusters[i].first_seen.nanoseconds < oldest_time) {
        -:  504:                        oldest_time = g_analyzer->clusters[i].first_seen.nanoseconds;
        -:  505:                        oldest_idx = i;
        -:  506:                    }
        -:  507:                }
        -:  508:                
        -:  509:                // Validate indices before memmove to prevent buffer overflow
    #####:  510:                if (oldest_idx < g_analyzer->cluster_count && oldest_idx + 1 < g_analyzer->max_clusters) {
    #####:  511:                    size_t elements_to_move = g_analyzer->cluster_count - oldest_idx - 1;
    #####:  512:                    if (elements_to_move > 0) {
    #####:  513:                        memmove(&g_analyzer->clusters[oldest_idx], 
    #####:  514:                               &g_analyzer->clusters[oldest_idx + 1],
        -:  515:                               elements_to_move * sizeof(QueryCluster));
        -:  516:                    }
    #####:  517:                    g_analyzer->cluster_count--;
        -:  518:                    
        -:  519:                    MERCURY_DEBUG("Evicted oldest cluster at index %zu (max clusters: %zu)", 
        -:  520:                                oldest_idx, g_analyzer->max_clusters);
        -:  521:                } else {
    #####:  522:                    MERCURY_ERROR("Invalid cluster index during eviction: oldest_idx=%zu, count=%zu, max=%zu", 
        -:  523:                                oldest_idx, g_analyzer->cluster_count, g_analyzer->max_clusters);
    #####:  524:                    pthread_mutex_unlock(&g_analyzer->cluster_mutex);
    #####:  525:                    return NULL;
        -:  526:                }
        -:  527:            } else {
    #####:  528:                MERCURY_ERROR("Cannot create cluster - no memory and no existing clusters to evict");
    #####:  529:                pthread_mutex_unlock(&g_analyzer->cluster_mutex);
    #####:  530:                return NULL;
        -:  531:            }
        -:  532:        }
        -:  533:    }
        -:  534:    
        -:  535:    // Final bounds check before creating new cluster
       53:  536:    if (g_analyzer->cluster_count >= g_analyzer->max_clusters) {
    #####:  537:        MERCURY_ERROR("Unable to create cluster - still no space after resize/eviction attempts");
    #####:  538:        pthread_mutex_unlock(&g_analyzer->cluster_mutex);
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
        -:  542:    // Now we have space - create new cluster with bounds checking
        -:  543:    size_t new_cluster_idx = g_analyzer->cluster_count;
        -:  544:    if (new_cluster_idx >= g_analyzer->max_clusters) {
        -:  545:        MERCURY_ERROR("Cluster index out of bounds: %zu >= %zu", new_cluster_idx, g_analyzer->max_clusters);
        -:  546:        pthread_mutex_unlock(&g_analyzer->cluster_mutex);
        -:  547:        return NULL;
        -:  548:    }
        -:  549:    
       53:  550:    QueryCluster* cluster = &g_analyzer->clusters[new_cluster_idx];
       53:  551:    g_analyzer->cluster_count++;
        -:  552:    
       53:  553:    cluster->pattern_hash = pattern_hash;
       53:  554:    cluster->query_count = 0;
       53:  555:    cluster->total_time = 0.0;
       53:  556:    cluster->avg_time = 0.0;
        -:  557:    
        -:  558:    // Safe string copy with bounds checking
       53:  559:    size_t query_len = strlen(query);
        -:  560:    size_t max_copy = sizeof(cluster->representative_query) - 1;
       53:  561:    if (query_len > max_copy) {
       1*:  562:        MERCURY_WARN("Query truncated from %zu to %zu characters", query_len, max_copy);
        -:  563:    }
       53:  564:    strncpy(cluster->representative_query, query, max_copy);
       53:  565:    cluster->representative_query[max_copy] = '\0';
        -:  566:    
       53:  567:    cluster->first_seen = mercury_get_timestamp();
       53:  568:    cluster->last_seen = cluster->first_seen;
        -:  569:    
        -:  570:    MERCURY_DEBUG("Created new cluster at index %zu (hash: %lu)", new_cluster_idx, pattern_hash);
        -:  571:    
       53:  572:    pthread_mutex_unlock(&g_analyzer->cluster_mutex);
       53:  573:    return cluster;
        -:  574:}
------------------
find_or_create_cluster:
function find_or_create_cluster called 173 returned 100% blocks executed 33%
      173:  454:static QueryCluster* find_or_create_cluster(uint64_t pattern_hash, const char* query) {
      173:  455:    if (!query || !g_analyzer || !g_analyzer->clusters) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  456:        MERCURY_ERROR("Invalid arguments or analyzer state in find_or_create_cluster");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  457:        return NULL;
        -:  458:    }
        -:  459:    
      173:  460:    pthread_mutex_lock(&g_analyzer->cluster_mutex);
call    0 returned 100%
        -:  461:    
        -:  462:    // Look for existing cluster with bounds checking
      202:  463:    for (size_t i = 0; i < g_analyzer->cluster_count && i < g_analyzer->max_clusters; i++) {
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
      190:  464:        if (g_analyzer->clusters[i].pattern_hash == pattern_hash) {
branch  0 taken 85% (fallthrough)
branch  1 taken 15%
      161:  465:            pthread_mutex_unlock(&g_analyzer->cluster_mutex);
call    0 returned 100%
      161:  466:            return &g_analyzer->clusters[i];
        -:  467:        }
        -:  468:    }
        -:  469:    
        -:  470:    // Create new cluster - resize array if needed
       12:  471:    if (g_analyzer->cluster_count >= g_analyzer->max_clusters) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  472:        // Try to resize cluster array (double the size) with overflow protection
        -:  473:        size_t current_max = g_analyzer->max_clusters;
    #####:  474:        if (current_max > SIZE_MAX / 2 || current_max > 10000) {
branch  0 never executed
branch  1 never executed
        -:  475:            // Prevent overflow and limit maximum clusters to reasonable size
    #####:  476:            MERCURY_WARN("Cluster array at maximum size (%zu), attempting eviction", current_max);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  477:        } else {
    #####:  478:            size_t new_max = current_max * 2;
        -:  479:            // Save old pointer in case realloc fails - prevents memory leak
    #####:  480:            QueryCluster* old_clusters = g_analyzer->clusters;
    #####:  481:            QueryCluster* new_clusters = realloc(old_clusters, new_max * sizeof(QueryCluster));
        -:  482:            
    #####:  483:            if (new_clusters) {
branch  0 never executed
branch  1 never executed
    #####:  484:                g_analyzer->clusters = new_clusters;
    #####:  485:                g_analyzer->max_clusters = new_max;
        -:  486:                MERCURY_DEBUG("Resized cluster array to %zu entries", new_max);
        -:  487:            } else {
        -:  488:                // realloc failed - old_clusters is still valid and unchanged
    #####:  489:                g_analyzer->clusters = old_clusters;  // Restore original pointer
    #####:  490:                MERCURY_WARN("Failed to resize cluster array from %zu to %zu entries", current_max, new_max);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  491:            }
        -:  492:        }
        -:  493:        
        -:  494:        // If we still don't have space after attempted resize, try eviction
    #####:  495:        if (g_analyzer->cluster_count >= g_analyzer->max_clusters) {
branch  0 never executed
branch  1 never executed
        -:  496:            // Try to evict oldest cluster to make space
    #####:  497:            if (g_analyzer->cluster_count > 0) {
branch  0 never executed
branch  1 never executed
        -:  498:                // Find oldest cluster (with earliest first_seen timestamp) with bounds checking
        -:  499:                size_t oldest_idx = 0;
    #####:  500:                uint64_t oldest_time = g_analyzer->clusters[0].first_seen.nanoseconds;
        -:  501:                
    #####:  502:                for (size_t i = 1; i < g_analyzer->cluster_count && i < g_analyzer->max_clusters; i++) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  503:                    if (g_analyzer->clusters[i].first_seen.nanoseconds < oldest_time) {
branch  0 never executed
branch  1 never executed
        -:  504:                        oldest_time = g_analyzer->clusters[i].first_seen.nanoseconds;
        -:  505:                        oldest_idx = i;
        -:  506:                    }
        -:  507:                }
        -:  508:                
        -:  509:                // Validate indices before memmove to prevent buffer overflow
    #####:  510:                if (oldest_idx < g_analyzer->cluster_count && oldest_idx + 1 < g_analyzer->max_clusters) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  511:                    size_t elements_to_move = g_analyzer->cluster_count - oldest_idx - 1;
    #####:  512:                    if (elements_to_move > 0) {
branch  0 never executed
branch  1 never executed
    #####:  513:                        memmove(&g_analyzer->clusters[oldest_idx], 
    #####:  514:                               &g_analyzer->clusters[oldest_idx + 1],
        -:  515:                               elements_to_move * sizeof(QueryCluster));
        -:  516:                    }
    #####:  517:                    g_analyzer->cluster_count--;
        -:  518:                    
        -:  519:                    MERCURY_DEBUG("Evicted oldest cluster at index %zu (max clusters: %zu)", 
        -:  520:                                oldest_idx, g_analyzer->max_clusters);
        -:  521:                } else {
    #####:  522:                    MERCURY_ERROR("Invalid cluster index during eviction: oldest_idx=%zu, count=%zu, max=%zu", 
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  523:                                oldest_idx, g_analyzer->cluster_count, g_analyzer->max_clusters);
    #####:  524:                    pthread_mutex_unlock(&g_analyzer->cluster_mutex);
call    0 never executed
    #####:  525:                    return NULL;
        -:  526:                }
        -:  527:            } else {
    #####:  528:                MERCURY_ERROR("Cannot create cluster - no memory and no existing clusters to evict");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  529:                pthread_mutex_unlock(&g_analyzer->cluster_mutex);
call    0 never executed
    #####:  530:                return NULL;
        -:  531:            }
        -:  532:        }
        -:  533:    }
        -:  534:    
        -:  535:    // Final bounds check before creating new cluster
       12:  536:    if (g_analyzer->cluster_count >= g_analyzer->max_clusters) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  537:        MERCURY_ERROR("Unable to create cluster - still no space after resize/eviction attempts");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  538:        pthread_mutex_unlock(&g_analyzer->cluster_mutex);
call    0 never executed
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
        -:  542:    // Now we have space - create new cluster with bounds checking
        -:  543:    size_t new_cluster_idx = g_analyzer->cluster_count;
        -:  544:    if (new_cluster_idx >= g_analyzer->max_clusters) {
        -:  545:        MERCURY_ERROR("Cluster index out of bounds: %zu >= %zu", new_cluster_idx, g_analyzer->max_clusters);
        -:  546:        pthread_mutex_unlock(&g_analyzer->cluster_mutex);
        -:  547:        return NULL;
        -:  548:    }
        -:  549:    
       12:  550:    QueryCluster* cluster = &g_analyzer->clusters[new_cluster_idx];
       12:  551:    g_analyzer->cluster_count++;
        -:  552:    
       12:  553:    cluster->pattern_hash = pattern_hash;
       12:  554:    cluster->query_count = 0;
       12:  555:    cluster->total_time = 0.0;
       12:  556:    cluster->avg_time = 0.0;
        -:  557:    
        -:  558:    // Safe string copy with bounds checking
       12:  559:    size_t query_len = strlen(query);
        -:  560:    size_t max_copy = sizeof(cluster->representative_query) - 1;
       12:  561:    if (query_len > max_copy) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  562:        MERCURY_WARN("Query truncated from %zu to %zu characters", query_len, max_copy);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  563:    }
       12:  564:    strncpy(cluster->representative_query, query, max_copy);
call    0 returned 100%
       12:  565:    cluster->representative_query[max_copy] = '\0';
        -:  566:    
       12:  567:    cluster->first_seen = mercury_get_timestamp();
call    0 returned 100%
       12:  568:    cluster->last_seen = cluster->first_seen;
        -:  569:    
        -:  570:    MERCURY_DEBUG("Created new cluster at index %zu (hash: %lu)", new_cluster_idx, pattern_hash);
        -:  571:    
       12:  572:    pthread_mutex_unlock(&g_analyzer->cluster_mutex);
call    0 returned 100%
       12:  573:    return cluster;
        -:  574:}
------------------
find_or_create_cluster:
function find_or_create_cluster called 3105 returned 100% blocks executed 36%
     3105:  454:static QueryCluster* find_or_create_cluster(uint64_t pattern_hash, const char* query) {
     3105:  455:    if (!query || !g_analyzer || !g_analyzer->clusters) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:  456:        MERCURY_ERROR("Invalid arguments or analyzer state in find_or_create_cluster");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  457:        return NULL;
        -:  458:    }
        -:  459:    
     3105:  460:    pthread_mutex_lock(&g_analyzer->cluster_mutex);
call    0 returned 100%
        -:  461:    
        -:  462:    // Look for existing cluster with bounds checking
     4604:  463:    for (size_t i = 0; i < g_analyzer->cluster_count && i < g_analyzer->max_clusters; i++) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
     4563:  464:        if (g_analyzer->clusters[i].pattern_hash == pattern_hash) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
     3064:  465:            pthread_mutex_unlock(&g_analyzer->cluster_mutex);
call    0 returned 100%
     3064:  466:            return &g_analyzer->clusters[i];
        -:  467:        }
        -:  468:    }
        -:  469:    
        -:  470:    // Create new cluster - resize array if needed
       41:  471:    if (g_analyzer->cluster_count >= g_analyzer->max_clusters) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  472:        // Try to resize cluster array (double the size) with overflow protection
        -:  473:        size_t current_max = g_analyzer->max_clusters;
    #####:  474:        if (current_max > SIZE_MAX / 2 || current_max > 10000) {
branch  0 never executed
branch  1 never executed
        -:  475:            // Prevent overflow and limit maximum clusters to reasonable size
    #####:  476:            MERCURY_WARN("Cluster array at maximum size (%zu), attempting eviction", current_max);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  477:        } else {
    #####:  478:            size_t new_max = current_max * 2;
        -:  479:            // Save old pointer in case realloc fails - prevents memory leak
    #####:  480:            QueryCluster* old_clusters = g_analyzer->clusters;
    #####:  481:            QueryCluster* new_clusters = realloc(old_clusters, new_max * sizeof(QueryCluster));
        -:  482:            
    #####:  483:            if (new_clusters) {
branch  0 never executed
branch  1 never executed
    #####:  484:                g_analyzer->clusters = new_clusters;
    #####:  485:                g_analyzer->max_clusters = new_max;
        -:  486:                MERCURY_DEBUG("Resized cluster array to %zu entries", new_max);
        -:  487:            } else {
        -:  488:                // realloc failed - old_clusters is still valid and unchanged
    #####:  489:                g_analyzer->clusters = old_clusters;  // Restore original pointer
    #####:  490:                MERCURY_WARN("Failed to resize cluster array from %zu to %zu entries", current_max, new_max);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  491:            }
        -:  492:        }
        -:  493:        
        -:  494:        // If we still don't have space after attempted resize, try eviction
    #####:  495:        if (g_analyzer->cluster_count >= g_analyzer->max_clusters) {
branch  0 never executed
branch  1 never executed
        -:  496:            // Try to evict oldest cluster to make space
    #####:  497:            if (g_analyzer->cluster_count > 0) {
branch  0 never executed
branch  1 never executed
        -:  498:                // Find oldest cluster (with earliest first_seen timestamp) with bounds checking
        -:  499:                size_t oldest_idx = 0;
    #####:  500:                uint64_t oldest_time = g_analyzer->clusters[0].first_seen.nanoseconds;
        -:  501:                
    #####:  502:                for (size_t i = 1; i < g_analyzer->cluster_count && i < g_analyzer->max_clusters; i++) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  503:                    if (g_analyzer->clusters[i].first_seen.nanoseconds < oldest_time) {
branch  0 never executed
branch  1 never executed
        -:  504:                        oldest_time = g_analyzer->clusters[i].first_seen.nanoseconds;
        -:  505:                        oldest_idx = i;
        -:  506:                    }
        -:  507:                }
        -:  508:                
        -:  509:                // Validate indices before memmove to prevent buffer overflow
    #####:  510:                if (oldest_idx < g_analyzer->cluster_count && oldest_idx + 1 < g_analyzer->max_clusters) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  511:                    size_t elements_to_move = g_analyzer->cluster_count - oldest_idx - 1;
    #####:  512:                    if (elements_to_move > 0) {
branch  0 never executed
branch  1 never executed
    #####:  513:                        memmove(&g_analyzer->clusters[oldest_idx], 
    #####:  514:                               &g_analyzer->clusters[oldest_idx + 1],
        -:  515:                               elements_to_move * sizeof(QueryCluster));
        -:  516:                    }
    #####:  517:                    g_analyzer->cluster_count--;
        -:  518:                    
        -:  519:                    MERCURY_DEBUG("Evicted oldest cluster at index %zu (max clusters: %zu)", 
        -:  520:                                oldest_idx, g_analyzer->max_clusters);
        -:  521:                } else {
    #####:  522:                    MERCURY_ERROR("Invalid cluster index during eviction: oldest_idx=%zu, count=%zu, max=%zu", 
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  523:                                oldest_idx, g_analyzer->cluster_count, g_analyzer->max_clusters);
    #####:  524:                    pthread_mutex_unlock(&g_analyzer->cluster_mutex);
call    0 never executed
    #####:  525:                    return NULL;
        -:  526:                }
        -:  527:            } else {
    #####:  528:                MERCURY_ERROR("Cannot create cluster - no memory and no existing clusters to evict");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  529:                pthread_mutex_unlock(&g_analyzer->cluster_mutex);
call    0 never executed
    #####:  530:                return NULL;
        -:  531:            }
        -:  532:        }
        -:  533:    }
        -:  534:    
        -:  535:    // Final bounds check before creating new cluster
       41:  536:    if (g_analyzer->cluster_count >= g_analyzer->max_clusters) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  537:        MERCURY_ERROR("Unable to create cluster - still no space after resize/eviction attempts");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  538:        pthread_mutex_unlock(&g_analyzer->cluster_mutex);
call    0 never executed
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
        -:  542:    // Now we have space - create new cluster with bounds checking
        -:  543:    size_t new_cluster_idx = g_analyzer->cluster_count;
        -:  544:    if (new_cluster_idx >= g_analyzer->max_clusters) {
        -:  545:        MERCURY_ERROR("Cluster index out of bounds: %zu >= %zu", new_cluster_idx, g_analyzer->max_clusters);
        -:  546:        pthread_mutex_unlock(&g_analyzer->cluster_mutex);
        -:  547:        return NULL;
        -:  548:    }
        -:  549:    
       41:  550:    QueryCluster* cluster = &g_analyzer->clusters[new_cluster_idx];
       41:  551:    g_analyzer->cluster_count++;
        -:  552:    
       41:  553:    cluster->pattern_hash = pattern_hash;
       41:  554:    cluster->query_count = 0;
       41:  555:    cluster->total_time = 0.0;
       41:  556:    cluster->avg_time = 0.0;
        -:  557:    
        -:  558:    // Safe string copy with bounds checking
       41:  559:    size_t query_len = strlen(query);
        -:  560:    size_t max_copy = sizeof(cluster->representative_query) - 1;
       41:  561:    if (query_len > max_copy) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
        1:  562:        MERCURY_WARN("Query truncated from %zu to %zu characters", query_len, max_copy);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  563:    }
       41:  564:    strncpy(cluster->representative_query, query, max_copy);
call    0 returned 100%
       41:  565:    cluster->representative_query[max_copy] = '\0';
        -:  566:    
       41:  567:    cluster->first_seen = mercury_get_timestamp();
call    0 returned 100%
       41:  568:    cluster->last_seen = cluster->first_seen;
        -:  569:    
        -:  570:    MERCURY_DEBUG("Created new cluster at index %zu (hash: %lu)", new_cluster_idx, pattern_hash);
        -:  571:    
       41:  572:    pthread_mutex_unlock(&g_analyzer->cluster_mutex);
call    0 returned 100%
       41:  573:    return cluster;
        -:  574:}
------------------
        -:  575:
        -:  576:// Update N+1 analysis based on current clusters
     3292:  577:static void update_n_plus_one_analysis(void) {
     3292:  578:    if (!g_analyzer) {
        -:  579:        return;
        -:  580:    }
        -:  581:    
        -:  582:    // If no queries analyzed in current session, reset severity to NONE
     3292:  583:    uint64_t total_queries = g_analyzer->total_queries_analyzed;
     3292:  584:    if (total_queries == 0) {
       2*:  585:        g_analyzer->current_severity = N_PLUS_ONE_NONE;
       2*:  586:        g_analyzer->estimated_cause = 0;
       2*:  587:        strcpy(g_analyzer->optimization_suggestion, "No queries analyzed");
       2*:  588:        return;
        -:  589:    }
        -:  590:    
        -:  591:    int max_cluster_size = 0;
        -:  592:    double max_cluster_time = 0.0;
        -:  593:    
        -:  594:    // Analyze all clusters (with bounds checking)
     9297:  595:    for (size_t i = 0; i < g_analyzer->cluster_count && i < g_analyzer->max_clusters; i++) {
     6007:  596:        QueryCluster* cluster = &g_analyzer->clusters[i];
     6007:  597:        if (cluster->query_count > 1) {
        -:  598:            if (cluster->query_count > max_cluster_size) {
        -:  599:                max_cluster_size = cluster->query_count;
        -:  600:            }
     5649:  601:            if (cluster->total_time > max_cluster_time) {
        -:  602:                max_cluster_time = cluster->total_time;
        -:  603:            }
        -:  604:        }
        -:  605:    }
        -:  606:    
        -:  607:    // Determine severity
     3290:  608:    if (max_cluster_size < 3) {
       59:  609:        g_analyzer->current_severity = N_PLUS_ONE_NONE;
       59:  610:        g_analyzer->estimated_cause = 0;
       59:  611:        strcpy(g_analyzer->optimization_suggestion, "No N+1 patterns detected");
     3231:  612:    } else if (max_cluster_size < 8) {
       86:  613:        g_analyzer->current_severity = N_PLUS_ONE_MILD;
       86:  614:        g_analyzer->estimated_cause = 1;
       86:  615:        strcpy(g_analyzer->optimization_suggestion, "Minor duplication detected - review serializer methods");
     3145:  616:    } else if (max_cluster_size < N_PLUS_ONE_THRESHOLD) {
       70:  617:        g_analyzer->current_severity = N_PLUS_ONE_MODERATE;
       70:  618:        g_analyzer->estimated_cause = 2;
       70:  619:        strcpy(g_analyzer->optimization_suggestion, "Use select_related() for foreign key access");
     3075:  620:    } else if (max_cluster_size < 25) {
      160:  621:        g_analyzer->current_severity = N_PLUS_ONE_HIGH;
      160:  622:        g_analyzer->estimated_cause = 3;
      160:  623:        strcpy(g_analyzer->optimization_suggestion, "Add prefetch_related() for reverse foreign keys");
     2915:  624:    } else if (max_cluster_size < 50) {
      236:  625:        g_analyzer->current_severity = N_PLUS_ONE_SEVERE;
      236:  626:        g_analyzer->estimated_cause = 4;
      236:  627:        strcpy(g_analyzer->optimization_suggestion, "Consider database denormalization or caching");
        -:  628:    } else {
     2679:  629:        g_analyzer->current_severity = N_PLUS_ONE_CRITICAL;
     2679:  630:        g_analyzer->estimated_cause = 4;
     2679:  631:        strcpy(g_analyzer->optimization_suggestion, "Critical N+1 - immediate optimization required");
        -:  632:    }
        -:  633:    
     3290:  634:    if (max_cluster_size >= 3) {
     3231:  635:        g_analyzer->n_plus_one_patterns_detected++;
        -:  636:    }
        -:  637:}
------------------
update_n_plus_one_analysis:
function update_n_plus_one_analysis called 175 returned 100% blocks executed 95%
      175:  577:static void update_n_plus_one_analysis(void) {
      175:  578:    if (!g_analyzer) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  579:        return;
        -:  580:    }
        -:  581:    
        -:  582:    // If no queries analyzed in current session, reset severity to NONE
      175:  583:    uint64_t total_queries = g_analyzer->total_queries_analyzed;
      175:  584:    if (total_queries == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  585:        g_analyzer->current_severity = N_PLUS_ONE_NONE;
    #####:  586:        g_analyzer->estimated_cause = 0;
    #####:  587:        strcpy(g_analyzer->optimization_suggestion, "No queries analyzed");
    #####:  588:        return;
        -:  589:    }
        -:  590:    
        -:  591:    int max_cluster_size = 0;
        -:  592:    double max_cluster_time = 0.0;
        -:  593:    
        -:  594:    // Analyze all clusters (with bounds checking)
      381:  595:    for (size_t i = 0; i < g_analyzer->cluster_count && i < g_analyzer->max_clusters; i++) {
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
      206:  596:        QueryCluster* cluster = &g_analyzer->clusters[i];
      206:  597:        if (cluster->query_count > 1) {
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
        -:  598:            if (cluster->query_count > max_cluster_size) {
        -:  599:                max_cluster_size = cluster->query_count;
        -:  600:            }
      163:  601:            if (cluster->total_time > max_cluster_time) {
        -:  602:                max_cluster_time = cluster->total_time;
        -:  603:            }
        -:  604:        }
        -:  605:    }
        -:  606:    
        -:  607:    // Determine severity
      175:  608:    if (max_cluster_size < 3) {
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
       16:  609:        g_analyzer->current_severity = N_PLUS_ONE_NONE;
       16:  610:        g_analyzer->estimated_cause = 0;
       16:  611:        strcpy(g_analyzer->optimization_suggestion, "No N+1 patterns detected");
      159:  612:    } else if (max_cluster_size < 8) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
       18:  613:        g_analyzer->current_severity = N_PLUS_ONE_MILD;
       18:  614:        g_analyzer->estimated_cause = 1;
       18:  615:        strcpy(g_analyzer->optimization_suggestion, "Minor duplication detected - review serializer methods");
      141:  616:    } else if (max_cluster_size < N_PLUS_ONE_THRESHOLD) {
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
       12:  617:        g_analyzer->current_severity = N_PLUS_ONE_MODERATE;
       12:  618:        g_analyzer->estimated_cause = 2;
       12:  619:        strcpy(g_analyzer->optimization_suggestion, "Use select_related() for foreign key access");
      129:  620:    } else if (max_cluster_size < 25) {
branch  0 taken 29% (fallthrough)
branch  1 taken 71%
       37:  621:        g_analyzer->current_severity = N_PLUS_ONE_HIGH;
       37:  622:        g_analyzer->estimated_cause = 3;
       37:  623:        strcpy(g_analyzer->optimization_suggestion, "Add prefetch_related() for reverse foreign keys");
       92:  624:    } else if (max_cluster_size < 50) {
branch  0 taken 45% (fallthrough)
branch  1 taken 55%
       41:  625:        g_analyzer->current_severity = N_PLUS_ONE_SEVERE;
       41:  626:        g_analyzer->estimated_cause = 4;
       41:  627:        strcpy(g_analyzer->optimization_suggestion, "Consider database denormalization or caching");
        -:  628:    } else {
       51:  629:        g_analyzer->current_severity = N_PLUS_ONE_CRITICAL;
       51:  630:        g_analyzer->estimated_cause = 4;
       51:  631:        strcpy(g_analyzer->optimization_suggestion, "Critical N+1 - immediate optimization required");
        -:  632:    }
        -:  633:    
      175:  634:    if (max_cluster_size >= 3) {
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
      159:  635:        g_analyzer->n_plus_one_patterns_detected++;
        -:  636:    }
        -:  637:}
------------------
update_n_plus_one_analysis:
function update_n_plus_one_analysis called 3117 returned 100% blocks executed 100%
     3117:  577:static void update_n_plus_one_analysis(void) {
     3117:  578:    if (!g_analyzer) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  579:        return;
        -:  580:    }
        -:  581:    
        -:  582:    // If no queries analyzed in current session, reset severity to NONE
     3117:  583:    uint64_t total_queries = g_analyzer->total_queries_analyzed;
     3117:  584:    if (total_queries == 0) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        2:  585:        g_analyzer->current_severity = N_PLUS_ONE_NONE;
        2:  586:        g_analyzer->estimated_cause = 0;
        2:  587:        strcpy(g_analyzer->optimization_suggestion, "No queries analyzed");
        2:  588:        return;
        -:  589:    }
        -:  590:    
        -:  591:    int max_cluster_size = 0;
        -:  592:    double max_cluster_time = 0.0;
        -:  593:    
        -:  594:    // Analyze all clusters (with bounds checking)
     8916:  595:    for (size_t i = 0; i < g_analyzer->cluster_count && i < g_analyzer->max_clusters; i++) {
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
     5801:  596:        QueryCluster* cluster = &g_analyzer->clusters[i];
     5801:  597:        if (cluster->query_count > 1) {
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
        -:  598:            if (cluster->query_count > max_cluster_size) {
        -:  599:                max_cluster_size = cluster->query_count;
        -:  600:            }
     5486:  601:            if (cluster->total_time > max_cluster_time) {
        -:  602:                max_cluster_time = cluster->total_time;
        -:  603:            }
        -:  604:        }
        -:  605:    }
        -:  606:    
        -:  607:    // Determine severity
     3115:  608:    if (max_cluster_size < 3) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
       43:  609:        g_analyzer->current_severity = N_PLUS_ONE_NONE;
       43:  610:        g_analyzer->estimated_cause = 0;
       43:  611:        strcpy(g_analyzer->optimization_suggestion, "No N+1 patterns detected");
     3072:  612:    } else if (max_cluster_size < 8) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
       68:  613:        g_analyzer->current_severity = N_PLUS_ONE_MILD;
       68:  614:        g_analyzer->estimated_cause = 1;
       68:  615:        strcpy(g_analyzer->optimization_suggestion, "Minor duplication detected - review serializer methods");
     3004:  616:    } else if (max_cluster_size < N_PLUS_ONE_THRESHOLD) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
       58:  617:        g_analyzer->current_severity = N_PLUS_ONE_MODERATE;
       58:  618:        g_analyzer->estimated_cause = 2;
       58:  619:        strcpy(g_analyzer->optimization_suggestion, "Use select_related() for foreign key access");
     2946:  620:    } else if (max_cluster_size < 25) {
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
      123:  621:        g_analyzer->current_severity = N_PLUS_ONE_HIGH;
      123:  622:        g_analyzer->estimated_cause = 3;
      123:  623:        strcpy(g_analyzer->optimization_suggestion, "Add prefetch_related() for reverse foreign keys");
     2823:  624:    } else if (max_cluster_size < 50) {
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
      195:  625:        g_analyzer->current_severity = N_PLUS_ONE_SEVERE;
      195:  626:        g_analyzer->estimated_cause = 4;
      195:  627:        strcpy(g_analyzer->optimization_suggestion, "Consider database denormalization or caching");
        -:  628:    } else {
     2628:  629:        g_analyzer->current_severity = N_PLUS_ONE_CRITICAL;
     2628:  630:        g_analyzer->estimated_cause = 4;
     2628:  631:        strcpy(g_analyzer->optimization_suggestion, "Critical N+1 - immediate optimization required");
        -:  632:    }
        -:  633:    
     3115:  634:    if (max_cluster_size >= 3) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
     3072:  635:        g_analyzer->n_plus_one_patterns_detected++;
        -:  636:    }
        -:  637:}
------------------
        -:  638:
        -:  639:// === PUBLIC API FUNCTIONS ===
        -:  640:
        -:  641:// Analyze a single query
     3279:  642:int analyze_query(const char* query_text, double execution_time) {
     3279:  643:    if (!query_text) {
       1*:  644:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Query text cannot be NULL");
       1*:  645:        return -1;
        -:  646:    }
        -:  647:    
        -:  648:    // Initialize analyzer if needed
     3278:  649:    if (!g_analyzer) {
        2:  650:        if (init_query_analyzer() != MERCURY_SUCCESS) {
    #####:  651:            MERCURY_ERROR("Failed to initialize query analyzer");
    #####:  652:            return -1;
        -:  653:        }
        -:  654:    }
        -:  655:    
        -:  656:    // Verify analyzer is in valid state
     3278:  657:    if (!g_analyzer->clusters || !g_analyzer->query_history) {
    #####:  658:        MERCURY_ERROR("Query analyzer in corrupted state");
    #####:  659:        return -1;
        -:  660:    }
        -:  661:    
     3278:  662:    g_analyzer->total_queries_analyzed++;
        -:  663:    
        -:  664:    // Normalize query for pattern matching
        -:  665:    char normalized[1024];
     3278:  666:    normalize_query(query_text, normalized, sizeof(normalized));
        -:  667:    
        -:  668:    // Calculate hash for similarity clustering
        -:  669:    uint64_t query_hash = mercury_hash_string(normalized);
        -:  670:    
        -:  671:    // Detect query type
     3278:  672:    SqlQueryType query_type = detect_query_type(query_text);
        -:  673:    
        -:  674:    // Create query record
     3278:  675:    MercuryQueryRecord record = {0};
     3278:  676:    record.query_text = pool_strdup(query_text);
     3278:  677:    if (!record.query_text) {
    #####:  678:        MERCURY_ERROR("Failed to allocate memory for query text (pool exhausted?)");
    #####:  679:        return -1;
        -:  680:    }
     3278:  681:    record.hash = query_hash;
     3278:  682:    record.execution_time = execution_time;
     3278:  683:    record.timestamp = mercury_get_timestamp();
     3278:  684:    record.similarity_score = 0;
     3278:  685:    record.query_type = query_type;
     3278:  686:    record.flags = 0;
        -:  687:    
        -:  688:    // Add to history buffer (thread-safe)
     3278:  689:    pthread_mutex_lock(&g_analyzer->history_mutex);
     3278:  690:    if (!mercury_ring_buffer_push(g_analyzer->query_history, &record)) {
        -:  691:        // Buffer full - remove oldest entry
        -:  692:        MercuryQueryRecord old_record;
    1000*:  693:        if (mercury_ring_buffer_pop(g_analyzer->query_history, &old_record)) {
    1000*:  694:            pool_strfree(old_record.query_text);  // Cleanup old query text
        -:  695:        }
    1000*:  696:        mercury_ring_buffer_push(g_analyzer->query_history, &record);
        -:  697:    }
     3278:  698:    pthread_mutex_unlock(&g_analyzer->history_mutex);
        -:  699:    
        -:  700:    // Update or create cluster using thread-safe function
     3278:  701:    QueryCluster* cluster = find_or_create_cluster(query_hash, normalized);
        -:  702:    
        -:  703:    // Update cluster stats if cluster creation succeeded
     3278:  704:    if (cluster) {
        -:  705:        // Note: We need to acquire the mutex again for stats update
     3278:  706:        pthread_mutex_lock(&g_analyzer->cluster_mutex);
        -:  707:        
        -:  708:        // Verify cluster is still valid (could have been evicted)
        -:  709:        bool cluster_valid = false;
     4806:  710:        for (size_t i = 0; i < g_analyzer->cluster_count && i < g_analyzer->max_clusters; i++) {
     4806:  711:            if (&g_analyzer->clusters[i] == cluster) {
        -:  712:                cluster_valid = true;
        -:  713:                break;
        -:  714:            }
        -:  715:        }
        -:  716:        
     3278:  717:        if (cluster_valid) {
     3278:  718:            cluster->query_count++;
     3278:  719:            cluster->total_time += execution_time;
     3278:  720:            cluster->avg_time = cluster->total_time / cluster->query_count;
     3278:  721:            cluster->last_seen = record.timestamp;
        -:  722:            
     3278:  723:            if (cluster->query_count > 1) {
     3225:  724:                g_analyzer->similar_queries_found++;
        -:  725:            }
        -:  726:            
        -:  727:            // Update N+1 analysis (while holding mutex)
     3278:  728:            update_n_plus_one_analysis();
        -:  729:        }
        -:  730:        
     3278:  731:        pthread_mutex_unlock(&g_analyzer->cluster_mutex);
        -:  732:    }
        -:  733:    
        -:  734:    return 0;  // Success
        -:  735:}
------------------
analyze_query:
function analyze_query called 173 returned 100% blocks executed 65%
      173:  642:int analyze_query(const char* query_text, double execution_time) {
      173:  643:    if (!query_text) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  644:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Query text cannot be NULL");
    #####:  645:        return -1;
        -:  646:    }
        -:  647:    
        -:  648:    // Initialize analyzer if needed
      173:  649:    if (!g_analyzer) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        1:  650:        if (init_query_analyzer() != MERCURY_SUCCESS) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  651:            MERCURY_ERROR("Failed to initialize query analyzer");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  652:            return -1;
        -:  653:        }
        -:  654:    }
        -:  655:    
        -:  656:    // Verify analyzer is in valid state
      173:  657:    if (!g_analyzer->clusters || !g_analyzer->query_history) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  658:        MERCURY_ERROR("Query analyzer in corrupted state");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  659:        return -1;
        -:  660:    }
        -:  661:    
      173:  662:    g_analyzer->total_queries_analyzed++;
        -:  663:    
        -:  664:    // Normalize query for pattern matching
        -:  665:    char normalized[1024];
      173:  666:    normalize_query(query_text, normalized, sizeof(normalized));
call    0 returned 100%
        -:  667:    
        -:  668:    // Calculate hash for similarity clustering
        -:  669:    uint64_t query_hash = mercury_hash_string(normalized);
        -:  670:    
        -:  671:    // Detect query type
      173:  672:    SqlQueryType query_type = detect_query_type(query_text);
call    0 returned 100%
        -:  673:    
        -:  674:    // Create query record
      173:  675:    MercuryQueryRecord record = {0};
      173:  676:    record.query_text = pool_strdup(query_text);
call    0 returned 100%
      173:  677:    if (!record.query_text) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  678:        MERCURY_ERROR("Failed to allocate memory for query text (pool exhausted?)");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  679:        return -1;
        -:  680:    }
      173:  681:    record.hash = query_hash;
      173:  682:    record.execution_time = execution_time;
      173:  683:    record.timestamp = mercury_get_timestamp();
call    0 returned 100%
      173:  684:    record.similarity_score = 0;
      173:  685:    record.query_type = query_type;
      173:  686:    record.flags = 0;
        -:  687:    
        -:  688:    // Add to history buffer (thread-safe)
      173:  689:    pthread_mutex_lock(&g_analyzer->history_mutex);
call    0 returned 100%
      173:  690:    if (!mercury_ring_buffer_push(g_analyzer->query_history, &record)) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  691:        // Buffer full - remove oldest entry
        -:  692:        MercuryQueryRecord old_record;
    #####:  693:        if (mercury_ring_buffer_pop(g_analyzer->query_history, &old_record)) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  694:            pool_strfree(old_record.query_text);  // Cleanup old query text
branch  0 never executed
branch  1 never executed
        -:  695:        }
    #####:  696:        mercury_ring_buffer_push(g_analyzer->query_history, &record);
call    0 never executed
        -:  697:    }
      173:  698:    pthread_mutex_unlock(&g_analyzer->history_mutex);
call    0 returned 100%
        -:  699:    
        -:  700:    // Update or create cluster using thread-safe function
      173:  701:    QueryCluster* cluster = find_or_create_cluster(query_hash, normalized);
call    0 returned 100%
        -:  702:    
        -:  703:    // Update cluster stats if cluster creation succeeded
      173:  704:    if (cluster) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  705:        // Note: We need to acquire the mutex again for stats update
      173:  706:        pthread_mutex_lock(&g_analyzer->cluster_mutex);
call    0 returned 100%
        -:  707:        
        -:  708:        // Verify cluster is still valid (could have been evicted)
        -:  709:        bool cluster_valid = false;
      202:  710:        for (size_t i = 0; i < g_analyzer->cluster_count && i < g_analyzer->max_clusters; i++) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
      202:  711:            if (&g_analyzer->clusters[i] == cluster) {
branch  0 taken 14% (fallthrough)
branch  1 taken 86%
        -:  712:                cluster_valid = true;
        -:  713:                break;
        -:  714:            }
        -:  715:        }
        -:  716:        
      173:  717:        if (cluster_valid) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      173:  718:            cluster->query_count++;
      173:  719:            cluster->total_time += execution_time;
      173:  720:            cluster->avg_time = cluster->total_time / cluster->query_count;
      173:  721:            cluster->last_seen = record.timestamp;
        -:  722:            
      173:  723:            if (cluster->query_count > 1) {
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
      161:  724:                g_analyzer->similar_queries_found++;
        -:  725:            }
        -:  726:            
        -:  727:            // Update N+1 analysis (while holding mutex)
      173:  728:            update_n_plus_one_analysis();
call    0 returned 100%
        -:  729:        }
        -:  730:        
      173:  731:        pthread_mutex_unlock(&g_analyzer->cluster_mutex);
call    0 returned 100%
        -:  732:    }
        -:  733:    
        -:  734:    return 0;  // Success
        -:  735:}
------------------
analyze_query:
function analyze_query called 3106 returned 100% blocks executed 82%
     3106:  642:int analyze_query(const char* query_text, double execution_time) {
     3106:  643:    if (!query_text) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        1:  644:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Query text cannot be NULL");
        1:  645:        return -1;
        -:  646:    }
        -:  647:    
        -:  648:    // Initialize analyzer if needed
     3105:  649:    if (!g_analyzer) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        1:  650:        if (init_query_analyzer() != MERCURY_SUCCESS) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  651:            MERCURY_ERROR("Failed to initialize query analyzer");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  652:            return -1;
        -:  653:        }
        -:  654:    }
        -:  655:    
        -:  656:    // Verify analyzer is in valid state
     3105:  657:    if (!g_analyzer->clusters || !g_analyzer->query_history) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  658:        MERCURY_ERROR("Query analyzer in corrupted state");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  659:        return -1;
        -:  660:    }
        -:  661:    
     3105:  662:    g_analyzer->total_queries_analyzed++;
        -:  663:    
        -:  664:    // Normalize query for pattern matching
        -:  665:    char normalized[1024];
     3105:  666:    normalize_query(query_text, normalized, sizeof(normalized));
call    0 returned 100%
        -:  667:    
        -:  668:    // Calculate hash for similarity clustering
        -:  669:    uint64_t query_hash = mercury_hash_string(normalized);
        -:  670:    
        -:  671:    // Detect query type
     3105:  672:    SqlQueryType query_type = detect_query_type(query_text);
call    0 returned 100%
        -:  673:    
        -:  674:    // Create query record
     3105:  675:    MercuryQueryRecord record = {0};
     3105:  676:    record.query_text = pool_strdup(query_text);
call    0 returned 100%
     3105:  677:    if (!record.query_text) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  678:        MERCURY_ERROR("Failed to allocate memory for query text (pool exhausted?)");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  679:        return -1;
        -:  680:    }
     3105:  681:    record.hash = query_hash;
     3105:  682:    record.execution_time = execution_time;
     3105:  683:    record.timestamp = mercury_get_timestamp();
call    0 returned 100%
     3105:  684:    record.similarity_score = 0;
     3105:  685:    record.query_type = query_type;
     3105:  686:    record.flags = 0;
        -:  687:    
        -:  688:    // Add to history buffer (thread-safe)
     3105:  689:    pthread_mutex_lock(&g_analyzer->history_mutex);
call    0 returned 100%
     3105:  690:    if (!mercury_ring_buffer_push(g_analyzer->query_history, &record)) {
call    0 returned 100%
branch  1 taken 32% (fallthrough)
branch  2 taken 68%
        -:  691:        // Buffer full - remove oldest entry
        -:  692:        MercuryQueryRecord old_record;
     1000:  693:        if (mercury_ring_buffer_pop(g_analyzer->query_history, &old_record)) {
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
     1000:  694:            pool_strfree(old_record.query_text);  // Cleanup old query text
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  695:        }
     1000:  696:        mercury_ring_buffer_push(g_analyzer->query_history, &record);
call    0 returned 100%
        -:  697:    }
     3105:  698:    pthread_mutex_unlock(&g_analyzer->history_mutex);
call    0 returned 100%
        -:  699:    
        -:  700:    // Update or create cluster using thread-safe function
     3105:  701:    QueryCluster* cluster = find_or_create_cluster(query_hash, normalized);
call    0 returned 100%
        -:  702:    
        -:  703:    // Update cluster stats if cluster creation succeeded
     3105:  704:    if (cluster) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  705:        // Note: We need to acquire the mutex again for stats update
     3105:  706:        pthread_mutex_lock(&g_analyzer->cluster_mutex);
call    0 returned 100%
        -:  707:        
        -:  708:        // Verify cluster is still valid (could have been evicted)
        -:  709:        bool cluster_valid = false;
     4604:  710:        for (size_t i = 0; i < g_analyzer->cluster_count && i < g_analyzer->max_clusters; i++) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
     4604:  711:            if (&g_analyzer->clusters[i] == cluster) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:  712:                cluster_valid = true;
        -:  713:                break;
        -:  714:            }
        -:  715:        }
        -:  716:        
     3105:  717:        if (cluster_valid) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     3105:  718:            cluster->query_count++;
     3105:  719:            cluster->total_time += execution_time;
     3105:  720:            cluster->avg_time = cluster->total_time / cluster->query_count;
     3105:  721:            cluster->last_seen = record.timestamp;
        -:  722:            
     3105:  723:            if (cluster->query_count > 1) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
     3064:  724:                g_analyzer->similar_queries_found++;
        -:  725:            }
        -:  726:            
        -:  727:            // Update N+1 analysis (while holding mutex)
     3105:  728:            update_n_plus_one_analysis();
call    0 returned 100%
        -:  729:        }
        -:  730:        
     3105:  731:        pthread_mutex_unlock(&g_analyzer->cluster_mutex);
call    0 returned 100%
        -:  732:    }
        -:  733:    
        -:  734:    return 0;  // Success
        -:  735:}
------------------
        -:  736:
        -:  737:// Get duplicate query groups
        5:  738:int get_duplicate_queries(char* result_buffer, size_t buffer_size) {
        5:  739:    if (!result_buffer || buffer_size == 0) {
       2*:  740:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid result buffer");
       2*:  741:        return -1;
        -:  742:    }
        -:  743:    
        3:  744:    if (!g_analyzer) {
    #####:  745:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Query analyzer not initialized");
    #####:  746:        return -1;
        -:  747:    }
        -:  748:    
        3:  749:    MercuryString* result = mercury_string_create(buffer_size);
        3:  750:    if (!result) {
        -:  751:        return -1;
        -:  752:    }
        -:  753:    
        -:  754:    int duplicate_groups = 0;
        -:  755:    
        -:  756:    // Find clusters with duplicates (with bounds checking)
       10:  757:    for (size_t i = 0; i < g_analyzer->cluster_count && i < g_analyzer->max_clusters; i++) {
        7:  758:        QueryCluster* cluster = &g_analyzer->clusters[i];
        7:  759:        if (cluster->query_count > 1) {
        -:  760:            char cluster_info[256];
        3:  761:            snprintf(cluster_info, sizeof(cluster_info), 
        -:  762:                    "Cluster %zu: %d queries, avg time %.2fms - %s\n",
        -:  763:                    i, cluster->query_count, cluster->avg_time, 
        3:  764:                    cluster->representative_query);
        -:  765:            
        3:  766:            if (mercury_string_append(result, cluster_info) != MERCURY_SUCCESS) {
    #####:  767:                mercury_string_destroy(result);
    #####:  768:                return -1;
        -:  769:            }
        -:  770:            
        3:  771:            duplicate_groups++;
        -:  772:        }
        -:  773:    }
        -:  774:    
        -:  775:    // Copy result to buffer
        3:  776:    const char* result_str = mercury_string_cstr(result);
        3:  777:    strncpy(result_buffer, result_str, buffer_size - 1);
        3:  778:    result_buffer[buffer_size - 1] = '\0';
        -:  779:    
        3:  780:    mercury_string_destroy(result);
        3:  781:    return duplicate_groups;
        -:  782:}
------------------
get_duplicate_queries:
function get_duplicate_queries called 1 returned 100% blocks executed 79%
        1:  738:int get_duplicate_queries(char* result_buffer, size_t buffer_size) {
        1:  739:    if (!result_buffer || buffer_size == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  740:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid result buffer");
    #####:  741:        return -1;
        -:  742:    }
        -:  743:    
        1:  744:    if (!g_analyzer) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  745:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Query analyzer not initialized");
    #####:  746:        return -1;
        -:  747:    }
        -:  748:    
        1:  749:    MercuryString* result = mercury_string_create(buffer_size);
call    0 returned 100%
        1:  750:    if (!result) {
branch  0 taken 100%
branch  1 taken 0%
        -:  751:        return -1;
        -:  752:    }
        -:  753:    
        -:  754:    int duplicate_groups = 0;
        -:  755:    
        -:  756:    // Find clusters with duplicates (with bounds checking)
        2:  757:    for (size_t i = 0; i < g_analyzer->cluster_count && i < g_analyzer->max_clusters; i++) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
        1:  758:        QueryCluster* cluster = &g_analyzer->clusters[i];
        1:  759:        if (cluster->query_count > 1) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  760:            char cluster_info[256];
        1:  761:            snprintf(cluster_info, sizeof(cluster_info), 
        -:  762:                    "Cluster %zu: %d queries, avg time %.2fms - %s\n",
        -:  763:                    i, cluster->query_count, cluster->avg_time, 
        1:  764:                    cluster->representative_query);
call    0 returned 100%
        -:  765:            
        1:  766:            if (mercury_string_append(result, cluster_info) != MERCURY_SUCCESS) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  767:                mercury_string_destroy(result);
call    0 never executed
    #####:  768:                return -1;
        -:  769:            }
        -:  770:            
        1:  771:            duplicate_groups++;
        -:  772:        }
        -:  773:    }
        -:  774:    
        -:  775:    // Copy result to buffer
        1:  776:    const char* result_str = mercury_string_cstr(result);
call    0 returned 100%
        1:  777:    strncpy(result_buffer, result_str, buffer_size - 1);
call    0 returned 100%
        1:  778:    result_buffer[buffer_size - 1] = '\0';
        -:  779:    
        1:  780:    mercury_string_destroy(result);
call    0 returned 100%
        1:  781:    return duplicate_groups;
        -:  782:}
------------------
get_duplicate_queries:
function get_duplicate_queries called 4 returned 100% blocks executed 84%
        4:  738:int get_duplicate_queries(char* result_buffer, size_t buffer_size) {
        4:  739:    if (!result_buffer || buffer_size == 0) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        2:  740:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid result buffer");
        2:  741:        return -1;
        -:  742:    }
        -:  743:    
        2:  744:    if (!g_analyzer) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  745:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Query analyzer not initialized");
    #####:  746:        return -1;
        -:  747:    }
        -:  748:    
        2:  749:    MercuryString* result = mercury_string_create(buffer_size);
call    0 returned 100%
        2:  750:    if (!result) {
branch  0 taken 100%
branch  1 taken 0%
        -:  751:        return -1;
        -:  752:    }
        -:  753:    
        -:  754:    int duplicate_groups = 0;
        -:  755:    
        -:  756:    // Find clusters with duplicates (with bounds checking)
        8:  757:    for (size_t i = 0; i < g_analyzer->cluster_count && i < g_analyzer->max_clusters; i++) {
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
branch  2 taken 100%
branch  3 taken 0% (fallthrough)
        6:  758:        QueryCluster* cluster = &g_analyzer->clusters[i];
        6:  759:        if (cluster->query_count > 1) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:  760:            char cluster_info[256];
        2:  761:            snprintf(cluster_info, sizeof(cluster_info), 
        -:  762:                    "Cluster %zu: %d queries, avg time %.2fms - %s\n",
        -:  763:                    i, cluster->query_count, cluster->avg_time, 
        2:  764:                    cluster->representative_query);
call    0 returned 100%
        -:  765:            
        2:  766:            if (mercury_string_append(result, cluster_info) != MERCURY_SUCCESS) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  767:                mercury_string_destroy(result);
call    0 never executed
    #####:  768:                return -1;
        -:  769:            }
        -:  770:            
        2:  771:            duplicate_groups++;
        -:  772:        }
        -:  773:    }
        -:  774:    
        -:  775:    // Copy result to buffer
        2:  776:    const char* result_str = mercury_string_cstr(result);
call    0 returned 100%
        2:  777:    strncpy(result_buffer, result_str, buffer_size - 1);
call    0 returned 100%
        2:  778:    result_buffer[buffer_size - 1] = '\0';
        -:  779:    
        2:  780:    mercury_string_destroy(result);
call    0 returned 100%
        2:  781:    return duplicate_groups;
        -:  782:}
------------------
        -:  783:
        -:  784:// Detect N+1 patterns
        9:  785:int detect_n_plus_one_patterns(void) {
        9:  786:    if (!g_analyzer) {
        -:  787:        return 0;
        -:  788:    }
        -:  789:    
        -:  790:    // Update analysis to ensure current state
        7:  791:    update_n_plus_one_analysis();
        -:  792:    
        7:  793:    return (g_analyzer->current_severity > N_PLUS_ONE_NONE) ? 1 : 0;
        -:  794:}
------------------
detect_n_plus_one_patterns:
function detect_n_plus_one_patterns called 2 returned 100% blocks executed 100%
        2:  785:int detect_n_plus_one_patterns(void) {
        2:  786:    if (!g_analyzer) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  787:        return 0;
        -:  788:    }
        -:  789:    
        -:  790:    // Update analysis to ensure current state
        1:  791:    update_n_plus_one_analysis();
call    0 returned 100%
        -:  792:    
        1:  793:    return (g_analyzer->current_severity > N_PLUS_ONE_NONE) ? 1 : 0;
        -:  794:}
------------------
detect_n_plus_one_patterns:
function detect_n_plus_one_patterns called 7 returned 100% blocks executed 100%
        7:  785:int detect_n_plus_one_patterns(void) {
        7:  786:    if (!g_analyzer) {
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
        -:  787:        return 0;
        -:  788:    }
        -:  789:    
        -:  790:    // Update analysis to ensure current state
        6:  791:    update_n_plus_one_analysis();
call    0 returned 100%
        -:  792:    
        6:  793:    return (g_analyzer->current_severity > N_PLUS_ONE_NONE) ? 1 : 0;
        -:  794:}
------------------
        -:  795:
        -:  796:// Get N+1 severity level
        9:  797:int get_n_plus_one_severity(void) {
        9:  798:    if (!g_analyzer) {
        -:  799:        return 0;
        -:  800:    }
        -:  801:    
        -:  802:    // Update analysis to ensure current state  
        7:  803:    update_n_plus_one_analysis();
        -:  804:    
        7:  805:    return (int)g_analyzer->current_severity;
        -:  806:}
------------------
get_n_plus_one_severity:
function get_n_plus_one_severity called 2 returned 100% blocks executed 100%
        2:  797:int get_n_plus_one_severity(void) {
        2:  798:    if (!g_analyzer) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  799:        return 0;
        -:  800:    }
        -:  801:    
        -:  802:    // Update analysis to ensure current state  
        1:  803:    update_n_plus_one_analysis();
call    0 returned 100%
        -:  804:    
        1:  805:    return (int)g_analyzer->current_severity;
        -:  806:}
------------------
get_n_plus_one_severity:
function get_n_plus_one_severity called 7 returned 100% blocks executed 100%
        7:  797:int get_n_plus_one_severity(void) {
        7:  798:    if (!g_analyzer) {
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
        -:  799:        return 0;
        -:  800:    }
        -:  801:    
        -:  802:    // Update analysis to ensure current state  
        6:  803:    update_n_plus_one_analysis();
call    0 returned 100%
        -:  804:    
        6:  805:    return (int)g_analyzer->current_severity;
        -:  806:}
------------------
        -:  807:
        -:  808:// Get estimated cause of N+1 issue
        8:  809:int get_n_plus_one_cause(void) {
        8:  810:    if (!g_analyzer) {
        -:  811:        return 0;
        -:  812:    }
        -:  813:    
       6*:  814:    return g_analyzer->estimated_cause;
        -:  815:}
------------------
get_n_plus_one_cause:
function get_n_plus_one_cause called 1 returned 100% blocks executed 67%
        1:  809:int get_n_plus_one_cause(void) {
        1:  810:    if (!g_analyzer) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  811:        return 0;
        -:  812:    }
        -:  813:    
    #####:  814:    return g_analyzer->estimated_cause;
        -:  815:}
------------------
get_n_plus_one_cause:
function get_n_plus_one_cause called 7 returned 100% blocks executed 100%
        7:  809:int get_n_plus_one_cause(void) {
        7:  810:    if (!g_analyzer) {
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
        -:  811:        return 0;
        -:  812:    }
        -:  813:    
        6:  814:    return g_analyzer->estimated_cause;
        -:  815:}
------------------
        -:  816:
        -:  817:// Get optimization suggestion
        9:  818:const char* get_optimization_suggestion(void) {
        9:  819:    if (!g_analyzer) {
        -:  820:        return "Query analyzer not initialized";
        -:  821:    }
        -:  822:    
        7:  823:    return g_analyzer->optimization_suggestion;
        -:  824:}
------------------
get_optimization_suggestion:
function get_optimization_suggestion called 2 returned 100% blocks executed 100%
        2:  818:const char* get_optimization_suggestion(void) {
        2:  819:    if (!g_analyzer) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  820:        return "Query analyzer not initialized";
        -:  821:    }
        -:  822:    
        1:  823:    return g_analyzer->optimization_suggestion;
        -:  824:}
------------------
get_optimization_suggestion:
function get_optimization_suggestion called 7 returned 100% blocks executed 100%
        7:  818:const char* get_optimization_suggestion(void) {
        7:  819:    if (!g_analyzer) {
branch  0 taken 86% (fallthrough)
branch  1 taken 14%
        -:  820:        return "Query analyzer not initialized";
        -:  821:    }
        -:  822:    
        6:  823:    return g_analyzer->optimization_suggestion;
        -:  824:}
------------------
        -:  825:
        -:  826:// Get query analysis statistics
       54:  827:void get_query_statistics(uint64_t* total_queries, uint64_t* n_plus_one_detected, 
        -:  828:                         uint64_t* similar_queries, int* active_clusters) {
       54:  829:    if (!g_analyzer) {
        2:  830:        if (total_queries) *total_queries = 0;
        2:  831:        if (n_plus_one_detected) *n_plus_one_detected = 0;
        2:  832:        if (similar_queries) *similar_queries = 0;
        2:  833:        if (active_clusters) *active_clusters = 0;
        2:  834:        return;
        -:  835:    }
        -:  836:    
       52:  837:    if (total_queries) *total_queries = g_analyzer->total_queries_analyzed;
       52:  838:    if (n_plus_one_detected) *n_plus_one_detected = g_analyzer->n_plus_one_patterns_detected;
       52:  839:    if (similar_queries) *similar_queries = g_analyzer->similar_queries_found;
       52:  840:    if (active_clusters) *active_clusters = (int)g_analyzer->cluster_count;
        -:  841:}
------------------
get_query_statistics:
function get_query_statistics called 6 returned 100% blocks executed 100%
        6:  827:void get_query_statistics(uint64_t* total_queries, uint64_t* n_plus_one_detected, 
        -:  828:                         uint64_t* similar_queries, int* active_clusters) {
        6:  829:    if (!g_analyzer) {
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        1:  830:        if (total_queries) *total_queries = 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  831:        if (n_plus_one_detected) *n_plus_one_detected = 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  832:        if (similar_queries) *similar_queries = 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  833:        if (active_clusters) *active_clusters = 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  834:        return;
        -:  835:    }
        -:  836:    
        5:  837:    if (total_queries) *total_queries = g_analyzer->total_queries_analyzed;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        5:  838:    if (n_plus_one_detected) *n_plus_one_detected = g_analyzer->n_plus_one_patterns_detected;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        5:  839:    if (similar_queries) *similar_queries = g_analyzer->similar_queries_found;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        5:  840:    if (active_clusters) *active_clusters = (int)g_analyzer->cluster_count;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  841:}
------------------
get_query_statistics:
function get_query_statistics called 48 returned 100% blocks executed 100%
       48:  827:void get_query_statistics(uint64_t* total_queries, uint64_t* n_plus_one_detected, 
        -:  828:                         uint64_t* similar_queries, int* active_clusters) {
       48:  829:    if (!g_analyzer) {
branch  0 taken 2% (fallthrough)
branch  1 taken 98%
        1:  830:        if (total_queries) *total_queries = 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  831:        if (n_plus_one_detected) *n_plus_one_detected = 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  832:        if (similar_queries) *similar_queries = 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  833:        if (active_clusters) *active_clusters = 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  834:        return;
        -:  835:    }
        -:  836:    
       47:  837:    if (total_queries) *total_queries = g_analyzer->total_queries_analyzed;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       47:  838:    if (n_plus_one_detected) *n_plus_one_detected = g_analyzer->n_plus_one_patterns_detected;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       47:  839:    if (similar_queries) *similar_queries = g_analyzer->similar_queries_found;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       47:  840:    if (active_clusters) *active_clusters = (int)g_analyzer->cluster_count;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  841:}
------------------
        -:  842:
        -:  843:// Reset query analyzer state
       27:  844:void reset_query_analyzer(void) {
       27:  845:    if (!g_analyzer) {
        4:  846:        return;
        -:  847:    }
        -:  848:    
        -:  849:    // Clear ring buffer
        -:  850:    MercuryQueryRecord record;
     2301:  851:    while (mercury_ring_buffer_pop(g_analyzer->query_history, &record)) {
     2278:  852:        pool_strfree(record.query_text);
        -:  853:    }
        -:  854:    
        -:  855:    // Reset clusters
       23:  856:    g_analyzer->cluster_count = 0;
        -:  857:    
        -:  858:    // Reset statistics
       23:  859:    g_analyzer->total_queries_analyzed = 0;
       23:  860:    g_analyzer->n_plus_one_patterns_detected = 0;
       23:  861:    g_analyzer->similar_queries_found = 0;
        -:  862:    
       23:  863:    g_analyzer->current_severity = N_PLUS_ONE_NONE;
       23:  864:    g_analyzer->estimated_cause = 0;
       23:  865:    strcpy(g_analyzer->optimization_suggestion, "No optimization needed");
        -:  866:    
        -:  867:    // MERCURY_INFO("Query analyzer state reset");  // Too verbose for normal operation
        -:  868:}
------------------
reset_query_analyzer:
function reset_query_analyzer called 8 returned 100% blocks executed 100%
        8:  844:void reset_query_analyzer(void) {
        8:  845:    if (!g_analyzer) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        2:  846:        return;
        -:  847:    }
        -:  848:    
        -:  849:    // Clear ring buffer
        -:  850:    MercuryQueryRecord record;
      179:  851:    while (mercury_ring_buffer_pop(g_analyzer->query_history, &record)) {
call    0 returned 100%
branch  1 taken 97%
branch  2 taken 3% (fallthrough)
      173:  852:        pool_strfree(record.query_text);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  853:    }
        -:  854:    
        -:  855:    // Reset clusters
        6:  856:    g_analyzer->cluster_count = 0;
        -:  857:    
        -:  858:    // Reset statistics
        6:  859:    g_analyzer->total_queries_analyzed = 0;
        6:  860:    g_analyzer->n_plus_one_patterns_detected = 0;
        6:  861:    g_analyzer->similar_queries_found = 0;
        -:  862:    
        6:  863:    g_analyzer->current_severity = N_PLUS_ONE_NONE;
        6:  864:    g_analyzer->estimated_cause = 0;
        6:  865:    strcpy(g_analyzer->optimization_suggestion, "No optimization needed");
        -:  866:    
        -:  867:    // MERCURY_INFO("Query analyzer state reset");  // Too verbose for normal operation
        -:  868:}
------------------
reset_query_analyzer:
function reset_query_analyzer called 19 returned 100% blocks executed 100%
       19:  844:void reset_query_analyzer(void) {
       19:  845:    if (!g_analyzer) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        2:  846:        return;
        -:  847:    }
        -:  848:    
        -:  849:    // Clear ring buffer
        -:  850:    MercuryQueryRecord record;
     2122:  851:    while (mercury_ring_buffer_pop(g_analyzer->query_history, &record)) {
call    0 returned 100%
branch  1 taken 99%
branch  2 taken 1% (fallthrough)
     2105:  852:        pool_strfree(record.query_text);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  853:    }
        -:  854:    
        -:  855:    // Reset clusters
       17:  856:    g_analyzer->cluster_count = 0;
        -:  857:    
        -:  858:    // Reset statistics
       17:  859:    g_analyzer->total_queries_analyzed = 0;
       17:  860:    g_analyzer->n_plus_one_patterns_detected = 0;
       17:  861:    g_analyzer->similar_queries_found = 0;
        -:  862:    
       17:  863:    g_analyzer->current_severity = N_PLUS_ONE_NONE;
       17:  864:    g_analyzer->estimated_cause = 0;
       17:  865:    strcpy(g_analyzer->optimization_suggestion, "No optimization needed");
        -:  866:    
        -:  867:    // MERCURY_INFO("Query analyzer state reset");  // Too verbose for normal operation
        -:  868:}
------------------
        -:  869:
        -:  870:// === LIBRARY INITIALIZATION ===
        -:  871:
        -:  872:// Library constructor (called when .so is loaded)
        -:  873:MERCURY_CONSTRUCTOR(query_analyzer_init) {
        -:  874:    // MERCURY_INFO("libquery_analyzer.so loaded");  // Too verbose
        -:  875:}
        -:  876:
        -:  877:// Library destructor (called when .so is unloaded)
        2:  878:MERCURY_DESTRUCTOR(query_analyzer_cleanup) {
        2:  879:    cleanup_query_analyzer();
        -:  880:    // MERCURY_INFO("libquery_analyzer.so unloaded");  // Too verbose
        2:  881:}
------------------
query_analyzer_cleanup:
function query_analyzer_cleanup called 1 returned 100% blocks executed 100%
        1:  878:MERCURY_DESTRUCTOR(query_analyzer_cleanup) {
        1:  879:    cleanup_query_analyzer();
call    0 returned 100%
        -:  880:    // MERCURY_INFO("libquery_analyzer.so unloaded");  // Too verbose
        1:  881:}
------------------
query_analyzer_cleanup:
function query_analyzer_cleanup called 1 returned 100% blocks executed 100%
        1:  878:MERCURY_DESTRUCTOR(query_analyzer_cleanup) {
        1:  879:    cleanup_query_analyzer();
call    0 returned 100%
        -:  880:    // MERCURY_INFO("libquery_analyzer.so unloaded");  // Too verbose
        1:  881:}
------------------

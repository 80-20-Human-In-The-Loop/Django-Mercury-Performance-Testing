        -:    0:Source:common.c
        -:    0:Source is newer than graph
        -:    1:/*
        -:    2: * common.c - Implementation of shared utilities for Mercury Performance Testing Framework
        -:    3: * 
        -:    4: * This file implements the common data structures and utility functions declared in common.h.
        -:    5: * It provides cross-platform compatibility and high-performance implementations for:
        -:    6: * - Memory management and ring buffers
        -:    7: * - String operations and Boyer-Moore pattern matching
        -:    8: * - Timing utilities and RDTSC calibration
        -:    9: * - SIMD-accelerated operations
        -:   10: * - Error handling and logging
        -:   11: *
        -:   12: * Author: EduLite Performance Team
        -:   13: * Version: 2.0.0
        -:   14: */
        -:   15:
        -:   16:/* Define feature test macros BEFORE any includes */
        -:   17:#ifndef _GNU_SOURCE
        -:   18:#define _GNU_SOURCE
        -:   19:#endif
        -:   20:#ifndef _POSIX_C_SOURCE
        -:   21:#define _POSIX_C_SOURCE 200809L
        -:   22:#endif
        -:   23:
        -:   24:#include "common.h"
        -:   25:#include <assert.h>
        -:   26:#include <stdarg.h>
        -:   27:
        -:   28:#ifdef MERCURY_LINUX
        -:   29:#include <time.h>
        -:   30:#endif
        -:   31:
        -:   32:// === GLOBAL VARIABLES ===
        -:   33:
        -:   34:// RDTSC frequency for timing calibration
        -:   35:#ifdef MERCURY_X86_64
        -:   36:uint64_t mercury_rdtsc_frequency = 0;
        -:   37:#endif
        -:   38:
        -:   39:// Thread-local error context
        -:   40:#ifdef __STDC_NO_THREADS__
        -:   41:    MercuryErrorContext mercury_last_error = {MERCURY_SUCCESS, {0}, NULL, NULL, 0};
        -:   42:#else
        -:   43:    _Thread_local MercuryErrorContext mercury_last_error = {MERCURY_SUCCESS, {0}, NULL, NULL, 0};
        -:   44:#endif
        -:   45:
        -:   46:// Default logger function pointer
        -:   47:void (*mercury_log_function)(MercuryLogLevel level, const char* format, ...) = mercury_default_logger;
        -:   48:
        -:   49:// === TIMING UTILITIES ===
        -:   50:
        -:   51:#ifdef MERCURY_X86_64
      29*:   52:void mercury_calibrate_rdtsc(void) {
      29*:   53:    if (mercury_rdtsc_frequency != 0) {
       4*:   54:        return;  // Already calibrated
        -:   55:    }
        -:   56:    
        -:   57:    // Calibrate RDTSC against system clock
        -:   58:    MercuryTimestamp start_sys = mercury_get_timestamp();
        -:   59:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   60:    
        -:   61:    // Wait approximately 100ms
        -:   62:    #ifdef MERCURY_LINUX
      25*:   63:        struct timespec sleep_time = {0, 100000000};  // 100ms
      25*:   64:        nanosleep(&sleep_time, NULL);
        -:   65:    #elif defined(MERCURY_MACOS)
        -:   66:        usleep(100000);  // 100ms
        -:   67:    #elif defined(MERCURY_WINDOWS)
        -:   68:        Sleep(100);  // 100ms
        -:   69:    #endif
        -:   70:    
        -:   71:    MercuryTimestamp end_sys = mercury_get_timestamp();
        -:   72:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   73:    
      25*:   74:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
      25*:   75:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   76:    
      25*:   77:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
      25*:   78:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
      25*:   79:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
        -:   80:    } else {
    #####:   81:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
    #####:   82:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   83:    }
        -:   84:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   52:void mercury_calibrate_rdtsc(void) {
    #####:   53:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   54:        return;  // Already calibrated
        -:   55:    }
        -:   56:    
        -:   57:    // Calibrate RDTSC against system clock
        -:   58:    MercuryTimestamp start_sys = mercury_get_timestamp();
        -:   59:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   60:    
        -:   61:    // Wait approximately 100ms
        -:   62:    #ifdef MERCURY_LINUX
    #####:   63:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   64:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   65:    #elif defined(MERCURY_MACOS)
        -:   66:        usleep(100000);  // 100ms
        -:   67:    #elif defined(MERCURY_WINDOWS)
        -:   68:        Sleep(100);  // 100ms
        -:   69:    #endif
        -:   70:    
        -:   71:    MercuryTimestamp end_sys = mercury_get_timestamp();
        -:   72:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   73:    
    #####:   74:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   75:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   76:    
    #####:   77:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   78:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   79:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   80:    } else {
    #####:   81:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   82:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   83:    }
        -:   84:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 6 returned 100% blocks executed 84%
        6:   52:void mercury_calibrate_rdtsc(void) {
        6:   53:    if (mercury_rdtsc_frequency != 0) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        4:   54:        return;  // Already calibrated
        -:   55:    }
        -:   56:    
        -:   57:    // Calibrate RDTSC against system clock
        -:   58:    MercuryTimestamp start_sys = mercury_get_timestamp();
        -:   59:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   60:    
        -:   61:    // Wait approximately 100ms
        -:   62:    #ifdef MERCURY_LINUX
        2:   63:        struct timespec sleep_time = {0, 100000000};  // 100ms
        2:   64:        nanosleep(&sleep_time, NULL);
call    0 returned 100%
        -:   65:    #elif defined(MERCURY_MACOS)
        -:   66:        usleep(100000);  // 100ms
        -:   67:    #elif defined(MERCURY_WINDOWS)
        -:   68:        Sleep(100);  // 100ms
        -:   69:    #endif
        -:   70:    
        -:   71:    MercuryTimestamp end_sys = mercury_get_timestamp();
        -:   72:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   73:    
        2:   74:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
        2:   75:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   76:    
        2:   77:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:   78:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
        2:   79:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:   80:    } else {
    #####:   81:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   82:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   83:    }
        -:   84:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 22 returned 100% blocks executed 79%
       22:   52:void mercury_calibrate_rdtsc(void) {
       22:   53:    if (mercury_rdtsc_frequency != 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   54:        return;  // Already calibrated
        -:   55:    }
        -:   56:    
        -:   57:    // Calibrate RDTSC against system clock
        -:   58:    MercuryTimestamp start_sys = mercury_get_timestamp();
        -:   59:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   60:    
        -:   61:    // Wait approximately 100ms
        -:   62:    #ifdef MERCURY_LINUX
       22:   63:        struct timespec sleep_time = {0, 100000000};  // 100ms
       22:   64:        nanosleep(&sleep_time, NULL);
call    0 returned 100%
        -:   65:    #elif defined(MERCURY_MACOS)
        -:   66:        usleep(100000);  // 100ms
        -:   67:    #elif defined(MERCURY_WINDOWS)
        -:   68:        Sleep(100);  // 100ms
        -:   69:    #endif
        -:   70:    
        -:   71:    MercuryTimestamp end_sys = mercury_get_timestamp();
        -:   72:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   73:    
       22:   74:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
       22:   75:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   76:    
       22:   77:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       22:   78:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
       22:   79:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:   80:    } else {
    #####:   81:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   82:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   83:    }
        -:   84:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   52:void mercury_calibrate_rdtsc(void) {
    #####:   53:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   54:        return;  // Already calibrated
        -:   55:    }
        -:   56:    
        -:   57:    // Calibrate RDTSC against system clock
        -:   58:    MercuryTimestamp start_sys = mercury_get_timestamp();
        -:   59:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   60:    
        -:   61:    // Wait approximately 100ms
        -:   62:    #ifdef MERCURY_LINUX
    #####:   63:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   64:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   65:    #elif defined(MERCURY_MACOS)
        -:   66:        usleep(100000);  // 100ms
        -:   67:    #elif defined(MERCURY_WINDOWS)
        -:   68:        Sleep(100);  // 100ms
        -:   69:    #endif
        -:   70:    
        -:   71:    MercuryTimestamp end_sys = mercury_get_timestamp();
        -:   72:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   73:    
    #####:   74:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   75:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   76:    
    #####:   77:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   78:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   79:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   80:    } else {
    #####:   81:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   82:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   83:    }
        -:   84:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   52:void mercury_calibrate_rdtsc(void) {
    #####:   53:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   54:        return;  // Already calibrated
        -:   55:    }
        -:   56:    
        -:   57:    // Calibrate RDTSC against system clock
        -:   58:    MercuryTimestamp start_sys = mercury_get_timestamp();
        -:   59:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   60:    
        -:   61:    // Wait approximately 100ms
        -:   62:    #ifdef MERCURY_LINUX
    #####:   63:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   64:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   65:    #elif defined(MERCURY_MACOS)
        -:   66:        usleep(100000);  // 100ms
        -:   67:    #elif defined(MERCURY_WINDOWS)
        -:   68:        Sleep(100);  // 100ms
        -:   69:    #endif
        -:   70:    
        -:   71:    MercuryTimestamp end_sys = mercury_get_timestamp();
        -:   72:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   73:    
    #####:   74:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   75:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   76:    
    #####:   77:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   78:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   79:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   80:    } else {
    #####:   81:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   82:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   83:    }
        -:   84:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 1 returned 100% blocks executed 79%
        1:   52:void mercury_calibrate_rdtsc(void) {
        1:   53:    if (mercury_rdtsc_frequency != 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   54:        return;  // Already calibrated
        -:   55:    }
        -:   56:    
        -:   57:    // Calibrate RDTSC against system clock
        -:   58:    MercuryTimestamp start_sys = mercury_get_timestamp();
        -:   59:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   60:    
        -:   61:    // Wait approximately 100ms
        -:   62:    #ifdef MERCURY_LINUX
        1:   63:        struct timespec sleep_time = {0, 100000000};  // 100ms
        1:   64:        nanosleep(&sleep_time, NULL);
call    0 returned 100%
        -:   65:    #elif defined(MERCURY_MACOS)
        -:   66:        usleep(100000);  // 100ms
        -:   67:    #elif defined(MERCURY_WINDOWS)
        -:   68:        Sleep(100);  // 100ms
        -:   69:    #endif
        -:   70:    
        -:   71:    MercuryTimestamp end_sys = mercury_get_timestamp();
        -:   72:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   73:    
        1:   74:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
        1:   75:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   76:    
        1:   77:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   78:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
        1:   79:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:   80:    } else {
    #####:   81:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   82:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   83:    }
        -:   84:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   52:void mercury_calibrate_rdtsc(void) {
    #####:   53:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   54:        return;  // Already calibrated
        -:   55:    }
        -:   56:    
        -:   57:    // Calibrate RDTSC against system clock
        -:   58:    MercuryTimestamp start_sys = mercury_get_timestamp();
        -:   59:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   60:    
        -:   61:    // Wait approximately 100ms
        -:   62:    #ifdef MERCURY_LINUX
    #####:   63:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   64:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   65:    #elif defined(MERCURY_MACOS)
        -:   66:        usleep(100000);  // 100ms
        -:   67:    #elif defined(MERCURY_WINDOWS)
        -:   68:        Sleep(100);  // 100ms
        -:   69:    #endif
        -:   70:    
        -:   71:    MercuryTimestamp end_sys = mercury_get_timestamp();
        -:   72:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   73:    
    #####:   74:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   75:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   76:    
    #####:   77:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   78:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   79:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   80:    } else {
    #####:   81:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   82:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   83:    }
        -:   84:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   52:void mercury_calibrate_rdtsc(void) {
    #####:   53:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   54:        return;  // Already calibrated
        -:   55:    }
        -:   56:    
        -:   57:    // Calibrate RDTSC against system clock
        -:   58:    MercuryTimestamp start_sys = mercury_get_timestamp();
        -:   59:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   60:    
        -:   61:    // Wait approximately 100ms
        -:   62:    #ifdef MERCURY_LINUX
    #####:   63:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   64:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   65:    #elif defined(MERCURY_MACOS)
        -:   66:        usleep(100000);  // 100ms
        -:   67:    #elif defined(MERCURY_WINDOWS)
        -:   68:        Sleep(100);  // 100ms
        -:   69:    #endif
        -:   70:    
        -:   71:    MercuryTimestamp end_sys = mercury_get_timestamp();
        -:   72:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   73:    
    #####:   74:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   75:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   76:    
    #####:   77:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   78:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   79:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   80:    } else {
    #####:   81:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   82:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   83:    }
        -:   84:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   52:void mercury_calibrate_rdtsc(void) {
    #####:   53:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   54:        return;  // Already calibrated
        -:   55:    }
        -:   56:    
        -:   57:    // Calibrate RDTSC against system clock
        -:   58:    MercuryTimestamp start_sys = mercury_get_timestamp();
        -:   59:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   60:    
        -:   61:    // Wait approximately 100ms
        -:   62:    #ifdef MERCURY_LINUX
    #####:   63:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   64:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   65:    #elif defined(MERCURY_MACOS)
        -:   66:        usleep(100000);  // 100ms
        -:   67:    #elif defined(MERCURY_WINDOWS)
        -:   68:        Sleep(100);  // 100ms
        -:   69:    #endif
        -:   70:    
        -:   71:    MercuryTimestamp end_sys = mercury_get_timestamp();
        -:   72:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   73:    
    #####:   74:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   75:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   76:    
    #####:   77:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   78:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   79:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   80:    } else {
    #####:   81:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   82:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   83:    }
        -:   84:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   52:void mercury_calibrate_rdtsc(void) {
    #####:   53:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   54:        return;  // Already calibrated
        -:   55:    }
        -:   56:    
        -:   57:    // Calibrate RDTSC against system clock
        -:   58:    MercuryTimestamp start_sys = mercury_get_timestamp();
        -:   59:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   60:    
        -:   61:    // Wait approximately 100ms
        -:   62:    #ifdef MERCURY_LINUX
    #####:   63:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   64:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   65:    #elif defined(MERCURY_MACOS)
        -:   66:        usleep(100000);  // 100ms
        -:   67:    #elif defined(MERCURY_WINDOWS)
        -:   68:        Sleep(100);  // 100ms
        -:   69:    #endif
        -:   70:    
        -:   71:    MercuryTimestamp end_sys = mercury_get_timestamp();
        -:   72:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   73:    
    #####:   74:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   75:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   76:    
    #####:   77:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   78:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   79:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   80:    } else {
    #####:   81:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   82:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   83:    }
        -:   84:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   52:void mercury_calibrate_rdtsc(void) {
    #####:   53:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   54:        return;  // Already calibrated
        -:   55:    }
        -:   56:    
        -:   57:    // Calibrate RDTSC against system clock
        -:   58:    MercuryTimestamp start_sys = mercury_get_timestamp();
        -:   59:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   60:    
        -:   61:    // Wait approximately 100ms
        -:   62:    #ifdef MERCURY_LINUX
    #####:   63:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   64:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   65:    #elif defined(MERCURY_MACOS)
        -:   66:        usleep(100000);  // 100ms
        -:   67:    #elif defined(MERCURY_WINDOWS)
        -:   68:        Sleep(100);  // 100ms
        -:   69:    #endif
        -:   70:    
        -:   71:    MercuryTimestamp end_sys = mercury_get_timestamp();
        -:   72:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   73:    
    #####:   74:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   75:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   76:    
    #####:   77:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   78:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   79:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   80:    } else {
    #####:   81:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   82:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   83:    }
        -:   84:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   52:void mercury_calibrate_rdtsc(void) {
    #####:   53:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   54:        return;  // Already calibrated
        -:   55:    }
        -:   56:    
        -:   57:    // Calibrate RDTSC against system clock
        -:   58:    MercuryTimestamp start_sys = mercury_get_timestamp();
        -:   59:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   60:    
        -:   61:    // Wait approximately 100ms
        -:   62:    #ifdef MERCURY_LINUX
    #####:   63:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   64:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   65:    #elif defined(MERCURY_MACOS)
        -:   66:        usleep(100000);  // 100ms
        -:   67:    #elif defined(MERCURY_WINDOWS)
        -:   68:        Sleep(100);  // 100ms
        -:   69:    #endif
        -:   70:    
        -:   71:    MercuryTimestamp end_sys = mercury_get_timestamp();
        -:   72:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   73:    
    #####:   74:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   75:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   76:    
    #####:   77:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   78:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   79:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   80:    } else {
    #####:   81:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   82:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   83:    }
        -:   84:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   52:void mercury_calibrate_rdtsc(void) {
    #####:   53:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   54:        return;  // Already calibrated
        -:   55:    }
        -:   56:    
        -:   57:    // Calibrate RDTSC against system clock
        -:   58:    MercuryTimestamp start_sys = mercury_get_timestamp();
        -:   59:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   60:    
        -:   61:    // Wait approximately 100ms
        -:   62:    #ifdef MERCURY_LINUX
    #####:   63:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   64:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   65:    #elif defined(MERCURY_MACOS)
        -:   66:        usleep(100000);  // 100ms
        -:   67:    #elif defined(MERCURY_WINDOWS)
        -:   68:        Sleep(100);  // 100ms
        -:   69:    #endif
        -:   70:    
        -:   71:    MercuryTimestamp end_sys = mercury_get_timestamp();
        -:   72:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   73:    
    #####:   74:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   75:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   76:    
    #####:   77:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   78:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   79:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   80:    } else {
    #####:   81:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   82:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   83:    }
        -:   84:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   52:void mercury_calibrate_rdtsc(void) {
    #####:   53:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   54:        return;  // Already calibrated
        -:   55:    }
        -:   56:    
        -:   57:    // Calibrate RDTSC against system clock
        -:   58:    MercuryTimestamp start_sys = mercury_get_timestamp();
        -:   59:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   60:    
        -:   61:    // Wait approximately 100ms
        -:   62:    #ifdef MERCURY_LINUX
    #####:   63:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   64:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   65:    #elif defined(MERCURY_MACOS)
        -:   66:        usleep(100000);  // 100ms
        -:   67:    #elif defined(MERCURY_WINDOWS)
        -:   68:        Sleep(100);  // 100ms
        -:   69:    #endif
        -:   70:    
        -:   71:    MercuryTimestamp end_sys = mercury_get_timestamp();
        -:   72:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   73:    
    #####:   74:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   75:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   76:    
    #####:   77:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   78:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   79:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   80:    } else {
    #####:   81:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   82:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   83:    }
        -:   84:}
------------------
        -:   85:#endif
        -:   86:
        -:   87:// === MEMORY UTILITIES ===
        -:   88:
  105386*:   89:void* mercury_aligned_alloc(size_t size, size_t alignment) {
  105386*:   90:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
      10*:   91:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
      10*:   92:        return NULL;
        -:   93:    }
        -:   94:    
  105376*:   95:    void* ptr = NULL;
        -:   96:    
        -:   97:#ifdef MERCURY_LINUX
  105376*:   98:    if (posix_memalign(&ptr, alignment, size) != 0) {
       3*:   99:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
       3*:  100:        return NULL;
        -:  101:    }
        -:  102:#elif defined(MERCURY_MACOS)
        -:  103:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  104:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  105:        return NULL;
        -:  106:    }
        -:  107:#elif defined(MERCURY_WINDOWS)
        -:  108:    ptr = _aligned_malloc(size, alignment);
        -:  109:    if (!ptr) {
        -:  110:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  111:        return NULL;
        -:  112:    }
        -:  113:#else
        -:  114:    // Fallback: allocate extra space and align manually
        -:  115:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  116:    if (!raw_ptr) {
        -:  117:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  118:        return NULL;
        -:  119:    }
        -:  120:    
        -:  121:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  122:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  123:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  124:    ptr = aligned_ptr;
        -:  125:#endif
        -:  126:    
  105373*:  127:    return ptr;
        -:  128:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 100002 returned 100% blocks executed 75%
   100002:   89:void* mercury_aligned_alloc(size_t size, size_t alignment) {
   100002:   90:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   91:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:   92:        return NULL;
        -:   93:    }
        -:   94:    
   100002:   95:    void* ptr = NULL;
        -:   96:    
        -:   97:#ifdef MERCURY_LINUX
   100002:   98:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   99:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  100:        return NULL;
        -:  101:    }
        -:  102:#elif defined(MERCURY_MACOS)
        -:  103:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  104:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  105:        return NULL;
        -:  106:    }
        -:  107:#elif defined(MERCURY_WINDOWS)
        -:  108:    ptr = _aligned_malloc(size, alignment);
        -:  109:    if (!ptr) {
        -:  110:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  111:        return NULL;
        -:  112:    }
        -:  113:#else
        -:  114:    // Fallback: allocate extra space and align manually
        -:  115:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  116:    if (!raw_ptr) {
        -:  117:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  118:        return NULL;
        -:  119:    }
        -:  120:    
        -:  121:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  122:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  123:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  124:    ptr = aligned_ptr;
        -:  125:#endif
        -:  126:    
   100002:  127:    return ptr;
        -:  128:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 139 returned 100% blocks executed 100%
      139:   89:void* mercury_aligned_alloc(size_t size, size_t alignment) {
      139:   90:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
branch  2 taken 2% (fallthrough)
branch  3 taken 98%
        7:   91:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
        7:   92:        return NULL;
        -:   93:    }
        -:   94:    
      132:   95:    void* ptr = NULL;
        -:   96:    
        -:   97:#ifdef MERCURY_LINUX
      132:   98:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
        2:   99:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        2:  100:        return NULL;
        -:  101:    }
        -:  102:#elif defined(MERCURY_MACOS)
        -:  103:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  104:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  105:        return NULL;
        -:  106:    }
        -:  107:#elif defined(MERCURY_WINDOWS)
        -:  108:    ptr = _aligned_malloc(size, alignment);
        -:  109:    if (!ptr) {
        -:  110:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  111:        return NULL;
        -:  112:    }
        -:  113:#else
        -:  114:    // Fallback: allocate extra space and align manually
        -:  115:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  116:    if (!raw_ptr) {
        -:  117:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  118:        return NULL;
        -:  119:    }
        -:  120:    
        -:  121:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  122:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  123:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  124:    ptr = aligned_ptr;
        -:  125:#endif
        -:  126:    
      130:  127:    return ptr;
        -:  128:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 116 returned 100% blocks executed 100%
      116:   89:void* mercury_aligned_alloc(size_t size, size_t alignment) {
      116:   90:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
        3:   91:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
        3:   92:        return NULL;
        -:   93:    }
        -:   94:    
      113:   95:    void* ptr = NULL;
        -:   96:    
        -:   97:#ifdef MERCURY_LINUX
      113:   98:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        1:   99:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        1:  100:        return NULL;
        -:  101:    }
        -:  102:#elif defined(MERCURY_MACOS)
        -:  103:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  104:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  105:        return NULL;
        -:  106:    }
        -:  107:#elif defined(MERCURY_WINDOWS)
        -:  108:    ptr = _aligned_malloc(size, alignment);
        -:  109:    if (!ptr) {
        -:  110:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  111:        return NULL;
        -:  112:    }
        -:  113:#else
        -:  114:    // Fallback: allocate extra space and align manually
        -:  115:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  116:    if (!raw_ptr) {
        -:  117:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  118:        return NULL;
        -:  119:    }
        -:  120:    
        -:  121:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  122:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  123:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  124:    ptr = aligned_ptr;
        -:  125:#endif
        -:  126:    
      112:  127:    return ptr;
        -:  128:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 19 returned 100% blocks executed 75%
       19:   89:void* mercury_aligned_alloc(size_t size, size_t alignment) {
       19:   90:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   91:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:   92:        return NULL;
        -:   93:    }
        -:   94:    
       19:   95:    void* ptr = NULL;
        -:   96:    
        -:   97:#ifdef MERCURY_LINUX
       19:   98:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   99:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  100:        return NULL;
        -:  101:    }
        -:  102:#elif defined(MERCURY_MACOS)
        -:  103:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  104:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  105:        return NULL;
        -:  106:    }
        -:  107:#elif defined(MERCURY_WINDOWS)
        -:  108:    ptr = _aligned_malloc(size, alignment);
        -:  109:    if (!ptr) {
        -:  110:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  111:        return NULL;
        -:  112:    }
        -:  113:#else
        -:  114:    // Fallback: allocate extra space and align manually
        -:  115:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  116:    if (!raw_ptr) {
        -:  117:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  118:        return NULL;
        -:  119:    }
        -:  120:    
        -:  121:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  122:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  123:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  124:    ptr = aligned_ptr;
        -:  125:#endif
        -:  126:    
       19:  127:    return ptr;
        -:  128:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 0 returned 0% blocks executed 0%
    #####:   89:void* mercury_aligned_alloc(size_t size, size_t alignment) {
    #####:   90:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   91:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:   92:        return NULL;
        -:   93:    }
        -:   94:    
    #####:   95:    void* ptr = NULL;
        -:   96:    
        -:   97:#ifdef MERCURY_LINUX
    #####:   98:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   99:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  100:        return NULL;
        -:  101:    }
        -:  102:#elif defined(MERCURY_MACOS)
        -:  103:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  104:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  105:        return NULL;
        -:  106:    }
        -:  107:#elif defined(MERCURY_WINDOWS)
        -:  108:    ptr = _aligned_malloc(size, alignment);
        -:  109:    if (!ptr) {
        -:  110:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  111:        return NULL;
        -:  112:    }
        -:  113:#else
        -:  114:    // Fallback: allocate extra space and align manually
        -:  115:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  116:    if (!raw_ptr) {
        -:  117:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  118:        return NULL;
        -:  119:    }
        -:  120:    
        -:  121:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  122:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  123:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  124:    ptr = aligned_ptr;
        -:  125:#endif
        -:  126:    
    #####:  127:    return ptr;
        -:  128:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 96 returned 100% blocks executed 75%
       96:   89:void* mercury_aligned_alloc(size_t size, size_t alignment) {
       96:   90:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   91:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:   92:        return NULL;
        -:   93:    }
        -:   94:    
       96:   95:    void* ptr = NULL;
        -:   96:    
        -:   97:#ifdef MERCURY_LINUX
       96:   98:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   99:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  100:        return NULL;
        -:  101:    }
        -:  102:#elif defined(MERCURY_MACOS)
        -:  103:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  104:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  105:        return NULL;
        -:  106:    }
        -:  107:#elif defined(MERCURY_WINDOWS)
        -:  108:    ptr = _aligned_malloc(size, alignment);
        -:  109:    if (!ptr) {
        -:  110:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  111:        return NULL;
        -:  112:    }
        -:  113:#else
        -:  114:    // Fallback: allocate extra space and align manually
        -:  115:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  116:    if (!raw_ptr) {
        -:  117:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  118:        return NULL;
        -:  119:    }
        -:  120:    
        -:  121:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  122:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  123:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  124:    ptr = aligned_ptr;
        -:  125:#endif
        -:  126:    
       96:  127:    return ptr;
        -:  128:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 0 returned 0% blocks executed 0%
    #####:   89:void* mercury_aligned_alloc(size_t size, size_t alignment) {
    #####:   90:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   91:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:   92:        return NULL;
        -:   93:    }
        -:   94:    
    #####:   95:    void* ptr = NULL;
        -:   96:    
        -:   97:#ifdef MERCURY_LINUX
    #####:   98:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   99:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  100:        return NULL;
        -:  101:    }
        -:  102:#elif defined(MERCURY_MACOS)
        -:  103:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  104:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  105:        return NULL;
        -:  106:    }
        -:  107:#elif defined(MERCURY_WINDOWS)
        -:  108:    ptr = _aligned_malloc(size, alignment);
        -:  109:    if (!ptr) {
        -:  110:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  111:        return NULL;
        -:  112:    }
        -:  113:#else
        -:  114:    // Fallback: allocate extra space and align manually
        -:  115:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  116:    if (!raw_ptr) {
        -:  117:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  118:        return NULL;
        -:  119:    }
        -:  120:    
        -:  121:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  122:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  123:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  124:    ptr = aligned_ptr;
        -:  125:#endif
        -:  126:    
    #####:  127:    return ptr;
        -:  128:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 0 returned 0% blocks executed 0%
    #####:   89:void* mercury_aligned_alloc(size_t size, size_t alignment) {
    #####:   90:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   91:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:   92:        return NULL;
        -:   93:    }
        -:   94:    
    #####:   95:    void* ptr = NULL;
        -:   96:    
        -:   97:#ifdef MERCURY_LINUX
    #####:   98:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   99:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  100:        return NULL;
        -:  101:    }
        -:  102:#elif defined(MERCURY_MACOS)
        -:  103:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  104:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  105:        return NULL;
        -:  106:    }
        -:  107:#elif defined(MERCURY_WINDOWS)
        -:  108:    ptr = _aligned_malloc(size, alignment);
        -:  109:    if (!ptr) {
        -:  110:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  111:        return NULL;
        -:  112:    }
        -:  113:#else
        -:  114:    // Fallback: allocate extra space and align manually
        -:  115:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  116:    if (!raw_ptr) {
        -:  117:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  118:        return NULL;
        -:  119:    }
        -:  120:    
        -:  121:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  122:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  123:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  124:    ptr = aligned_ptr;
        -:  125:#endif
        -:  126:    
    #####:  127:    return ptr;
        -:  128:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 0 returned 0% blocks executed 0%
    #####:   89:void* mercury_aligned_alloc(size_t size, size_t alignment) {
    #####:   90:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:   91:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:   92:        return NULL;
        -:   93:    }
        -:   94:    
    #####:   95:    void* ptr = NULL;
        -:   96:    
        -:   97:#ifdef MERCURY_LINUX
    #####:   98:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   99:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  100:        return NULL;
        -:  101:    }
        -:  102:#elif defined(MERCURY_MACOS)
        -:  103:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  104:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  105:        return NULL;
        -:  106:    }
        -:  107:#elif defined(MERCURY_WINDOWS)
        -:  108:    ptr = _aligned_malloc(size, alignment);
        -:  109:    if (!ptr) {
        -:  110:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  111:        return NULL;
        -:  112:    }
        -:  113:#else
        -:  114:    // Fallback: allocate extra space and align manually
        -:  115:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  116:    if (!raw_ptr) {
        -:  117:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  118:        return NULL;
        -:  119:    }
        -:  120:    
        -:  121:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  122:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  123:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  124:    ptr = aligned_ptr;
        -:  125:#endif
        -:  126:    
    #####:  127:    return ptr;
        -:  128:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 2504 returned 100% blocks executed 75%
     2504:   89:void* mercury_aligned_alloc(size_t size, size_t alignment) {
     2504:   90:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   91:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:   92:        return NULL;
        -:   93:    }
        -:   94:    
     2504:   95:    void* ptr = NULL;
        -:   96:    
        -:   97:#ifdef MERCURY_LINUX
     2504:   98:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   99:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  100:        return NULL;
        -:  101:    }
        -:  102:#elif defined(MERCURY_MACOS)
        -:  103:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  104:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  105:        return NULL;
        -:  106:    }
        -:  107:#elif defined(MERCURY_WINDOWS)
        -:  108:    ptr = _aligned_malloc(size, alignment);
        -:  109:    if (!ptr) {
        -:  110:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  111:        return NULL;
        -:  112:    }
        -:  113:#else
        -:  114:    // Fallback: allocate extra space and align manually
        -:  115:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  116:    if (!raw_ptr) {
        -:  117:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  118:        return NULL;
        -:  119:    }
        -:  120:    
        -:  121:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  122:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  123:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  124:    ptr = aligned_ptr;
        -:  125:#endif
        -:  126:    
     2504:  127:    return ptr;
        -:  128:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 2504 returned 100% blocks executed 75%
     2504:   89:void* mercury_aligned_alloc(size_t size, size_t alignment) {
     2504:   90:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   91:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:   92:        return NULL;
        -:   93:    }
        -:   94:    
     2504:   95:    void* ptr = NULL;
        -:   96:    
        -:   97:#ifdef MERCURY_LINUX
     2504:   98:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   99:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  100:        return NULL;
        -:  101:    }
        -:  102:#elif defined(MERCURY_MACOS)
        -:  103:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  104:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  105:        return NULL;
        -:  106:    }
        -:  107:#elif defined(MERCURY_WINDOWS)
        -:  108:    ptr = _aligned_malloc(size, alignment);
        -:  109:    if (!ptr) {
        -:  110:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  111:        return NULL;
        -:  112:    }
        -:  113:#else
        -:  114:    // Fallback: allocate extra space and align manually
        -:  115:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  116:    if (!raw_ptr) {
        -:  117:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  118:        return NULL;
        -:  119:    }
        -:  120:    
        -:  121:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  122:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  123:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  124:    ptr = aligned_ptr;
        -:  125:#endif
        -:  126:    
     2504:  127:    return ptr;
        -:  128:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 2 returned 100% blocks executed 75%
        2:   89:void* mercury_aligned_alloc(size_t size, size_t alignment) {
        2:   90:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   91:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:   92:        return NULL;
        -:   93:    }
        -:   94:    
        2:   95:    void* ptr = NULL;
        -:   96:    
        -:   97:#ifdef MERCURY_LINUX
        2:   98:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   99:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  100:        return NULL;
        -:  101:    }
        -:  102:#elif defined(MERCURY_MACOS)
        -:  103:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  104:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  105:        return NULL;
        -:  106:    }
        -:  107:#elif defined(MERCURY_WINDOWS)
        -:  108:    ptr = _aligned_malloc(size, alignment);
        -:  109:    if (!ptr) {
        -:  110:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  111:        return NULL;
        -:  112:    }
        -:  113:#else
        -:  114:    // Fallback: allocate extra space and align manually
        -:  115:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  116:    if (!raw_ptr) {
        -:  117:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  118:        return NULL;
        -:  119:    }
        -:  120:    
        -:  121:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  122:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  123:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  124:    ptr = aligned_ptr;
        -:  125:#endif
        -:  126:    
        2:  127:    return ptr;
        -:  128:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 2 returned 100% blocks executed 75%
        2:   89:void* mercury_aligned_alloc(size_t size, size_t alignment) {
        2:   90:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   91:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:   92:        return NULL;
        -:   93:    }
        -:   94:    
        2:   95:    void* ptr = NULL;
        -:   96:    
        -:   97:#ifdef MERCURY_LINUX
        2:   98:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   99:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  100:        return NULL;
        -:  101:    }
        -:  102:#elif defined(MERCURY_MACOS)
        -:  103:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  104:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  105:        return NULL;
        -:  106:    }
        -:  107:#elif defined(MERCURY_WINDOWS)
        -:  108:    ptr = _aligned_malloc(size, alignment);
        -:  109:    if (!ptr) {
        -:  110:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  111:        return NULL;
        -:  112:    }
        -:  113:#else
        -:  114:    // Fallback: allocate extra space and align manually
        -:  115:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  116:    if (!raw_ptr) {
        -:  117:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  118:        return NULL;
        -:  119:    }
        -:  120:    
        -:  121:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  122:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  123:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  124:    ptr = aligned_ptr;
        -:  125:#endif
        -:  126:    
        2:  127:    return ptr;
        -:  128:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 2 returned 100% blocks executed 75%
        2:   89:void* mercury_aligned_alloc(size_t size, size_t alignment) {
        2:   90:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:   91:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:   92:        return NULL;
        -:   93:    }
        -:   94:    
        2:   95:    void* ptr = NULL;
        -:   96:    
        -:   97:#ifdef MERCURY_LINUX
        2:   98:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   99:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  100:        return NULL;
        -:  101:    }
        -:  102:#elif defined(MERCURY_MACOS)
        -:  103:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  104:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  105:        return NULL;
        -:  106:    }
        -:  107:#elif defined(MERCURY_WINDOWS)
        -:  108:    ptr = _aligned_malloc(size, alignment);
        -:  109:    if (!ptr) {
        -:  110:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  111:        return NULL;
        -:  112:    }
        -:  113:#else
        -:  114:    // Fallback: allocate extra space and align manually
        -:  115:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  116:    if (!raw_ptr) {
        -:  117:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  118:        return NULL;
        -:  119:    }
        -:  120:    
        -:  121:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  122:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  123:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  124:    ptr = aligned_ptr;
        -:  125:#endif
        -:  126:    
        2:  127:    return ptr;
        -:  128:}
------------------
        -:  129:
  105374*:  130:void mercury_aligned_free(void* ptr) {
  105374*:  131:    if (!ptr) return;
        -:  132:    
        -:  133:#ifdef MERCURY_LINUX
  105373*:  134:    free(ptr);
        -:  135:#elif defined(MERCURY_MACOS)
        -:  136:    free(ptr);
        -:  137:#elif defined(MERCURY_WINDOWS)
        -:  138:    _aligned_free(ptr);
        -:  139:#else
        -:  140:    // Fallback: retrieve original pointer and free
        -:  141:    void* raw_ptr = ((void**)ptr)[-1];
        -:  142:    free(raw_ptr);
        -:  143:#endif
        -:  144:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 100002 returned 100% blocks executed 100%
   100002:  130:void mercury_aligned_free(void* ptr) {
   100002:  131:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  132:    
        -:  133:#ifdef MERCURY_LINUX
   100002:  134:    free(ptr);
        -:  135:#elif defined(MERCURY_MACOS)
        -:  136:    free(ptr);
        -:  137:#elif defined(MERCURY_WINDOWS)
        -:  138:    _aligned_free(ptr);
        -:  139:#else
        -:  140:    // Fallback: retrieve original pointer and free
        -:  141:    void* raw_ptr = ((void**)ptr)[-1];
        -:  142:    free(raw_ptr);
        -:  143:#endif
        -:  144:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 131 returned 100% blocks executed 100%
      131:  130:void mercury_aligned_free(void* ptr) {
      131:  131:    if (!ptr) return;
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  132:    
        -:  133:#ifdef MERCURY_LINUX
      130:  134:    free(ptr);
        -:  135:#elif defined(MERCURY_MACOS)
        -:  136:    free(ptr);
        -:  137:#elif defined(MERCURY_WINDOWS)
        -:  138:    _aligned_free(ptr);
        -:  139:#else
        -:  140:    // Fallback: retrieve original pointer and free
        -:  141:    void* raw_ptr = ((void**)ptr)[-1];
        -:  142:    free(raw_ptr);
        -:  143:#endif
        -:  144:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 112 returned 100% blocks executed 100%
      112:  130:void mercury_aligned_free(void* ptr) {
      112:  131:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  132:    
        -:  133:#ifdef MERCURY_LINUX
      112:  134:    free(ptr);
        -:  135:#elif defined(MERCURY_MACOS)
        -:  136:    free(ptr);
        -:  137:#elif defined(MERCURY_WINDOWS)
        -:  138:    _aligned_free(ptr);
        -:  139:#else
        -:  140:    // Fallback: retrieve original pointer and free
        -:  141:    void* raw_ptr = ((void**)ptr)[-1];
        -:  142:    free(raw_ptr);
        -:  143:#endif
        -:  144:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 19 returned 100% blocks executed 100%
       19:  130:void mercury_aligned_free(void* ptr) {
       19:  131:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  132:    
        -:  133:#ifdef MERCURY_LINUX
       19:  134:    free(ptr);
        -:  135:#elif defined(MERCURY_MACOS)
        -:  136:    free(ptr);
        -:  137:#elif defined(MERCURY_WINDOWS)
        -:  138:    _aligned_free(ptr);
        -:  139:#else
        -:  140:    // Fallback: retrieve original pointer and free
        -:  141:    void* raw_ptr = ((void**)ptr)[-1];
        -:  142:    free(raw_ptr);
        -:  143:#endif
        -:  144:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 0 returned 0% blocks executed 0%
    #####:  130:void mercury_aligned_free(void* ptr) {
    #####:  131:    if (!ptr) return;
branch  0 never executed
branch  1 never executed
        -:  132:    
        -:  133:#ifdef MERCURY_LINUX
    #####:  134:    free(ptr);
        -:  135:#elif defined(MERCURY_MACOS)
        -:  136:    free(ptr);
        -:  137:#elif defined(MERCURY_WINDOWS)
        -:  138:    _aligned_free(ptr);
        -:  139:#else
        -:  140:    // Fallback: retrieve original pointer and free
        -:  141:    void* raw_ptr = ((void**)ptr)[-1];
        -:  142:    free(raw_ptr);
        -:  143:#endif
        -:  144:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 96 returned 100% blocks executed 100%
       96:  130:void mercury_aligned_free(void* ptr) {
       96:  131:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  132:    
        -:  133:#ifdef MERCURY_LINUX
       96:  134:    free(ptr);
        -:  135:#elif defined(MERCURY_MACOS)
        -:  136:    free(ptr);
        -:  137:#elif defined(MERCURY_WINDOWS)
        -:  138:    _aligned_free(ptr);
        -:  139:#else
        -:  140:    // Fallback: retrieve original pointer and free
        -:  141:    void* raw_ptr = ((void**)ptr)[-1];
        -:  142:    free(raw_ptr);
        -:  143:#endif
        -:  144:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 0 returned 0% blocks executed 0%
    #####:  130:void mercury_aligned_free(void* ptr) {
    #####:  131:    if (!ptr) return;
branch  0 never executed
branch  1 never executed
        -:  132:    
        -:  133:#ifdef MERCURY_LINUX
    #####:  134:    free(ptr);
        -:  135:#elif defined(MERCURY_MACOS)
        -:  136:    free(ptr);
        -:  137:#elif defined(MERCURY_WINDOWS)
        -:  138:    _aligned_free(ptr);
        -:  139:#else
        -:  140:    // Fallback: retrieve original pointer and free
        -:  141:    void* raw_ptr = ((void**)ptr)[-1];
        -:  142:    free(raw_ptr);
        -:  143:#endif
        -:  144:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 0 returned 0% blocks executed 0%
    #####:  130:void mercury_aligned_free(void* ptr) {
    #####:  131:    if (!ptr) return;
branch  0 never executed
branch  1 never executed
        -:  132:    
        -:  133:#ifdef MERCURY_LINUX
    #####:  134:    free(ptr);
        -:  135:#elif defined(MERCURY_MACOS)
        -:  136:    free(ptr);
        -:  137:#elif defined(MERCURY_WINDOWS)
        -:  138:    _aligned_free(ptr);
        -:  139:#else
        -:  140:    // Fallback: retrieve original pointer and free
        -:  141:    void* raw_ptr = ((void**)ptr)[-1];
        -:  142:    free(raw_ptr);
        -:  143:#endif
        -:  144:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 0 returned 0% blocks executed 0%
    #####:  130:void mercury_aligned_free(void* ptr) {
    #####:  131:    if (!ptr) return;
branch  0 never executed
branch  1 never executed
        -:  132:    
        -:  133:#ifdef MERCURY_LINUX
    #####:  134:    free(ptr);
        -:  135:#elif defined(MERCURY_MACOS)
        -:  136:    free(ptr);
        -:  137:#elif defined(MERCURY_WINDOWS)
        -:  138:    _aligned_free(ptr);
        -:  139:#else
        -:  140:    // Fallback: retrieve original pointer and free
        -:  141:    void* raw_ptr = ((void**)ptr)[-1];
        -:  142:    free(raw_ptr);
        -:  143:#endif
        -:  144:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 2504 returned 100% blocks executed 100%
     2504:  130:void mercury_aligned_free(void* ptr) {
     2504:  131:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  132:    
        -:  133:#ifdef MERCURY_LINUX
     2504:  134:    free(ptr);
        -:  135:#elif defined(MERCURY_MACOS)
        -:  136:    free(ptr);
        -:  137:#elif defined(MERCURY_WINDOWS)
        -:  138:    _aligned_free(ptr);
        -:  139:#else
        -:  140:    // Fallback: retrieve original pointer and free
        -:  141:    void* raw_ptr = ((void**)ptr)[-1];
        -:  142:    free(raw_ptr);
        -:  143:#endif
        -:  144:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 2504 returned 100% blocks executed 100%
     2504:  130:void mercury_aligned_free(void* ptr) {
     2504:  131:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  132:    
        -:  133:#ifdef MERCURY_LINUX
     2504:  134:    free(ptr);
        -:  135:#elif defined(MERCURY_MACOS)
        -:  136:    free(ptr);
        -:  137:#elif defined(MERCURY_WINDOWS)
        -:  138:    _aligned_free(ptr);
        -:  139:#else
        -:  140:    // Fallback: retrieve original pointer and free
        -:  141:    void* raw_ptr = ((void**)ptr)[-1];
        -:  142:    free(raw_ptr);
        -:  143:#endif
        -:  144:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 2 returned 100% blocks executed 100%
        2:  130:void mercury_aligned_free(void* ptr) {
        2:  131:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  132:    
        -:  133:#ifdef MERCURY_LINUX
        2:  134:    free(ptr);
        -:  135:#elif defined(MERCURY_MACOS)
        -:  136:    free(ptr);
        -:  137:#elif defined(MERCURY_WINDOWS)
        -:  138:    _aligned_free(ptr);
        -:  139:#else
        -:  140:    // Fallback: retrieve original pointer and free
        -:  141:    void* raw_ptr = ((void**)ptr)[-1];
        -:  142:    free(raw_ptr);
        -:  143:#endif
        -:  144:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 2 returned 100% blocks executed 100%
        2:  130:void mercury_aligned_free(void* ptr) {
        2:  131:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  132:    
        -:  133:#ifdef MERCURY_LINUX
        2:  134:    free(ptr);
        -:  135:#elif defined(MERCURY_MACOS)
        -:  136:    free(ptr);
        -:  137:#elif defined(MERCURY_WINDOWS)
        -:  138:    _aligned_free(ptr);
        -:  139:#else
        -:  140:    // Fallback: retrieve original pointer and free
        -:  141:    void* raw_ptr = ((void**)ptr)[-1];
        -:  142:    free(raw_ptr);
        -:  143:#endif
        -:  144:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 2 returned 100% blocks executed 100%
        2:  130:void mercury_aligned_free(void* ptr) {
        2:  131:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  132:    
        -:  133:#ifdef MERCURY_LINUX
        2:  134:    free(ptr);
        -:  135:#elif defined(MERCURY_MACOS)
        -:  136:    free(ptr);
        -:  137:#elif defined(MERCURY_WINDOWS)
        -:  138:    _aligned_free(ptr);
        -:  139:#else
        -:  140:    // Fallback: retrieve original pointer and free
        -:  141:    void* raw_ptr = ((void**)ptr)[-1];
        -:  142:    free(raw_ptr);
        -:  143:#endif
        -:  144:}
------------------
        -:  145:
        -:  146:// === RING BUFFER IMPLEMENTATION ===
        -:  147:
      13*:  148:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
      13*:  149:    if (element_size == 0 || capacity == 0) {
       4*:  150:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
       4*:  151:        return NULL;
        -:  152:    }
        -:  153:    
        -:  154:    // Check for overflow in size calculation
        -:  155:    size_t total_size;
       9*:  156:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
    #####:  157:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  158:                         "Buffer size would overflow");
    #####:  159:        return NULL;
        -:  160:    }
        -:  161:    
        -:  162:    // Sanity check: limit to 1GB to prevent accidental huge allocations
       9*:  163:    if (total_size > (1ULL << 30)) {
       1*:  164:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  165:                         "Buffer size too large (max 1GB)");
       1*:  166:        return NULL;
        -:  167:    }
        -:  168:    
       8*:  169:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
       8*:  170:    if (!buffer) {
    #####:  171:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  172:                         "Failed to allocate ring buffer structure");
    #####:  173:        return NULL;
        -:  174:    }
        -:  175:    
       8*:  176:    buffer->data = mercury_aligned_alloc(total_size, 64);
       8*:  177:    if (!buffer->data) {
    #####:  178:        mercury_aligned_free(buffer);
    #####:  179:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  180:                         "Failed to allocate ring buffer data");
    #####:  181:        return NULL;
        -:  182:    }
        -:  183:    
       8*:  184:    buffer->element_size = element_size;
       8*:  185:    buffer->capacity = capacity;
       8*:  186:    atomic_store(&buffer->head, 0);
       8*:  187:    atomic_store(&buffer->tail, 0);
       8*:  188:    atomic_store(&buffer->count, 0);
        -:  189:    
       8*:  190:    return buffer;
        -:  191:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 1 returned 100% blocks executed 65%
        1:  148:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
        1:  149:    if (element_size == 0 || capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  150:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  151:        return NULL;
        -:  152:    }
        -:  153:    
        -:  154:    // Check for overflow in size calculation
        -:  155:    size_t total_size;
        1:  156:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  157:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  158:                         "Buffer size would overflow");
    #####:  159:        return NULL;
        -:  160:    }
        -:  161:    
        -:  162:    // Sanity check: limit to 1GB to prevent accidental huge allocations
        1:  163:    if (total_size > (1ULL << 30)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  164:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  165:                         "Buffer size too large (max 1GB)");
    #####:  166:        return NULL;
        -:  167:    }
        -:  168:    
        1:  169:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 returned 100%
        1:  170:    if (!buffer) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  171:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  172:                         "Failed to allocate ring buffer structure");
    #####:  173:        return NULL;
        -:  174:    }
        -:  175:    
        1:  176:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 returned 100%
        1:  177:    if (!buffer->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  178:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  179:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  180:                         "Failed to allocate ring buffer data");
    #####:  181:        return NULL;
        -:  182:    }
        -:  183:    
        1:  184:    buffer->element_size = element_size;
        1:  185:    buffer->capacity = capacity;
        1:  186:    atomic_store(&buffer->head, 0);
        1:  187:    atomic_store(&buffer->tail, 0);
        1:  188:    atomic_store(&buffer->count, 0);
        -:  189:    
        1:  190:    return buffer;
        -:  191:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 8 returned 100% blocks executed 76%
        8:  148:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
        8:  149:    if (element_size == 0 || capacity == 0) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        4:  150:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
        4:  151:        return NULL;
        -:  152:    }
        -:  153:    
        -:  154:    // Check for overflow in size calculation
        -:  155:    size_t total_size;
        4:  156:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  157:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  158:                         "Buffer size would overflow");
    #####:  159:        return NULL;
        -:  160:    }
        -:  161:    
        -:  162:    // Sanity check: limit to 1GB to prevent accidental huge allocations
        4:  163:    if (total_size > (1ULL << 30)) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        1:  164:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  165:                         "Buffer size too large (max 1GB)");
        1:  166:        return NULL;
        -:  167:    }
        -:  168:    
        3:  169:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 returned 100%
        3:  170:    if (!buffer) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  171:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  172:                         "Failed to allocate ring buffer structure");
    #####:  173:        return NULL;
        -:  174:    }
        -:  175:    
        3:  176:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 returned 100%
        3:  177:    if (!buffer->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  178:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  179:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  180:                         "Failed to allocate ring buffer data");
    #####:  181:        return NULL;
        -:  182:    }
        -:  183:    
        3:  184:    buffer->element_size = element_size;
        3:  185:    buffer->capacity = capacity;
        3:  186:    atomic_store(&buffer->head, 0);
        3:  187:    atomic_store(&buffer->tail, 0);
        3:  188:    atomic_store(&buffer->count, 0);
        -:  189:    
        3:  190:    return buffer;
        -:  191:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 2 returned 100% blocks executed 65%
        2:  148:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
        2:  149:    if (element_size == 0 || capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  150:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  151:        return NULL;
        -:  152:    }
        -:  153:    
        -:  154:    // Check for overflow in size calculation
        -:  155:    size_t total_size;
        2:  156:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  157:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  158:                         "Buffer size would overflow");
    #####:  159:        return NULL;
        -:  160:    }
        -:  161:    
        -:  162:    // Sanity check: limit to 1GB to prevent accidental huge allocations
        2:  163:    if (total_size > (1ULL << 30)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  164:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  165:                         "Buffer size too large (max 1GB)");
    #####:  166:        return NULL;
        -:  167:    }
        -:  168:    
        2:  169:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 returned 100%
        2:  170:    if (!buffer) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  171:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  172:                         "Failed to allocate ring buffer structure");
    #####:  173:        return NULL;
        -:  174:    }
        -:  175:    
        2:  176:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 returned 100%
        2:  177:    if (!buffer->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  178:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  179:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  180:                         "Failed to allocate ring buffer data");
    #####:  181:        return NULL;
        -:  182:    }
        -:  183:    
        2:  184:    buffer->element_size = element_size;
        2:  185:    buffer->capacity = capacity;
        2:  186:    atomic_store(&buffer->head, 0);
        2:  187:    atomic_store(&buffer->tail, 0);
        2:  188:    atomic_store(&buffer->count, 0);
        -:  189:    
        2:  190:    return buffer;
        -:  191:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 0 returned 0% blocks executed 0%
    #####:  148:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
    #####:  149:    if (element_size == 0 || capacity == 0) {
branch  0 never executed
branch  1 never executed
    #####:  150:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  151:        return NULL;
        -:  152:    }
        -:  153:    
        -:  154:    // Check for overflow in size calculation
        -:  155:    size_t total_size;
    #####:  156:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 never executed
branch  1 never executed
    #####:  157:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  158:                         "Buffer size would overflow");
    #####:  159:        return NULL;
        -:  160:    }
        -:  161:    
        -:  162:    // Sanity check: limit to 1GB to prevent accidental huge allocations
    #####:  163:    if (total_size > (1ULL << 30)) {
branch  0 never executed
branch  1 never executed
    #####:  164:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  165:                         "Buffer size too large (max 1GB)");
    #####:  166:        return NULL;
        -:  167:    }
        -:  168:    
    #####:  169:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 never executed
    #####:  170:    if (!buffer) {
branch  0 never executed
branch  1 never executed
    #####:  171:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  172:                         "Failed to allocate ring buffer structure");
    #####:  173:        return NULL;
        -:  174:    }
        -:  175:    
    #####:  176:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 never executed
    #####:  177:    if (!buffer->data) {
branch  0 never executed
branch  1 never executed
    #####:  178:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  179:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  180:                         "Failed to allocate ring buffer data");
    #####:  181:        return NULL;
        -:  182:    }
        -:  183:    
    #####:  184:    buffer->element_size = element_size;
    #####:  185:    buffer->capacity = capacity;
    #####:  186:    atomic_store(&buffer->head, 0);
    #####:  187:    atomic_store(&buffer->tail, 0);
    #####:  188:    atomic_store(&buffer->count, 0);
        -:  189:    
    #####:  190:    return buffer;
        -:  191:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 0 returned 0% blocks executed 0%
    #####:  148:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
    #####:  149:    if (element_size == 0 || capacity == 0) {
branch  0 never executed
branch  1 never executed
    #####:  150:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  151:        return NULL;
        -:  152:    }
        -:  153:    
        -:  154:    // Check for overflow in size calculation
        -:  155:    size_t total_size;
    #####:  156:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 never executed
branch  1 never executed
    #####:  157:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  158:                         "Buffer size would overflow");
    #####:  159:        return NULL;
        -:  160:    }
        -:  161:    
        -:  162:    // Sanity check: limit to 1GB to prevent accidental huge allocations
    #####:  163:    if (total_size > (1ULL << 30)) {
branch  0 never executed
branch  1 never executed
    #####:  164:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  165:                         "Buffer size too large (max 1GB)");
    #####:  166:        return NULL;
        -:  167:    }
        -:  168:    
    #####:  169:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 never executed
    #####:  170:    if (!buffer) {
branch  0 never executed
branch  1 never executed
    #####:  171:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  172:                         "Failed to allocate ring buffer structure");
    #####:  173:        return NULL;
        -:  174:    }
        -:  175:    
    #####:  176:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 never executed
    #####:  177:    if (!buffer->data) {
branch  0 never executed
branch  1 never executed
    #####:  178:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  179:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  180:                         "Failed to allocate ring buffer data");
    #####:  181:        return NULL;
        -:  182:    }
        -:  183:    
    #####:  184:    buffer->element_size = element_size;
    #####:  185:    buffer->capacity = capacity;
    #####:  186:    atomic_store(&buffer->head, 0);
    #####:  187:    atomic_store(&buffer->tail, 0);
    #####:  188:    atomic_store(&buffer->count, 0);
        -:  189:    
    #####:  190:    return buffer;
        -:  191:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 0 returned 0% blocks executed 0%
    #####:  148:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
    #####:  149:    if (element_size == 0 || capacity == 0) {
branch  0 never executed
branch  1 never executed
    #####:  150:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  151:        return NULL;
        -:  152:    }
        -:  153:    
        -:  154:    // Check for overflow in size calculation
        -:  155:    size_t total_size;
    #####:  156:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 never executed
branch  1 never executed
    #####:  157:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  158:                         "Buffer size would overflow");
    #####:  159:        return NULL;
        -:  160:    }
        -:  161:    
        -:  162:    // Sanity check: limit to 1GB to prevent accidental huge allocations
    #####:  163:    if (total_size > (1ULL << 30)) {
branch  0 never executed
branch  1 never executed
    #####:  164:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  165:                         "Buffer size too large (max 1GB)");
    #####:  166:        return NULL;
        -:  167:    }
        -:  168:    
    #####:  169:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 never executed
    #####:  170:    if (!buffer) {
branch  0 never executed
branch  1 never executed
    #####:  171:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  172:                         "Failed to allocate ring buffer structure");
    #####:  173:        return NULL;
        -:  174:    }
        -:  175:    
    #####:  176:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 never executed
    #####:  177:    if (!buffer->data) {
branch  0 never executed
branch  1 never executed
    #####:  178:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  179:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  180:                         "Failed to allocate ring buffer data");
    #####:  181:        return NULL;
        -:  182:    }
        -:  183:    
    #####:  184:    buffer->element_size = element_size;
    #####:  185:    buffer->capacity = capacity;
    #####:  186:    atomic_store(&buffer->head, 0);
    #####:  187:    atomic_store(&buffer->tail, 0);
    #####:  188:    atomic_store(&buffer->count, 0);
        -:  189:    
    #####:  190:    return buffer;
        -:  191:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 0 returned 0% blocks executed 0%
    #####:  148:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
    #####:  149:    if (element_size == 0 || capacity == 0) {
branch  0 never executed
branch  1 never executed
    #####:  150:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  151:        return NULL;
        -:  152:    }
        -:  153:    
        -:  154:    // Check for overflow in size calculation
        -:  155:    size_t total_size;
    #####:  156:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 never executed
branch  1 never executed
    #####:  157:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  158:                         "Buffer size would overflow");
    #####:  159:        return NULL;
        -:  160:    }
        -:  161:    
        -:  162:    // Sanity check: limit to 1GB to prevent accidental huge allocations
    #####:  163:    if (total_size > (1ULL << 30)) {
branch  0 never executed
branch  1 never executed
    #####:  164:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  165:                         "Buffer size too large (max 1GB)");
    #####:  166:        return NULL;
        -:  167:    }
        -:  168:    
    #####:  169:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 never executed
    #####:  170:    if (!buffer) {
branch  0 never executed
branch  1 never executed
    #####:  171:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  172:                         "Failed to allocate ring buffer structure");
    #####:  173:        return NULL;
        -:  174:    }
        -:  175:    
    #####:  176:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 never executed
    #####:  177:    if (!buffer->data) {
branch  0 never executed
branch  1 never executed
    #####:  178:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  179:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  180:                         "Failed to allocate ring buffer data");
    #####:  181:        return NULL;
        -:  182:    }
        -:  183:    
    #####:  184:    buffer->element_size = element_size;
    #####:  185:    buffer->capacity = capacity;
    #####:  186:    atomic_store(&buffer->head, 0);
    #####:  187:    atomic_store(&buffer->tail, 0);
    #####:  188:    atomic_store(&buffer->count, 0);
        -:  189:    
    #####:  190:    return buffer;
        -:  191:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 0 returned 0% blocks executed 0%
    #####:  148:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
    #####:  149:    if (element_size == 0 || capacity == 0) {
branch  0 never executed
branch  1 never executed
    #####:  150:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  151:        return NULL;
        -:  152:    }
        -:  153:    
        -:  154:    // Check for overflow in size calculation
        -:  155:    size_t total_size;
    #####:  156:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 never executed
branch  1 never executed
    #####:  157:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  158:                         "Buffer size would overflow");
    #####:  159:        return NULL;
        -:  160:    }
        -:  161:    
        -:  162:    // Sanity check: limit to 1GB to prevent accidental huge allocations
    #####:  163:    if (total_size > (1ULL << 30)) {
branch  0 never executed
branch  1 never executed
    #####:  164:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  165:                         "Buffer size too large (max 1GB)");
    #####:  166:        return NULL;
        -:  167:    }
        -:  168:    
    #####:  169:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 never executed
    #####:  170:    if (!buffer) {
branch  0 never executed
branch  1 never executed
    #####:  171:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  172:                         "Failed to allocate ring buffer structure");
    #####:  173:        return NULL;
        -:  174:    }
        -:  175:    
    #####:  176:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 never executed
    #####:  177:    if (!buffer->data) {
branch  0 never executed
branch  1 never executed
    #####:  178:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  179:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  180:                         "Failed to allocate ring buffer data");
    #####:  181:        return NULL;
        -:  182:    }
        -:  183:    
    #####:  184:    buffer->element_size = element_size;
    #####:  185:    buffer->capacity = capacity;
    #####:  186:    atomic_store(&buffer->head, 0);
    #####:  187:    atomic_store(&buffer->tail, 0);
    #####:  188:    atomic_store(&buffer->count, 0);
        -:  189:    
    #####:  190:    return buffer;
        -:  191:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 0 returned 0% blocks executed 0%
    #####:  148:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
    #####:  149:    if (element_size == 0 || capacity == 0) {
branch  0 never executed
branch  1 never executed
    #####:  150:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  151:        return NULL;
        -:  152:    }
        -:  153:    
        -:  154:    // Check for overflow in size calculation
        -:  155:    size_t total_size;
    #####:  156:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 never executed
branch  1 never executed
    #####:  157:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  158:                         "Buffer size would overflow");
    #####:  159:        return NULL;
        -:  160:    }
        -:  161:    
        -:  162:    // Sanity check: limit to 1GB to prevent accidental huge allocations
    #####:  163:    if (total_size > (1ULL << 30)) {
branch  0 never executed
branch  1 never executed
    #####:  164:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  165:                         "Buffer size too large (max 1GB)");
    #####:  166:        return NULL;
        -:  167:    }
        -:  168:    
    #####:  169:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 never executed
    #####:  170:    if (!buffer) {
branch  0 never executed
branch  1 never executed
    #####:  171:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  172:                         "Failed to allocate ring buffer structure");
    #####:  173:        return NULL;
        -:  174:    }
        -:  175:    
    #####:  176:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 never executed
    #####:  177:    if (!buffer->data) {
branch  0 never executed
branch  1 never executed
    #####:  178:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  179:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  180:                         "Failed to allocate ring buffer data");
    #####:  181:        return NULL;
        -:  182:    }
        -:  183:    
    #####:  184:    buffer->element_size = element_size;
    #####:  185:    buffer->capacity = capacity;
    #####:  186:    atomic_store(&buffer->head, 0);
    #####:  187:    atomic_store(&buffer->tail, 0);
    #####:  188:    atomic_store(&buffer->count, 0);
        -:  189:    
    #####:  190:    return buffer;
        -:  191:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 1 returned 100% blocks executed 65%
        1:  148:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
        1:  149:    if (element_size == 0 || capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  150:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  151:        return NULL;
        -:  152:    }
        -:  153:    
        -:  154:    // Check for overflow in size calculation
        -:  155:    size_t total_size;
        1:  156:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  157:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  158:                         "Buffer size would overflow");
    #####:  159:        return NULL;
        -:  160:    }
        -:  161:    
        -:  162:    // Sanity check: limit to 1GB to prevent accidental huge allocations
        1:  163:    if (total_size > (1ULL << 30)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  164:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  165:                         "Buffer size too large (max 1GB)");
    #####:  166:        return NULL;
        -:  167:    }
        -:  168:    
        1:  169:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 returned 100%
        1:  170:    if (!buffer) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  171:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  172:                         "Failed to allocate ring buffer structure");
    #####:  173:        return NULL;
        -:  174:    }
        -:  175:    
        1:  176:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 returned 100%
        1:  177:    if (!buffer->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  178:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  179:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  180:                         "Failed to allocate ring buffer data");
    #####:  181:        return NULL;
        -:  182:    }
        -:  183:    
        1:  184:    buffer->element_size = element_size;
        1:  185:    buffer->capacity = capacity;
        1:  186:    atomic_store(&buffer->head, 0);
        1:  187:    atomic_store(&buffer->tail, 0);
        1:  188:    atomic_store(&buffer->count, 0);
        -:  189:    
        1:  190:    return buffer;
        -:  191:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 1 returned 100% blocks executed 65%
        1:  148:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
        1:  149:    if (element_size == 0 || capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  150:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  151:        return NULL;
        -:  152:    }
        -:  153:    
        -:  154:    // Check for overflow in size calculation
        -:  155:    size_t total_size;
        1:  156:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  157:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  158:                         "Buffer size would overflow");
    #####:  159:        return NULL;
        -:  160:    }
        -:  161:    
        -:  162:    // Sanity check: limit to 1GB to prevent accidental huge allocations
        1:  163:    if (total_size > (1ULL << 30)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  164:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  165:                         "Buffer size too large (max 1GB)");
    #####:  166:        return NULL;
        -:  167:    }
        -:  168:    
        1:  169:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 returned 100%
        1:  170:    if (!buffer) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  171:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  172:                         "Failed to allocate ring buffer structure");
    #####:  173:        return NULL;
        -:  174:    }
        -:  175:    
        1:  176:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 returned 100%
        1:  177:    if (!buffer->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  178:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  179:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  180:                         "Failed to allocate ring buffer data");
    #####:  181:        return NULL;
        -:  182:    }
        -:  183:    
        1:  184:    buffer->element_size = element_size;
        1:  185:    buffer->capacity = capacity;
        1:  186:    atomic_store(&buffer->head, 0);
        1:  187:    atomic_store(&buffer->tail, 0);
        1:  188:    atomic_store(&buffer->count, 0);
        -:  189:    
        1:  190:    return buffer;
        -:  191:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 0 returned 0% blocks executed 0%
    #####:  148:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
    #####:  149:    if (element_size == 0 || capacity == 0) {
branch  0 never executed
branch  1 never executed
    #####:  150:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  151:        return NULL;
        -:  152:    }
        -:  153:    
        -:  154:    // Check for overflow in size calculation
        -:  155:    size_t total_size;
    #####:  156:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 never executed
branch  1 never executed
    #####:  157:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  158:                         "Buffer size would overflow");
    #####:  159:        return NULL;
        -:  160:    }
        -:  161:    
        -:  162:    // Sanity check: limit to 1GB to prevent accidental huge allocations
    #####:  163:    if (total_size > (1ULL << 30)) {
branch  0 never executed
branch  1 never executed
    #####:  164:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  165:                         "Buffer size too large (max 1GB)");
    #####:  166:        return NULL;
        -:  167:    }
        -:  168:    
    #####:  169:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 never executed
    #####:  170:    if (!buffer) {
branch  0 never executed
branch  1 never executed
    #####:  171:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  172:                         "Failed to allocate ring buffer structure");
    #####:  173:        return NULL;
        -:  174:    }
        -:  175:    
    #####:  176:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 never executed
    #####:  177:    if (!buffer->data) {
branch  0 never executed
branch  1 never executed
    #####:  178:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  179:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  180:                         "Failed to allocate ring buffer data");
    #####:  181:        return NULL;
        -:  182:    }
        -:  183:    
    #####:  184:    buffer->element_size = element_size;
    #####:  185:    buffer->capacity = capacity;
    #####:  186:    atomic_store(&buffer->head, 0);
    #####:  187:    atomic_store(&buffer->tail, 0);
    #####:  188:    atomic_store(&buffer->count, 0);
        -:  189:    
    #####:  190:    return buffer;
        -:  191:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 0 returned 0% blocks executed 0%
    #####:  148:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
    #####:  149:    if (element_size == 0 || capacity == 0) {
branch  0 never executed
branch  1 never executed
    #####:  150:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  151:        return NULL;
        -:  152:    }
        -:  153:    
        -:  154:    // Check for overflow in size calculation
        -:  155:    size_t total_size;
    #####:  156:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 never executed
branch  1 never executed
    #####:  157:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  158:                         "Buffer size would overflow");
    #####:  159:        return NULL;
        -:  160:    }
        -:  161:    
        -:  162:    // Sanity check: limit to 1GB to prevent accidental huge allocations
    #####:  163:    if (total_size > (1ULL << 30)) {
branch  0 never executed
branch  1 never executed
    #####:  164:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  165:                         "Buffer size too large (max 1GB)");
    #####:  166:        return NULL;
        -:  167:    }
        -:  168:    
    #####:  169:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 never executed
    #####:  170:    if (!buffer) {
branch  0 never executed
branch  1 never executed
    #####:  171:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  172:                         "Failed to allocate ring buffer structure");
    #####:  173:        return NULL;
        -:  174:    }
        -:  175:    
    #####:  176:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 never executed
    #####:  177:    if (!buffer->data) {
branch  0 never executed
branch  1 never executed
    #####:  178:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  179:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  180:                         "Failed to allocate ring buffer data");
    #####:  181:        return NULL;
        -:  182:    }
        -:  183:    
    #####:  184:    buffer->element_size = element_size;
    #####:  185:    buffer->capacity = capacity;
    #####:  186:    atomic_store(&buffer->head, 0);
    #####:  187:    atomic_store(&buffer->tail, 0);
    #####:  188:    atomic_store(&buffer->count, 0);
        -:  189:    
    #####:  190:    return buffer;
        -:  191:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 0 returned 0% blocks executed 0%
    #####:  148:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
    #####:  149:    if (element_size == 0 || capacity == 0) {
branch  0 never executed
branch  1 never executed
    #####:  150:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  151:        return NULL;
        -:  152:    }
        -:  153:    
        -:  154:    // Check for overflow in size calculation
        -:  155:    size_t total_size;
    #####:  156:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 never executed
branch  1 never executed
    #####:  157:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  158:                         "Buffer size would overflow");
    #####:  159:        return NULL;
        -:  160:    }
        -:  161:    
        -:  162:    // Sanity check: limit to 1GB to prevent accidental huge allocations
    #####:  163:    if (total_size > (1ULL << 30)) {
branch  0 never executed
branch  1 never executed
    #####:  164:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  165:                         "Buffer size too large (max 1GB)");
    #####:  166:        return NULL;
        -:  167:    }
        -:  168:    
    #####:  169:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 never executed
    #####:  170:    if (!buffer) {
branch  0 never executed
branch  1 never executed
    #####:  171:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  172:                         "Failed to allocate ring buffer structure");
    #####:  173:        return NULL;
        -:  174:    }
        -:  175:    
    #####:  176:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 never executed
    #####:  177:    if (!buffer->data) {
branch  0 never executed
branch  1 never executed
    #####:  178:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  179:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  180:                         "Failed to allocate ring buffer data");
    #####:  181:        return NULL;
        -:  182:    }
        -:  183:    
    #####:  184:    buffer->element_size = element_size;
    #####:  185:    buffer->capacity = capacity;
    #####:  186:    atomic_store(&buffer->head, 0);
    #####:  187:    atomic_store(&buffer->tail, 0);
    #####:  188:    atomic_store(&buffer->count, 0);
        -:  189:    
    #####:  190:    return buffer;
        -:  191:}
------------------
        -:  192:
       8*:  193:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
       8*:  194:    if (!buffer) return;
        -:  195:    
       8*:  196:    mercury_aligned_free(buffer->data);
       8*:  197:    mercury_aligned_free(buffer);
        -:  198:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 1 returned 100% blocks executed 100%
        1:  193:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
        1:  194:    if (!buffer) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  195:    
        1:  196:    mercury_aligned_free(buffer->data);
call    0 returned 100%
        1:  197:    mercury_aligned_free(buffer);
call    0 returned 100%
        -:  198:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 3 returned 100% blocks executed 100%
        3:  193:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
        3:  194:    if (!buffer) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  195:    
        3:  196:    mercury_aligned_free(buffer->data);
call    0 returned 100%
        3:  197:    mercury_aligned_free(buffer);
call    0 returned 100%
        -:  198:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 2 returned 100% blocks executed 100%
        2:  193:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
        2:  194:    if (!buffer) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  195:    
        2:  196:    mercury_aligned_free(buffer->data);
call    0 returned 100%
        2:  197:    mercury_aligned_free(buffer);
call    0 returned 100%
        -:  198:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 0 returned 0% blocks executed 0%
    #####:  193:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
    #####:  194:    if (!buffer) return;
branch  0 never executed
branch  1 never executed
        -:  195:    
    #####:  196:    mercury_aligned_free(buffer->data);
call    0 never executed
    #####:  197:    mercury_aligned_free(buffer);
call    0 never executed
        -:  198:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 0 returned 0% blocks executed 0%
    #####:  193:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
    #####:  194:    if (!buffer) return;
branch  0 never executed
branch  1 never executed
        -:  195:    
    #####:  196:    mercury_aligned_free(buffer->data);
call    0 never executed
    #####:  197:    mercury_aligned_free(buffer);
call    0 never executed
        -:  198:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 0 returned 0% blocks executed 0%
    #####:  193:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
    #####:  194:    if (!buffer) return;
branch  0 never executed
branch  1 never executed
        -:  195:    
    #####:  196:    mercury_aligned_free(buffer->data);
call    0 never executed
    #####:  197:    mercury_aligned_free(buffer);
call    0 never executed
        -:  198:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 0 returned 0% blocks executed 0%
    #####:  193:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
    #####:  194:    if (!buffer) return;
branch  0 never executed
branch  1 never executed
        -:  195:    
    #####:  196:    mercury_aligned_free(buffer->data);
call    0 never executed
    #####:  197:    mercury_aligned_free(buffer);
call    0 never executed
        -:  198:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 0 returned 0% blocks executed 0%
    #####:  193:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
    #####:  194:    if (!buffer) return;
branch  0 never executed
branch  1 never executed
        -:  195:    
    #####:  196:    mercury_aligned_free(buffer->data);
call    0 never executed
    #####:  197:    mercury_aligned_free(buffer);
call    0 never executed
        -:  198:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 0 returned 0% blocks executed 0%
    #####:  193:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
    #####:  194:    if (!buffer) return;
branch  0 never executed
branch  1 never executed
        -:  195:    
    #####:  196:    mercury_aligned_free(buffer->data);
call    0 never executed
    #####:  197:    mercury_aligned_free(buffer);
call    0 never executed
        -:  198:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 1 returned 100% blocks executed 100%
        1:  193:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
        1:  194:    if (!buffer) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  195:    
        1:  196:    mercury_aligned_free(buffer->data);
call    0 returned 100%
        1:  197:    mercury_aligned_free(buffer);
call    0 returned 100%
        -:  198:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 1 returned 100% blocks executed 100%
        1:  193:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
        1:  194:    if (!buffer) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  195:    
        1:  196:    mercury_aligned_free(buffer->data);
call    0 returned 100%
        1:  197:    mercury_aligned_free(buffer);
call    0 returned 100%
        -:  198:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 0 returned 0% blocks executed 0%
    #####:  193:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
    #####:  194:    if (!buffer) return;
branch  0 never executed
branch  1 never executed
        -:  195:    
    #####:  196:    mercury_aligned_free(buffer->data);
call    0 never executed
    #####:  197:    mercury_aligned_free(buffer);
call    0 never executed
        -:  198:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 0 returned 0% blocks executed 0%
    #####:  193:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
    #####:  194:    if (!buffer) return;
branch  0 never executed
branch  1 never executed
        -:  195:    
    #####:  196:    mercury_aligned_free(buffer->data);
call    0 never executed
    #####:  197:    mercury_aligned_free(buffer);
call    0 never executed
        -:  198:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 0 returned 0% blocks executed 0%
    #####:  193:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
    #####:  194:    if (!buffer) return;
branch  0 never executed
branch  1 never executed
        -:  195:    
    #####:  196:    mercury_aligned_free(buffer->data);
call    0 never executed
    #####:  197:    mercury_aligned_free(buffer);
call    0 never executed
        -:  198:}
------------------
        -:  199:
    4397*:  200:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    4397*:  201:    if (MERCURY_UNLIKELY(!buffer || !element)) {
        -:  202:        return false;
        -:  203:    }
        -:  204:    
        -:  205:    // Debug: verify buffer integrity
        -:  206:    MERCURY_VERIFY_BUFFER(buffer);
        -:  207:    
        -:  208:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  209:    size_t current_count, new_count;
        -:  210:    do {
    4397*:  211:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    4397*:  212:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
        -:  213:            return false;  // Buffer is full
        -:  214:        }
    3388*:  215:        new_count = current_count + 1;
    3388*:  216:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
        -:  217:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  218:    
        -:  219:    // Now we have successfully reserved a slot, get our position
    3388*:  220:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    3388*:  221:    head = head % buffer->capacity;  // Wrap around
        -:  222:    
        -:  223:    // Copy data to reserved slot
    3388*:  224:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  225:    
        -:  226:    // Prefetch destination for write
    3388*:  227:    MERCURY_PREFETCH_WRITE(dest);
        -:  228:    
        -:  229:    // Prefetch next few slots for sequential writes (cache warming)
    3388*:  230:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
    3378*:  231:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
        -:  232:    }
    3388*:  233:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
    3370*:  234:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
        -:  235:    }
        -:  236:    
        -:  237:    // Optimized copy based on element size
    3388*:  238:    if (buffer->element_size <= 8) {
        -:  239:        // Fast path for small elements (like ints, pointers)
        -:  240:        memcpy(dest, element, buffer->element_size);
    3182*:  241:    } else if (buffer->element_size >= 32) {
        -:  242:        // SIMD path for larger elements
    3182*:  243:        mercury_memcpy_simd(dest, element, buffer->element_size);
        -:  244:    } else {
        -:  245:        // Regular memcpy for medium elements
        -:  246:        memcpy(dest, element, buffer->element_size);
        -:  247:    }
        -:  248:    
        -:  249:    // Count was already updated atomically in the CAS loop above
        -:  250:    
        -:  251:    return true;
        -:  252:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 205 returned 100% blocks executed 80%
      205:  200:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
      205:  201:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  202:        return false;
        -:  203:    }
        -:  204:    
        -:  205:    // Debug: verify buffer integrity
        -:  206:    MERCURY_VERIFY_BUFFER(buffer);
        -:  207:    
        -:  208:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  209:    size_t current_count, new_count;
        -:  210:    do {
      205:  211:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
      205:  212:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
        -:  213:            return false;  // Buffer is full
        -:  214:        }
      200:  215:        new_count = current_count + 1;
      200:  216:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  217:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  218:    
        -:  219:    // Now we have successfully reserved a slot, get our position
      200:  220:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
      200:  221:    head = head % buffer->capacity;  // Wrap around
        -:  222:    
        -:  223:    // Copy data to reserved slot
      200:  224:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  225:    
        -:  226:    // Prefetch destination for write
      200:  227:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  228:    
        -:  229:    // Prefetch next few slots for sequential writes (cache warming)
      200:  230:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
      197:  231:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 returned 100%
        -:  232:    }
      200:  233:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
      194:  234:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 returned 100%
        -:  235:    }
        -:  236:    
        -:  237:    // Optimized copy based on element size
      200:  238:    if (buffer->element_size <= 8) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  239:        // Fast path for small elements (like ints, pointers)
        -:  240:        memcpy(dest, element, buffer->element_size);
    #####:  241:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  242:        // SIMD path for larger elements
    #####:  243:        mercury_memcpy_simd(dest, element, buffer->element_size);
call    0 never executed
        -:  244:    } else {
        -:  245:        // Regular memcpy for medium elements
        -:  246:        memcpy(dest, element, buffer->element_size);
        -:  247:    }
        -:  248:    
        -:  249:    // Count was already updated atomically in the CAS loop above
        -:  250:    
        -:  251:    return true;
        -:  252:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 11 returned 100% blocks executed 93%
       11:  200:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
       11:  201:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  202:        return false;
        -:  203:    }
        -:  204:    
        -:  205:    // Debug: verify buffer integrity
        -:  206:    MERCURY_VERIFY_BUFFER(buffer);
        -:  207:    
        -:  208:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  209:    size_t current_count, new_count;
        -:  210:    do {
       11:  211:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
       11:  212:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
        -:  213:            return false;  // Buffer is full
        -:  214:        }
        8:  215:        new_count = current_count + 1;
        8:  216:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  217:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  218:    
        -:  219:    // Now we have successfully reserved a slot, get our position
        8:  220:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
        8:  221:    head = head % buffer->capacity;  // Wrap around
        -:  222:    
        -:  223:    // Copy data to reserved slot
        8:  224:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  225:    
        -:  226:    // Prefetch destination for write
        8:  227:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  228:    
        -:  229:    // Prefetch next few slots for sequential writes (cache warming)
        8:  230:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
        5:  231:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 returned 100%
        -:  232:    }
        8:  233:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
        3:  234:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 returned 100%
        -:  235:    }
        -:  236:    
        -:  237:    // Optimized copy based on element size
        8:  238:    if (buffer->element_size <= 8) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
        -:  239:        // Fast path for small elements (like ints, pointers)
        -:  240:        memcpy(dest, element, buffer->element_size);
        3:  241:    } else if (buffer->element_size >= 32) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  242:        // SIMD path for larger elements
        3:  243:        mercury_memcpy_simd(dest, element, buffer->element_size);
call    0 returned 100%
        -:  244:    } else {
        -:  245:        // Regular memcpy for medium elements
        -:  246:        memcpy(dest, element, buffer->element_size);
        -:  247:    }
        -:  248:    
        -:  249:    // Count was already updated atomically in the CAS loop above
        -:  250:    
        -:  251:    return true;
        -:  252:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 3 returned 100% blocks executed 93%
        3:  200:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
        3:  201:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  202:        return false;
        -:  203:    }
        -:  204:    
        -:  205:    // Debug: verify buffer integrity
        -:  206:    MERCURY_VERIFY_BUFFER(buffer);
        -:  207:    
        -:  208:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  209:    size_t current_count, new_count;
        -:  210:    do {
        3:  211:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
        3:  212:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -:  213:            return false;  // Buffer is full
        -:  214:        }
        2:  215:        new_count = current_count + 1;
        2:  216:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  217:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  218:    
        -:  219:    // Now we have successfully reserved a slot, get our position
        2:  220:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
        2:  221:    head = head % buffer->capacity;  // Wrap around
        -:  222:    
        -:  223:    // Copy data to reserved slot
        2:  224:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  225:    
        -:  226:    // Prefetch destination for write
        2:  227:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  228:    
        -:  229:    // Prefetch next few slots for sequential writes (cache warming)
        2:  230:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:  231:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 returned 100%
        -:  232:    }
        2:  233:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:  234:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 returned 100%
        -:  235:    }
        -:  236:    
        -:  237:    // Optimized copy based on element size
        2:  238:    if (buffer->element_size <= 8) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  239:        // Fast path for small elements (like ints, pointers)
        -:  240:        memcpy(dest, element, buffer->element_size);
        1:  241:    } else if (buffer->element_size >= 32) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  242:        // SIMD path for larger elements
        1:  243:        mercury_memcpy_simd(dest, element, buffer->element_size);
call    0 returned 100%
        -:  244:    } else {
        -:  245:        // Regular memcpy for medium elements
        -:  246:        memcpy(dest, element, buffer->element_size);
        -:  247:    }
        -:  248:    
        -:  249:    // Count was already updated atomically in the CAS loop above
        -:  250:    
        -:  251:    return true;
        -:  252:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 0 returned 0% blocks executed 0%
    #####:  200:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    #####:  201:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  202:        return false;
        -:  203:    }
        -:  204:    
        -:  205:    // Debug: verify buffer integrity
        -:  206:    MERCURY_VERIFY_BUFFER(buffer);
        -:  207:    
        -:  208:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  209:    size_t current_count, new_count;
        -:  210:    do {
    #####:  211:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  212:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  213:            return false;  // Buffer is full
        -:  214:        }
    #####:  215:        new_count = current_count + 1;
    #####:  216:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  217:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  218:    
        -:  219:    // Now we have successfully reserved a slot, get our position
    #####:  220:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    #####:  221:    head = head % buffer->capacity;  // Wrap around
        -:  222:    
        -:  223:    // Copy data to reserved slot
    #####:  224:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  225:    
        -:  226:    // Prefetch destination for write
    #####:  227:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  228:    
        -:  229:    // Prefetch next few slots for sequential writes (cache warming)
    #####:  230:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  231:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 never executed
        -:  232:    }
    #####:  233:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  234:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 never executed
        -:  235:    }
        -:  236:    
        -:  237:    // Optimized copy based on element size
    #####:  238:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  239:        // Fast path for small elements (like ints, pointers)
        -:  240:        memcpy(dest, element, buffer->element_size);
    #####:  241:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  242:        // SIMD path for larger elements
    #####:  243:        mercury_memcpy_simd(dest, element, buffer->element_size);
call    0 never executed
        -:  244:    } else {
        -:  245:        // Regular memcpy for medium elements
        -:  246:        memcpy(dest, element, buffer->element_size);
        -:  247:    }
        -:  248:    
        -:  249:    // Count was already updated atomically in the CAS loop above
        -:  250:    
        -:  251:    return true;
        -:  252:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 0 returned 0% blocks executed 0%
    #####:  200:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    #####:  201:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  202:        return false;
        -:  203:    }
        -:  204:    
        -:  205:    // Debug: verify buffer integrity
        -:  206:    MERCURY_VERIFY_BUFFER(buffer);
        -:  207:    
        -:  208:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  209:    size_t current_count, new_count;
        -:  210:    do {
    #####:  211:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  212:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  213:            return false;  // Buffer is full
        -:  214:        }
    #####:  215:        new_count = current_count + 1;
    #####:  216:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  217:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  218:    
        -:  219:    // Now we have successfully reserved a slot, get our position
    #####:  220:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    #####:  221:    head = head % buffer->capacity;  // Wrap around
        -:  222:    
        -:  223:    // Copy data to reserved slot
    #####:  224:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  225:    
        -:  226:    // Prefetch destination for write
    #####:  227:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  228:    
        -:  229:    // Prefetch next few slots for sequential writes (cache warming)
    #####:  230:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  231:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 never executed
        -:  232:    }
    #####:  233:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  234:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 never executed
        -:  235:    }
        -:  236:    
        -:  237:    // Optimized copy based on element size
    #####:  238:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  239:        // Fast path for small elements (like ints, pointers)
        -:  240:        memcpy(dest, element, buffer->element_size);
    #####:  241:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  242:        // SIMD path for larger elements
    #####:  243:        mercury_memcpy_simd(dest, element, buffer->element_size);
call    0 never executed
        -:  244:    } else {
        -:  245:        // Regular memcpy for medium elements
        -:  246:        memcpy(dest, element, buffer->element_size);
        -:  247:    }
        -:  248:    
        -:  249:    // Count was already updated atomically in the CAS loop above
        -:  250:    
        -:  251:    return true;
        -:  252:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 0 returned 0% blocks executed 0%
    #####:  200:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    #####:  201:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  202:        return false;
        -:  203:    }
        -:  204:    
        -:  205:    // Debug: verify buffer integrity
        -:  206:    MERCURY_VERIFY_BUFFER(buffer);
        -:  207:    
        -:  208:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  209:    size_t current_count, new_count;
        -:  210:    do {
    #####:  211:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  212:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  213:            return false;  // Buffer is full
        -:  214:        }
    #####:  215:        new_count = current_count + 1;
    #####:  216:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  217:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  218:    
        -:  219:    // Now we have successfully reserved a slot, get our position
    #####:  220:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    #####:  221:    head = head % buffer->capacity;  // Wrap around
        -:  222:    
        -:  223:    // Copy data to reserved slot
    #####:  224:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  225:    
        -:  226:    // Prefetch destination for write
    #####:  227:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  228:    
        -:  229:    // Prefetch next few slots for sequential writes (cache warming)
    #####:  230:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  231:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 never executed
        -:  232:    }
    #####:  233:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  234:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 never executed
        -:  235:    }
        -:  236:    
        -:  237:    // Optimized copy based on element size
    #####:  238:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  239:        // Fast path for small elements (like ints, pointers)
        -:  240:        memcpy(dest, element, buffer->element_size);
    #####:  241:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  242:        // SIMD path for larger elements
    #####:  243:        mercury_memcpy_simd(dest, element, buffer->element_size);
call    0 never executed
        -:  244:    } else {
        -:  245:        // Regular memcpy for medium elements
        -:  246:        memcpy(dest, element, buffer->element_size);
        -:  247:    }
        -:  248:    
        -:  249:    // Count was already updated atomically in the CAS loop above
        -:  250:    
        -:  251:    return true;
        -:  252:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 0 returned 0% blocks executed 0%
    #####:  200:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    #####:  201:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  202:        return false;
        -:  203:    }
        -:  204:    
        -:  205:    // Debug: verify buffer integrity
        -:  206:    MERCURY_VERIFY_BUFFER(buffer);
        -:  207:    
        -:  208:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  209:    size_t current_count, new_count;
        -:  210:    do {
    #####:  211:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  212:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  213:            return false;  // Buffer is full
        -:  214:        }
    #####:  215:        new_count = current_count + 1;
    #####:  216:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  217:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  218:    
        -:  219:    // Now we have successfully reserved a slot, get our position
    #####:  220:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    #####:  221:    head = head % buffer->capacity;  // Wrap around
        -:  222:    
        -:  223:    // Copy data to reserved slot
    #####:  224:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  225:    
        -:  226:    // Prefetch destination for write
    #####:  227:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  228:    
        -:  229:    // Prefetch next few slots for sequential writes (cache warming)
    #####:  230:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  231:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 never executed
        -:  232:    }
    #####:  233:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  234:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 never executed
        -:  235:    }
        -:  236:    
        -:  237:    // Optimized copy based on element size
    #####:  238:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  239:        // Fast path for small elements (like ints, pointers)
        -:  240:        memcpy(dest, element, buffer->element_size);
    #####:  241:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  242:        // SIMD path for larger elements
    #####:  243:        mercury_memcpy_simd(dest, element, buffer->element_size);
call    0 never executed
        -:  244:    } else {
        -:  245:        // Regular memcpy for medium elements
        -:  246:        memcpy(dest, element, buffer->element_size);
        -:  247:    }
        -:  248:    
        -:  249:    // Count was already updated atomically in the CAS loop above
        -:  250:    
        -:  251:    return true;
        -:  252:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 0 returned 0% blocks executed 0%
    #####:  200:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    #####:  201:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  202:        return false;
        -:  203:    }
        -:  204:    
        -:  205:    // Debug: verify buffer integrity
        -:  206:    MERCURY_VERIFY_BUFFER(buffer);
        -:  207:    
        -:  208:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  209:    size_t current_count, new_count;
        -:  210:    do {
    #####:  211:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  212:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  213:            return false;  // Buffer is full
        -:  214:        }
    #####:  215:        new_count = current_count + 1;
    #####:  216:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  217:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  218:    
        -:  219:    // Now we have successfully reserved a slot, get our position
    #####:  220:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    #####:  221:    head = head % buffer->capacity;  // Wrap around
        -:  222:    
        -:  223:    // Copy data to reserved slot
    #####:  224:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  225:    
        -:  226:    // Prefetch destination for write
    #####:  227:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  228:    
        -:  229:    // Prefetch next few slots for sequential writes (cache warming)
    #####:  230:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  231:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 never executed
        -:  232:    }
    #####:  233:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  234:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 never executed
        -:  235:    }
        -:  236:    
        -:  237:    // Optimized copy based on element size
    #####:  238:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  239:        // Fast path for small elements (like ints, pointers)
        -:  240:        memcpy(dest, element, buffer->element_size);
    #####:  241:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  242:        // SIMD path for larger elements
    #####:  243:        mercury_memcpy_simd(dest, element, buffer->element_size);
call    0 never executed
        -:  244:    } else {
        -:  245:        // Regular memcpy for medium elements
        -:  246:        memcpy(dest, element, buffer->element_size);
        -:  247:    }
        -:  248:    
        -:  249:    // Count was already updated atomically in the CAS loop above
        -:  250:    
        -:  251:    return true;
        -:  252:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 0 returned 0% blocks executed 0%
    #####:  200:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    #####:  201:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  202:        return false;
        -:  203:    }
        -:  204:    
        -:  205:    // Debug: verify buffer integrity
        -:  206:    MERCURY_VERIFY_BUFFER(buffer);
        -:  207:    
        -:  208:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  209:    size_t current_count, new_count;
        -:  210:    do {
    #####:  211:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  212:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  213:            return false;  // Buffer is full
        -:  214:        }
    #####:  215:        new_count = current_count + 1;
    #####:  216:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  217:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  218:    
        -:  219:    // Now we have successfully reserved a slot, get our position
    #####:  220:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    #####:  221:    head = head % buffer->capacity;  // Wrap around
        -:  222:    
        -:  223:    // Copy data to reserved slot
    #####:  224:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  225:    
        -:  226:    // Prefetch destination for write
    #####:  227:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  228:    
        -:  229:    // Prefetch next few slots for sequential writes (cache warming)
    #####:  230:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  231:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 never executed
        -:  232:    }
    #####:  233:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  234:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 never executed
        -:  235:    }
        -:  236:    
        -:  237:    // Optimized copy based on element size
    #####:  238:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  239:        // Fast path for small elements (like ints, pointers)
        -:  240:        memcpy(dest, element, buffer->element_size);
    #####:  241:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  242:        // SIMD path for larger elements
    #####:  243:        mercury_memcpy_simd(dest, element, buffer->element_size);
call    0 never executed
        -:  244:    } else {
        -:  245:        // Regular memcpy for medium elements
        -:  246:        memcpy(dest, element, buffer->element_size);
        -:  247:    }
        -:  248:    
        -:  249:    // Count was already updated atomically in the CAS loop above
        -:  250:    
        -:  251:    return true;
        -:  252:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 73 returned 100% blocks executed 87%
       73:  200:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
       73:  201:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  202:        return false;
        -:  203:    }
        -:  204:    
        -:  205:    // Debug: verify buffer integrity
        -:  206:    MERCURY_VERIFY_BUFFER(buffer);
        -:  207:    
        -:  208:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  209:    size_t current_count, new_count;
        -:  210:    do {
       73:  211:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
       73:  212:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  213:            return false;  // Buffer is full
        -:  214:        }
       73:  215:        new_count = current_count + 1;
       73:  216:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  217:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  218:    
        -:  219:    // Now we have successfully reserved a slot, get our position
       73:  220:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
       73:  221:    head = head % buffer->capacity;  // Wrap around
        -:  222:    
        -:  223:    // Copy data to reserved slot
       73:  224:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  225:    
        -:  226:    // Prefetch destination for write
       73:  227:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  228:    
        -:  229:    // Prefetch next few slots for sequential writes (cache warming)
       73:  230:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       73:  231:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 returned 100%
        -:  232:    }
       73:  233:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       73:  234:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 returned 100%
        -:  235:    }
        -:  236:    
        -:  237:    // Optimized copy based on element size
       73:  238:    if (buffer->element_size <= 8) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  239:        // Fast path for small elements (like ints, pointers)
        -:  240:        memcpy(dest, element, buffer->element_size);
       73:  241:    } else if (buffer->element_size >= 32) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  242:        // SIMD path for larger elements
       73:  243:        mercury_memcpy_simd(dest, element, buffer->element_size);
call    0 returned 100%
        -:  244:    } else {
        -:  245:        // Regular memcpy for medium elements
        -:  246:        memcpy(dest, element, buffer->element_size);
        -:  247:    }
        -:  248:    
        -:  249:    // Count was already updated atomically in the CAS loop above
        -:  250:    
        -:  251:    return true;
        -:  252:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 4105 returned 100% blocks executed 87%
     4105:  200:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
     4105:  201:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  202:        return false;
        -:  203:    }
        -:  204:    
        -:  205:    // Debug: verify buffer integrity
        -:  206:    MERCURY_VERIFY_BUFFER(buffer);
        -:  207:    
        -:  208:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  209:    size_t current_count, new_count;
        -:  210:    do {
     4105:  211:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
     4105:  212:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
        -:  213:            return false;  // Buffer is full
        -:  214:        }
     3105:  215:        new_count = current_count + 1;
     3105:  216:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  217:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  218:    
        -:  219:    // Now we have successfully reserved a slot, get our position
     3105:  220:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
     3105:  221:    head = head % buffer->capacity;  // Wrap around
        -:  222:    
        -:  223:    // Copy data to reserved slot
     3105:  224:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  225:    
        -:  226:    // Prefetch destination for write
     3105:  227:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  228:    
        -:  229:    // Prefetch next few slots for sequential writes (cache warming)
     3105:  230:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     3102:  231:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 returned 100%
        -:  232:    }
     3105:  233:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     3099:  234:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 returned 100%
        -:  235:    }
        -:  236:    
        -:  237:    // Optimized copy based on element size
     3105:  238:    if (buffer->element_size <= 8) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  239:        // Fast path for small elements (like ints, pointers)
        -:  240:        memcpy(dest, element, buffer->element_size);
     3105:  241:    } else if (buffer->element_size >= 32) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  242:        // SIMD path for larger elements
     3105:  243:        mercury_memcpy_simd(dest, element, buffer->element_size);
call    0 returned 100%
        -:  244:    } else {
        -:  245:        // Regular memcpy for medium elements
        -:  246:        memcpy(dest, element, buffer->element_size);
        -:  247:    }
        -:  248:    
        -:  249:    // Count was already updated atomically in the CAS loop above
        -:  250:    
        -:  251:    return true;
        -:  252:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 0 returned 0% blocks executed 0%
    #####:  200:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    #####:  201:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  202:        return false;
        -:  203:    }
        -:  204:    
        -:  205:    // Debug: verify buffer integrity
        -:  206:    MERCURY_VERIFY_BUFFER(buffer);
        -:  207:    
        -:  208:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  209:    size_t current_count, new_count;
        -:  210:    do {
    #####:  211:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  212:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  213:            return false;  // Buffer is full
        -:  214:        }
    #####:  215:        new_count = current_count + 1;
    #####:  216:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  217:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  218:    
        -:  219:    // Now we have successfully reserved a slot, get our position
    #####:  220:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    #####:  221:    head = head % buffer->capacity;  // Wrap around
        -:  222:    
        -:  223:    // Copy data to reserved slot
    #####:  224:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  225:    
        -:  226:    // Prefetch destination for write
    #####:  227:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  228:    
        -:  229:    // Prefetch next few slots for sequential writes (cache warming)
    #####:  230:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  231:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 never executed
        -:  232:    }
    #####:  233:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  234:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 never executed
        -:  235:    }
        -:  236:    
        -:  237:    // Optimized copy based on element size
    #####:  238:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  239:        // Fast path for small elements (like ints, pointers)
        -:  240:        memcpy(dest, element, buffer->element_size);
    #####:  241:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  242:        // SIMD path for larger elements
    #####:  243:        mercury_memcpy_simd(dest, element, buffer->element_size);
call    0 never executed
        -:  244:    } else {
        -:  245:        // Regular memcpy for medium elements
        -:  246:        memcpy(dest, element, buffer->element_size);
        -:  247:    }
        -:  248:    
        -:  249:    // Count was already updated atomically in the CAS loop above
        -:  250:    
        -:  251:    return true;
        -:  252:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 0 returned 0% blocks executed 0%
    #####:  200:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    #####:  201:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  202:        return false;
        -:  203:    }
        -:  204:    
        -:  205:    // Debug: verify buffer integrity
        -:  206:    MERCURY_VERIFY_BUFFER(buffer);
        -:  207:    
        -:  208:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  209:    size_t current_count, new_count;
        -:  210:    do {
    #####:  211:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  212:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  213:            return false;  // Buffer is full
        -:  214:        }
    #####:  215:        new_count = current_count + 1;
    #####:  216:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  217:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  218:    
        -:  219:    // Now we have successfully reserved a slot, get our position
    #####:  220:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    #####:  221:    head = head % buffer->capacity;  // Wrap around
        -:  222:    
        -:  223:    // Copy data to reserved slot
    #####:  224:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  225:    
        -:  226:    // Prefetch destination for write
    #####:  227:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  228:    
        -:  229:    // Prefetch next few slots for sequential writes (cache warming)
    #####:  230:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  231:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 never executed
        -:  232:    }
    #####:  233:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  234:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 never executed
        -:  235:    }
        -:  236:    
        -:  237:    // Optimized copy based on element size
    #####:  238:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  239:        // Fast path for small elements (like ints, pointers)
        -:  240:        memcpy(dest, element, buffer->element_size);
    #####:  241:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  242:        // SIMD path for larger elements
    #####:  243:        mercury_memcpy_simd(dest, element, buffer->element_size);
call    0 never executed
        -:  244:    } else {
        -:  245:        // Regular memcpy for medium elements
        -:  246:        memcpy(dest, element, buffer->element_size);
        -:  247:    }
        -:  248:    
        -:  249:    // Count was already updated atomically in the CAS loop above
        -:  250:    
        -:  251:    return true;
        -:  252:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 0 returned 0% blocks executed 0%
    #####:  200:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    #####:  201:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  202:        return false;
        -:  203:    }
        -:  204:    
        -:  205:    // Debug: verify buffer integrity
        -:  206:    MERCURY_VERIFY_BUFFER(buffer);
        -:  207:    
        -:  208:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  209:    size_t current_count, new_count;
        -:  210:    do {
    #####:  211:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  212:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  213:            return false;  // Buffer is full
        -:  214:        }
    #####:  215:        new_count = current_count + 1;
    #####:  216:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  217:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  218:    
        -:  219:    // Now we have successfully reserved a slot, get our position
    #####:  220:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    #####:  221:    head = head % buffer->capacity;  // Wrap around
        -:  222:    
        -:  223:    // Copy data to reserved slot
    #####:  224:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  225:    
        -:  226:    // Prefetch destination for write
    #####:  227:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  228:    
        -:  229:    // Prefetch next few slots for sequential writes (cache warming)
    #####:  230:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  231:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 never executed
        -:  232:    }
    #####:  233:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  234:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 never executed
        -:  235:    }
        -:  236:    
        -:  237:    // Optimized copy based on element size
    #####:  238:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  239:        // Fast path for small elements (like ints, pointers)
        -:  240:        memcpy(dest, element, buffer->element_size);
    #####:  241:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  242:        // SIMD path for larger elements
    #####:  243:        mercury_memcpy_simd(dest, element, buffer->element_size);
call    0 never executed
        -:  244:    } else {
        -:  245:        // Regular memcpy for medium elements
        -:  246:        memcpy(dest, element, buffer->element_size);
        -:  247:    }
        -:  248:    
        -:  249:    // Count was already updated atomically in the CAS loop above
        -:  250:    
        -:  251:    return true;
        -:  252:}
------------------
        -:  253:
    3379*:  254:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    3379*:  255:    if (MERCURY_UNLIKELY(!buffer || !element)) {
        -:  256:        return false;
        -:  257:    }
        -:  258:    
        -:  259:    // Debug: verify buffer integrity
        -:  260:    MERCURY_VERIFY_BUFFER(buffer);
        -:  261:    
        -:  262:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  263:    size_t current_count, new_count;
        -:  264:    do {
    3379*:  265:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    3379*:  266:        if (MERCURY_UNLIKELY(current_count == 0)) {
        -:  267:            return false;  // Buffer is empty
        -:  268:        }
    3348*:  269:        new_count = current_count - 1;
    3348*:  270:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
        -:  271:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  272:    
        -:  273:    // Now we have successfully reserved a slot, get our position
    3348*:  274:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    3348*:  275:    tail = tail % buffer->capacity;  // Wrap around
        -:  276:    
        -:  277:    // Copy data from reserved slot
    3348*:  278:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  279:    
        -:  280:    // Prefetch source for read
    3348*:  281:    MERCURY_PREFETCH_READ(src);
        -:  282:    
        -:  283:    // Prefetch next few slots for sequential reads (cache warming)
    3348*:  284:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
    3338*:  285:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
        -:  286:    }
    3348*:  287:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
    3330*:  288:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
        -:  289:    }
        -:  290:    
        -:  291:    // Optimized copy based on element size
    3348*:  292:    if (buffer->element_size <= 8) {
        -:  293:        // Fast path for small elements (like ints, pointers)
        -:  294:        memcpy(element, src, buffer->element_size);
    3142*:  295:    } else if (buffer->element_size >= 32) {
        -:  296:        // SIMD path for larger elements
    3142*:  297:        mercury_memcpy_simd(element, src, buffer->element_size);
        -:  298:    } else {
        -:  299:        // Regular memcpy for medium elements
        -:  300:        memcpy(element, src, buffer->element_size);
        -:  301:    }
        -:  302:    
        -:  303:    // Count was already updated atomically in the CAS loop above
        -:  304:    
        -:  305:    return true;
        -:  306:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 206 returned 100% blocks executed 80%
      206:  254:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
      206:  255:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  256:        return false;
        -:  257:    }
        -:  258:    
        -:  259:    // Debug: verify buffer integrity
        -:  260:    MERCURY_VERIFY_BUFFER(buffer);
        -:  261:    
        -:  262:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  263:    size_t current_count, new_count;
        -:  264:    do {
      206:  265:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
      206:  266:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
        -:  267:            return false;  // Buffer is empty
        -:  268:        }
      200:  269:        new_count = current_count - 1;
      200:  270:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  271:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  272:    
        -:  273:    // Now we have successfully reserved a slot, get our position
      200:  274:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
      200:  275:    tail = tail % buffer->capacity;  // Wrap around
        -:  276:    
        -:  277:    // Copy data from reserved slot
      200:  278:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  279:    
        -:  280:    // Prefetch source for read
      200:  281:    MERCURY_PREFETCH_READ(src);
call    0 returned 100%
        -:  282:    
        -:  283:    // Prefetch next few slots for sequential reads (cache warming)
      200:  284:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
      197:  285:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 returned 100%
        -:  286:    }
      200:  287:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
      194:  288:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 returned 100%
        -:  289:    }
        -:  290:    
        -:  291:    // Optimized copy based on element size
      200:  292:    if (buffer->element_size <= 8) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  293:        // Fast path for small elements (like ints, pointers)
        -:  294:        memcpy(element, src, buffer->element_size);
    #####:  295:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  296:        // SIMD path for larger elements
    #####:  297:        mercury_memcpy_simd(element, src, buffer->element_size);
call    0 never executed
        -:  298:    } else {
        -:  299:        // Regular memcpy for medium elements
        -:  300:        memcpy(element, src, buffer->element_size);
        -:  301:    }
        -:  302:    
        -:  303:    // Count was already updated atomically in the CAS loop above
        -:  304:    
        -:  305:    return true;
        -:  306:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 11 returned 100% blocks executed 93%
       11:  254:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
       11:  255:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  256:        return false;
        -:  257:    }
        -:  258:    
        -:  259:    // Debug: verify buffer integrity
        -:  260:    MERCURY_VERIFY_BUFFER(buffer);
        -:  261:    
        -:  262:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  263:    size_t current_count, new_count;
        -:  264:    do {
       11:  265:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
       11:  266:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
        -:  267:            return false;  // Buffer is empty
        -:  268:        }
        8:  269:        new_count = current_count - 1;
        8:  270:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  271:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  272:    
        -:  273:    // Now we have successfully reserved a slot, get our position
        8:  274:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
        8:  275:    tail = tail % buffer->capacity;  // Wrap around
        -:  276:    
        -:  277:    // Copy data from reserved slot
        8:  278:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  279:    
        -:  280:    // Prefetch source for read
        8:  281:    MERCURY_PREFETCH_READ(src);
call    0 returned 100%
        -:  282:    
        -:  283:    // Prefetch next few slots for sequential reads (cache warming)
        8:  284:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
        5:  285:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 returned 100%
        -:  286:    }
        8:  287:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
        3:  288:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 returned 100%
        -:  289:    }
        -:  290:    
        -:  291:    // Optimized copy based on element size
        8:  292:    if (buffer->element_size <= 8) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
        -:  293:        // Fast path for small elements (like ints, pointers)
        -:  294:        memcpy(element, src, buffer->element_size);
        3:  295:    } else if (buffer->element_size >= 32) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  296:        // SIMD path for larger elements
        3:  297:        mercury_memcpy_simd(element, src, buffer->element_size);
call    0 returned 100%
        -:  298:    } else {
        -:  299:        // Regular memcpy for medium elements
        -:  300:        memcpy(element, src, buffer->element_size);
        -:  301:    }
        -:  302:    
        -:  303:    // Count was already updated atomically in the CAS loop above
        -:  304:    
        -:  305:    return true;
        -:  306:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 3 returned 100% blocks executed 93%
        3:  254:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
        3:  255:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  256:        return false;
        -:  257:    }
        -:  258:    
        -:  259:    // Debug: verify buffer integrity
        -:  260:    MERCURY_VERIFY_BUFFER(buffer);
        -:  261:    
        -:  262:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  263:    size_t current_count, new_count;
        -:  264:    do {
        3:  265:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
        3:  266:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -:  267:            return false;  // Buffer is empty
        -:  268:        }
        2:  269:        new_count = current_count - 1;
        2:  270:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  271:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  272:    
        -:  273:    // Now we have successfully reserved a slot, get our position
        2:  274:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
        2:  275:    tail = tail % buffer->capacity;  // Wrap around
        -:  276:    
        -:  277:    // Copy data from reserved slot
        2:  278:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  279:    
        -:  280:    // Prefetch source for read
        2:  281:    MERCURY_PREFETCH_READ(src);
call    0 returned 100%
        -:  282:    
        -:  283:    // Prefetch next few slots for sequential reads (cache warming)
        2:  284:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:  285:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 returned 100%
        -:  286:    }
        2:  287:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:  288:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 returned 100%
        -:  289:    }
        -:  290:    
        -:  291:    // Optimized copy based on element size
        2:  292:    if (buffer->element_size <= 8) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  293:        // Fast path for small elements (like ints, pointers)
        -:  294:        memcpy(element, src, buffer->element_size);
        1:  295:    } else if (buffer->element_size >= 32) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  296:        // SIMD path for larger elements
        1:  297:        mercury_memcpy_simd(element, src, buffer->element_size);
call    0 returned 100%
        -:  298:    } else {
        -:  299:        // Regular memcpy for medium elements
        -:  300:        memcpy(element, src, buffer->element_size);
        -:  301:    }
        -:  302:    
        -:  303:    // Count was already updated atomically in the CAS loop above
        -:  304:    
        -:  305:    return true;
        -:  306:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 0 returned 0% blocks executed 0%
    #####:  254:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    #####:  255:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  256:        return false;
        -:  257:    }
        -:  258:    
        -:  259:    // Debug: verify buffer integrity
        -:  260:    MERCURY_VERIFY_BUFFER(buffer);
        -:  261:    
        -:  262:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  263:    size_t current_count, new_count;
        -:  264:    do {
    #####:  265:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  266:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 never executed
branch  1 never executed
        -:  267:            return false;  // Buffer is empty
        -:  268:        }
    #####:  269:        new_count = current_count - 1;
    #####:  270:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  271:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  272:    
        -:  273:    // Now we have successfully reserved a slot, get our position
    #####:  274:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    #####:  275:    tail = tail % buffer->capacity;  // Wrap around
        -:  276:    
        -:  277:    // Copy data from reserved slot
    #####:  278:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  279:    
        -:  280:    // Prefetch source for read
    #####:  281:    MERCURY_PREFETCH_READ(src);
call    0 never executed
        -:  282:    
        -:  283:    // Prefetch next few slots for sequential reads (cache warming)
    #####:  284:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  285:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 never executed
        -:  286:    }
    #####:  287:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  288:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 never executed
        -:  289:    }
        -:  290:    
        -:  291:    // Optimized copy based on element size
    #####:  292:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  293:        // Fast path for small elements (like ints, pointers)
        -:  294:        memcpy(element, src, buffer->element_size);
    #####:  295:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  296:        // SIMD path for larger elements
    #####:  297:        mercury_memcpy_simd(element, src, buffer->element_size);
call    0 never executed
        -:  298:    } else {
        -:  299:        // Regular memcpy for medium elements
        -:  300:        memcpy(element, src, buffer->element_size);
        -:  301:    }
        -:  302:    
        -:  303:    // Count was already updated atomically in the CAS loop above
        -:  304:    
        -:  305:    return true;
        -:  306:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 0 returned 0% blocks executed 0%
    #####:  254:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    #####:  255:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  256:        return false;
        -:  257:    }
        -:  258:    
        -:  259:    // Debug: verify buffer integrity
        -:  260:    MERCURY_VERIFY_BUFFER(buffer);
        -:  261:    
        -:  262:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  263:    size_t current_count, new_count;
        -:  264:    do {
    #####:  265:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  266:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 never executed
branch  1 never executed
        -:  267:            return false;  // Buffer is empty
        -:  268:        }
    #####:  269:        new_count = current_count - 1;
    #####:  270:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  271:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  272:    
        -:  273:    // Now we have successfully reserved a slot, get our position
    #####:  274:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    #####:  275:    tail = tail % buffer->capacity;  // Wrap around
        -:  276:    
        -:  277:    // Copy data from reserved slot
    #####:  278:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  279:    
        -:  280:    // Prefetch source for read
    #####:  281:    MERCURY_PREFETCH_READ(src);
call    0 never executed
        -:  282:    
        -:  283:    // Prefetch next few slots for sequential reads (cache warming)
    #####:  284:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  285:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 never executed
        -:  286:    }
    #####:  287:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  288:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 never executed
        -:  289:    }
        -:  290:    
        -:  291:    // Optimized copy based on element size
    #####:  292:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  293:        // Fast path for small elements (like ints, pointers)
        -:  294:        memcpy(element, src, buffer->element_size);
    #####:  295:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  296:        // SIMD path for larger elements
    #####:  297:        mercury_memcpy_simd(element, src, buffer->element_size);
call    0 never executed
        -:  298:    } else {
        -:  299:        // Regular memcpy for medium elements
        -:  300:        memcpy(element, src, buffer->element_size);
        -:  301:    }
        -:  302:    
        -:  303:    // Count was already updated atomically in the CAS loop above
        -:  304:    
        -:  305:    return true;
        -:  306:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 0 returned 0% blocks executed 0%
    #####:  254:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    #####:  255:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  256:        return false;
        -:  257:    }
        -:  258:    
        -:  259:    // Debug: verify buffer integrity
        -:  260:    MERCURY_VERIFY_BUFFER(buffer);
        -:  261:    
        -:  262:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  263:    size_t current_count, new_count;
        -:  264:    do {
    #####:  265:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  266:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 never executed
branch  1 never executed
        -:  267:            return false;  // Buffer is empty
        -:  268:        }
    #####:  269:        new_count = current_count - 1;
    #####:  270:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  271:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  272:    
        -:  273:    // Now we have successfully reserved a slot, get our position
    #####:  274:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    #####:  275:    tail = tail % buffer->capacity;  // Wrap around
        -:  276:    
        -:  277:    // Copy data from reserved slot
    #####:  278:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  279:    
        -:  280:    // Prefetch source for read
    #####:  281:    MERCURY_PREFETCH_READ(src);
call    0 never executed
        -:  282:    
        -:  283:    // Prefetch next few slots for sequential reads (cache warming)
    #####:  284:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  285:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 never executed
        -:  286:    }
    #####:  287:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  288:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 never executed
        -:  289:    }
        -:  290:    
        -:  291:    // Optimized copy based on element size
    #####:  292:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  293:        // Fast path for small elements (like ints, pointers)
        -:  294:        memcpy(element, src, buffer->element_size);
    #####:  295:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  296:        // SIMD path for larger elements
    #####:  297:        mercury_memcpy_simd(element, src, buffer->element_size);
call    0 never executed
        -:  298:    } else {
        -:  299:        // Regular memcpy for medium elements
        -:  300:        memcpy(element, src, buffer->element_size);
        -:  301:    }
        -:  302:    
        -:  303:    // Count was already updated atomically in the CAS loop above
        -:  304:    
        -:  305:    return true;
        -:  306:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 0 returned 0% blocks executed 0%
    #####:  254:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    #####:  255:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  256:        return false;
        -:  257:    }
        -:  258:    
        -:  259:    // Debug: verify buffer integrity
        -:  260:    MERCURY_VERIFY_BUFFER(buffer);
        -:  261:    
        -:  262:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  263:    size_t current_count, new_count;
        -:  264:    do {
    #####:  265:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  266:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 never executed
branch  1 never executed
        -:  267:            return false;  // Buffer is empty
        -:  268:        }
    #####:  269:        new_count = current_count - 1;
    #####:  270:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  271:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  272:    
        -:  273:    // Now we have successfully reserved a slot, get our position
    #####:  274:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    #####:  275:    tail = tail % buffer->capacity;  // Wrap around
        -:  276:    
        -:  277:    // Copy data from reserved slot
    #####:  278:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  279:    
        -:  280:    // Prefetch source for read
    #####:  281:    MERCURY_PREFETCH_READ(src);
call    0 never executed
        -:  282:    
        -:  283:    // Prefetch next few slots for sequential reads (cache warming)
    #####:  284:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  285:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 never executed
        -:  286:    }
    #####:  287:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  288:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 never executed
        -:  289:    }
        -:  290:    
        -:  291:    // Optimized copy based on element size
    #####:  292:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  293:        // Fast path for small elements (like ints, pointers)
        -:  294:        memcpy(element, src, buffer->element_size);
    #####:  295:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  296:        // SIMD path for larger elements
    #####:  297:        mercury_memcpy_simd(element, src, buffer->element_size);
call    0 never executed
        -:  298:    } else {
        -:  299:        // Regular memcpy for medium elements
        -:  300:        memcpy(element, src, buffer->element_size);
        -:  301:    }
        -:  302:    
        -:  303:    // Count was already updated atomically in the CAS loop above
        -:  304:    
        -:  305:    return true;
        -:  306:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 0 returned 0% blocks executed 0%
    #####:  254:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    #####:  255:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  256:        return false;
        -:  257:    }
        -:  258:    
        -:  259:    // Debug: verify buffer integrity
        -:  260:    MERCURY_VERIFY_BUFFER(buffer);
        -:  261:    
        -:  262:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  263:    size_t current_count, new_count;
        -:  264:    do {
    #####:  265:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  266:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 never executed
branch  1 never executed
        -:  267:            return false;  // Buffer is empty
        -:  268:        }
    #####:  269:        new_count = current_count - 1;
    #####:  270:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  271:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  272:    
        -:  273:    // Now we have successfully reserved a slot, get our position
    #####:  274:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    #####:  275:    tail = tail % buffer->capacity;  // Wrap around
        -:  276:    
        -:  277:    // Copy data from reserved slot
    #####:  278:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  279:    
        -:  280:    // Prefetch source for read
    #####:  281:    MERCURY_PREFETCH_READ(src);
call    0 never executed
        -:  282:    
        -:  283:    // Prefetch next few slots for sequential reads (cache warming)
    #####:  284:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  285:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 never executed
        -:  286:    }
    #####:  287:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  288:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 never executed
        -:  289:    }
        -:  290:    
        -:  291:    // Optimized copy based on element size
    #####:  292:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  293:        // Fast path for small elements (like ints, pointers)
        -:  294:        memcpy(element, src, buffer->element_size);
    #####:  295:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  296:        // SIMD path for larger elements
    #####:  297:        mercury_memcpy_simd(element, src, buffer->element_size);
call    0 never executed
        -:  298:    } else {
        -:  299:        // Regular memcpy for medium elements
        -:  300:        memcpy(element, src, buffer->element_size);
        -:  301:    }
        -:  302:    
        -:  303:    // Count was already updated atomically in the CAS loop above
        -:  304:    
        -:  305:    return true;
        -:  306:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 0 returned 0% blocks executed 0%
    #####:  254:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    #####:  255:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  256:        return false;
        -:  257:    }
        -:  258:    
        -:  259:    // Debug: verify buffer integrity
        -:  260:    MERCURY_VERIFY_BUFFER(buffer);
        -:  261:    
        -:  262:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  263:    size_t current_count, new_count;
        -:  264:    do {
    #####:  265:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  266:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 never executed
branch  1 never executed
        -:  267:            return false;  // Buffer is empty
        -:  268:        }
    #####:  269:        new_count = current_count - 1;
    #####:  270:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  271:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  272:    
        -:  273:    // Now we have successfully reserved a slot, get our position
    #####:  274:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    #####:  275:    tail = tail % buffer->capacity;  // Wrap around
        -:  276:    
        -:  277:    // Copy data from reserved slot
    #####:  278:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  279:    
        -:  280:    // Prefetch source for read
    #####:  281:    MERCURY_PREFETCH_READ(src);
call    0 never executed
        -:  282:    
        -:  283:    // Prefetch next few slots for sequential reads (cache warming)
    #####:  284:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  285:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 never executed
        -:  286:    }
    #####:  287:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  288:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 never executed
        -:  289:    }
        -:  290:    
        -:  291:    // Optimized copy based on element size
    #####:  292:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  293:        // Fast path for small elements (like ints, pointers)
        -:  294:        memcpy(element, src, buffer->element_size);
    #####:  295:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  296:        // SIMD path for larger elements
    #####:  297:        mercury_memcpy_simd(element, src, buffer->element_size);
call    0 never executed
        -:  298:    } else {
        -:  299:        // Regular memcpy for medium elements
        -:  300:        memcpy(element, src, buffer->element_size);
        -:  301:    }
        -:  302:    
        -:  303:    // Count was already updated atomically in the CAS loop above
        -:  304:    
        -:  305:    return true;
        -:  306:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 37 returned 100% blocks executed 87%
       37:  254:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
       37:  255:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  256:        return false;
        -:  257:    }
        -:  258:    
        -:  259:    // Debug: verify buffer integrity
        -:  260:    MERCURY_VERIFY_BUFFER(buffer);
        -:  261:    
        -:  262:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  263:    size_t current_count, new_count;
        -:  264:    do {
       37:  265:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
       37:  266:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 taken 89% (fallthrough)
branch  1 taken 11%
        -:  267:            return false;  // Buffer is empty
        -:  268:        }
       33:  269:        new_count = current_count - 1;
       33:  270:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  271:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  272:    
        -:  273:    // Now we have successfully reserved a slot, get our position
       33:  274:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
       33:  275:    tail = tail % buffer->capacity;  // Wrap around
        -:  276:    
        -:  277:    // Copy data from reserved slot
       33:  278:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  279:    
        -:  280:    // Prefetch source for read
       33:  281:    MERCURY_PREFETCH_READ(src);
call    0 returned 100%
        -:  282:    
        -:  283:    // Prefetch next few slots for sequential reads (cache warming)
       33:  284:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       33:  285:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 returned 100%
        -:  286:    }
       33:  287:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       33:  288:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 returned 100%
        -:  289:    }
        -:  290:    
        -:  291:    // Optimized copy based on element size
       33:  292:    if (buffer->element_size <= 8) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  293:        // Fast path for small elements (like ints, pointers)
        -:  294:        memcpy(element, src, buffer->element_size);
       33:  295:    } else if (buffer->element_size >= 32) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  296:        // SIMD path for larger elements
       33:  297:        mercury_memcpy_simd(element, src, buffer->element_size);
call    0 returned 100%
        -:  298:    } else {
        -:  299:        // Regular memcpy for medium elements
        -:  300:        memcpy(element, src, buffer->element_size);
        -:  301:    }
        -:  302:    
        -:  303:    // Count was already updated atomically in the CAS loop above
        -:  304:    
        -:  305:    return true;
        -:  306:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 3122 returned 100% blocks executed 87%
     3122:  254:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
     3122:  255:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  256:        return false;
        -:  257:    }
        -:  258:    
        -:  259:    // Debug: verify buffer integrity
        -:  260:    MERCURY_VERIFY_BUFFER(buffer);
        -:  261:    
        -:  262:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  263:    size_t current_count, new_count;
        -:  264:    do {
     3122:  265:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
     3122:  266:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  267:            return false;  // Buffer is empty
        -:  268:        }
     3105:  269:        new_count = current_count - 1;
     3105:  270:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  271:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  272:    
        -:  273:    // Now we have successfully reserved a slot, get our position
     3105:  274:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
     3105:  275:    tail = tail % buffer->capacity;  // Wrap around
        -:  276:    
        -:  277:    // Copy data from reserved slot
     3105:  278:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  279:    
        -:  280:    // Prefetch source for read
     3105:  281:    MERCURY_PREFETCH_READ(src);
call    0 returned 100%
        -:  282:    
        -:  283:    // Prefetch next few slots for sequential reads (cache warming)
     3105:  284:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     3102:  285:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 returned 100%
        -:  286:    }
     3105:  287:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     3099:  288:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 returned 100%
        -:  289:    }
        -:  290:    
        -:  291:    // Optimized copy based on element size
     3105:  292:    if (buffer->element_size <= 8) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  293:        // Fast path for small elements (like ints, pointers)
        -:  294:        memcpy(element, src, buffer->element_size);
     3105:  295:    } else if (buffer->element_size >= 32) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  296:        // SIMD path for larger elements
     3105:  297:        mercury_memcpy_simd(element, src, buffer->element_size);
call    0 returned 100%
        -:  298:    } else {
        -:  299:        // Regular memcpy for medium elements
        -:  300:        memcpy(element, src, buffer->element_size);
        -:  301:    }
        -:  302:    
        -:  303:    // Count was already updated atomically in the CAS loop above
        -:  304:    
        -:  305:    return true;
        -:  306:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 0 returned 0% blocks executed 0%
    #####:  254:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    #####:  255:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  256:        return false;
        -:  257:    }
        -:  258:    
        -:  259:    // Debug: verify buffer integrity
        -:  260:    MERCURY_VERIFY_BUFFER(buffer);
        -:  261:    
        -:  262:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  263:    size_t current_count, new_count;
        -:  264:    do {
    #####:  265:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  266:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 never executed
branch  1 never executed
        -:  267:            return false;  // Buffer is empty
        -:  268:        }
    #####:  269:        new_count = current_count - 1;
    #####:  270:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  271:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  272:    
        -:  273:    // Now we have successfully reserved a slot, get our position
    #####:  274:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    #####:  275:    tail = tail % buffer->capacity;  // Wrap around
        -:  276:    
        -:  277:    // Copy data from reserved slot
    #####:  278:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  279:    
        -:  280:    // Prefetch source for read
    #####:  281:    MERCURY_PREFETCH_READ(src);
call    0 never executed
        -:  282:    
        -:  283:    // Prefetch next few slots for sequential reads (cache warming)
    #####:  284:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  285:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 never executed
        -:  286:    }
    #####:  287:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  288:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 never executed
        -:  289:    }
        -:  290:    
        -:  291:    // Optimized copy based on element size
    #####:  292:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  293:        // Fast path for small elements (like ints, pointers)
        -:  294:        memcpy(element, src, buffer->element_size);
    #####:  295:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  296:        // SIMD path for larger elements
    #####:  297:        mercury_memcpy_simd(element, src, buffer->element_size);
call    0 never executed
        -:  298:    } else {
        -:  299:        // Regular memcpy for medium elements
        -:  300:        memcpy(element, src, buffer->element_size);
        -:  301:    }
        -:  302:    
        -:  303:    // Count was already updated atomically in the CAS loop above
        -:  304:    
        -:  305:    return true;
        -:  306:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 0 returned 0% blocks executed 0%
    #####:  254:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    #####:  255:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  256:        return false;
        -:  257:    }
        -:  258:    
        -:  259:    // Debug: verify buffer integrity
        -:  260:    MERCURY_VERIFY_BUFFER(buffer);
        -:  261:    
        -:  262:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  263:    size_t current_count, new_count;
        -:  264:    do {
    #####:  265:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  266:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 never executed
branch  1 never executed
        -:  267:            return false;  // Buffer is empty
        -:  268:        }
    #####:  269:        new_count = current_count - 1;
    #####:  270:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  271:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  272:    
        -:  273:    // Now we have successfully reserved a slot, get our position
    #####:  274:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    #####:  275:    tail = tail % buffer->capacity;  // Wrap around
        -:  276:    
        -:  277:    // Copy data from reserved slot
    #####:  278:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  279:    
        -:  280:    // Prefetch source for read
    #####:  281:    MERCURY_PREFETCH_READ(src);
call    0 never executed
        -:  282:    
        -:  283:    // Prefetch next few slots for sequential reads (cache warming)
    #####:  284:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  285:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 never executed
        -:  286:    }
    #####:  287:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  288:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 never executed
        -:  289:    }
        -:  290:    
        -:  291:    // Optimized copy based on element size
    #####:  292:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  293:        // Fast path for small elements (like ints, pointers)
        -:  294:        memcpy(element, src, buffer->element_size);
    #####:  295:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  296:        // SIMD path for larger elements
    #####:  297:        mercury_memcpy_simd(element, src, buffer->element_size);
call    0 never executed
        -:  298:    } else {
        -:  299:        // Regular memcpy for medium elements
        -:  300:        memcpy(element, src, buffer->element_size);
        -:  301:    }
        -:  302:    
        -:  303:    // Count was already updated atomically in the CAS loop above
        -:  304:    
        -:  305:    return true;
        -:  306:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 0 returned 0% blocks executed 0%
    #####:  254:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    #####:  255:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  256:        return false;
        -:  257:    }
        -:  258:    
        -:  259:    // Debug: verify buffer integrity
        -:  260:    MERCURY_VERIFY_BUFFER(buffer);
        -:  261:    
        -:  262:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  263:    size_t current_count, new_count;
        -:  264:    do {
    #####:  265:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  266:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 never executed
branch  1 never executed
        -:  267:            return false;  // Buffer is empty
        -:  268:        }
    #####:  269:        new_count = current_count - 1;
    #####:  270:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  271:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  272:    
        -:  273:    // Now we have successfully reserved a slot, get our position
    #####:  274:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    #####:  275:    tail = tail % buffer->capacity;  // Wrap around
        -:  276:    
        -:  277:    // Copy data from reserved slot
    #####:  278:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  279:    
        -:  280:    // Prefetch source for read
    #####:  281:    MERCURY_PREFETCH_READ(src);
call    0 never executed
        -:  282:    
        -:  283:    // Prefetch next few slots for sequential reads (cache warming)
    #####:  284:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  285:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 never executed
        -:  286:    }
    #####:  287:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  288:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 never executed
        -:  289:    }
        -:  290:    
        -:  291:    // Optimized copy based on element size
    #####:  292:    if (buffer->element_size <= 8) {
branch  0 never executed
branch  1 never executed
        -:  293:        // Fast path for small elements (like ints, pointers)
        -:  294:        memcpy(element, src, buffer->element_size);
    #####:  295:    } else if (buffer->element_size >= 32) {
branch  0 never executed
branch  1 never executed
        -:  296:        // SIMD path for larger elements
    #####:  297:        mercury_memcpy_simd(element, src, buffer->element_size);
call    0 never executed
        -:  298:    } else {
        -:  299:        // Regular memcpy for medium elements
        -:  300:        memcpy(element, src, buffer->element_size);
        -:  301:    }
        -:  302:    
        -:  303:    // Count was already updated atomically in the CAS loop above
        -:  304:    
        -:  305:    return true;
        -:  306:}
------------------
        -:  307:
       2*:  308:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
       2*:  309:    if (!buffer) return 0;
       2*:  310:    return atomic_load(&buffer->count);
        -:  311:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  308:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  309:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  310:    return atomic_load(&buffer->count);
        -:  311:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 2 returned 100% blocks executed 100%
        2:  308:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
        2:  309:    if (!buffer) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  310:    return atomic_load(&buffer->count);
        -:  311:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  308:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  309:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  310:    return atomic_load(&buffer->count);
        -:  311:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  308:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  309:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  310:    return atomic_load(&buffer->count);
        -:  311:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  308:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  309:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  310:    return atomic_load(&buffer->count);
        -:  311:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  308:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  309:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  310:    return atomic_load(&buffer->count);
        -:  311:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  308:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  309:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  310:    return atomic_load(&buffer->count);
        -:  311:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  308:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  309:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  310:    return atomic_load(&buffer->count);
        -:  311:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  308:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  309:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  310:    return atomic_load(&buffer->count);
        -:  311:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  308:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  309:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  310:    return atomic_load(&buffer->count);
        -:  311:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  308:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  309:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  310:    return atomic_load(&buffer->count);
        -:  311:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  308:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  309:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  310:    return atomic_load(&buffer->count);
        -:  311:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  308:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  309:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  310:    return atomic_load(&buffer->count);
        -:  311:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  308:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  309:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  310:    return atomic_load(&buffer->count);
        -:  311:}
------------------
        -:  312:
       4*:  313:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
       4*:  314:    if (!buffer) return true;
       4*:  315:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  316:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  313:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  314:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  315:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  316:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 4 returned 100% blocks executed 100%
        4:  313:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
        4:  314:    if (!buffer) return true;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4:  315:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  316:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  313:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  314:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  315:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  316:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  313:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  314:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  315:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  316:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  313:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  314:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  315:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  316:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  313:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  314:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  315:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  316:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  313:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  314:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  315:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  316:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  313:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  314:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  315:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  316:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  313:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  314:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  315:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  316:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  313:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  314:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  315:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  316:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  313:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  314:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  315:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  316:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  313:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  314:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  315:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  316:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  313:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  314:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  315:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  316:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  313:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  314:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  315:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  316:}
------------------
        -:  317:
       5*:  318:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
       5*:  319:    if (!buffer) return true;
       5*:  320:    return atomic_load(&buffer->count) == 0;
        -:  321:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 1 returned 100% blocks executed 100%
        1:  318:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
        1:  319:    if (!buffer) return true;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  320:    return atomic_load(&buffer->count) == 0;
        -:  321:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 4 returned 100% blocks executed 100%
        4:  318:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
        4:  319:    if (!buffer) return true;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4:  320:    return atomic_load(&buffer->count) == 0;
        -:  321:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  318:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  319:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  320:    return atomic_load(&buffer->count) == 0;
        -:  321:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  318:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  319:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  320:    return atomic_load(&buffer->count) == 0;
        -:  321:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  318:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  319:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  320:    return atomic_load(&buffer->count) == 0;
        -:  321:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  318:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  319:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  320:    return atomic_load(&buffer->count) == 0;
        -:  321:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  318:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  319:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  320:    return atomic_load(&buffer->count) == 0;
        -:  321:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  318:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  319:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  320:    return atomic_load(&buffer->count) == 0;
        -:  321:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  318:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  319:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  320:    return atomic_load(&buffer->count) == 0;
        -:  321:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  318:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  319:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  320:    return atomic_load(&buffer->count) == 0;
        -:  321:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  318:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  319:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  320:    return atomic_load(&buffer->count) == 0;
        -:  321:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  318:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  319:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  320:    return atomic_load(&buffer->count) == 0;
        -:  321:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  318:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  319:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  320:    return atomic_load(&buffer->count) == 0;
        -:  321:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  318:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  319:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  320:    return atomic_load(&buffer->count) == 0;
        -:  321:}
------------------
        -:  322:
        -:  323:// === STRING UTILITIES ===
        -:  324:
      11*:  325:MercuryString* mercury_string_create(size_t initial_capacity) {
      11*:  326:    if (initial_capacity == 0) {
        -:  327:        initial_capacity = 256;  // Default capacity
        -:  328:    }
        -:  329:    
      11*:  330:    MercuryString* str = malloc(sizeof(MercuryString));
      11*:  331:    if (!str) {
    #####:  332:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  333:        return NULL;
        -:  334:    }
        -:  335:    
      11*:  336:    str->data = malloc(initial_capacity);
      11*:  337:    if (!str->data) {
    #####:  338:        free(str);
    #####:  339:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  340:        return NULL;
        -:  341:    }
        -:  342:    
      11*:  343:    str->data[0] = '\0';
      11*:  344:    str->length = 0;
      11*:  345:    str->capacity = initial_capacity;
        -:  346:    
      11*:  347:    return str;
        -:  348:}
------------------
mercury_string_create:
function mercury_string_create called 1 returned 100% blocks executed 62%
        1:  325:MercuryString* mercury_string_create(size_t initial_capacity) {
        1:  326:    if (initial_capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  327:        initial_capacity = 256;  // Default capacity
        -:  328:    }
        -:  329:    
        1:  330:    MercuryString* str = malloc(sizeof(MercuryString));
        1:  331:    if (!str) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  332:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  333:        return NULL;
        -:  334:    }
        -:  335:    
        1:  336:    str->data = malloc(initial_capacity);
        1:  337:    if (!str->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  338:        free(str);
    #####:  339:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  340:        return NULL;
        -:  341:    }
        -:  342:    
        1:  343:    str->data[0] = '\0';
        1:  344:    str->length = 0;
        1:  345:    str->capacity = initial_capacity;
        -:  346:    
        1:  347:    return str;
        -:  348:}
------------------
mercury_string_create:
function mercury_string_create called 5 returned 100% blocks executed 75%
        5:  325:MercuryString* mercury_string_create(size_t initial_capacity) {
        5:  326:    if (initial_capacity == 0) {
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        -:  327:        initial_capacity = 256;  // Default capacity
        -:  328:    }
        -:  329:    
        5:  330:    MercuryString* str = malloc(sizeof(MercuryString));
        5:  331:    if (!str) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  332:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  333:        return NULL;
        -:  334:    }
        -:  335:    
        5:  336:    str->data = malloc(initial_capacity);
        5:  337:    if (!str->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  338:        free(str);
    #####:  339:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  340:        return NULL;
        -:  341:    }
        -:  342:    
        5:  343:    str->data[0] = '\0';
        5:  344:    str->length = 0;
        5:  345:    str->capacity = initial_capacity;
        -:  346:    
        5:  347:    return str;
        -:  348:}
------------------
mercury_string_create:
function mercury_string_create called 1 returned 100% blocks executed 62%
        1:  325:MercuryString* mercury_string_create(size_t initial_capacity) {
        1:  326:    if (initial_capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  327:        initial_capacity = 256;  // Default capacity
        -:  328:    }
        -:  329:    
        1:  330:    MercuryString* str = malloc(sizeof(MercuryString));
        1:  331:    if (!str) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  332:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  333:        return NULL;
        -:  334:    }
        -:  335:    
        1:  336:    str->data = malloc(initial_capacity);
        1:  337:    if (!str->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  338:        free(str);
    #####:  339:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  340:        return NULL;
        -:  341:    }
        -:  342:    
        1:  343:    str->data[0] = '\0';
        1:  344:    str->length = 0;
        1:  345:    str->capacity = initial_capacity;
        -:  346:    
        1:  347:    return str;
        -:  348:}
------------------
mercury_string_create:
function mercury_string_create called 1 returned 100% blocks executed 62%
        1:  325:MercuryString* mercury_string_create(size_t initial_capacity) {
        1:  326:    if (initial_capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  327:        initial_capacity = 256;  // Default capacity
        -:  328:    }
        -:  329:    
        1:  330:    MercuryString* str = malloc(sizeof(MercuryString));
        1:  331:    if (!str) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  332:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  333:        return NULL;
        -:  334:    }
        -:  335:    
        1:  336:    str->data = malloc(initial_capacity);
        1:  337:    if (!str->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  338:        free(str);
    #####:  339:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  340:        return NULL;
        -:  341:    }
        -:  342:    
        1:  343:    str->data[0] = '\0';
        1:  344:    str->length = 0;
        1:  345:    str->capacity = initial_capacity;
        -:  346:    
        1:  347:    return str;
        -:  348:}
------------------
mercury_string_create:
function mercury_string_create called 0 returned 0% blocks executed 0%
    #####:  325:MercuryString* mercury_string_create(size_t initial_capacity) {
    #####:  326:    if (initial_capacity == 0) {
branch  0 never executed
branch  1 never executed
        -:  327:        initial_capacity = 256;  // Default capacity
        -:  328:    }
        -:  329:    
    #####:  330:    MercuryString* str = malloc(sizeof(MercuryString));
    #####:  331:    if (!str) {
branch  0 never executed
branch  1 never executed
    #####:  332:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  333:        return NULL;
        -:  334:    }
        -:  335:    
    #####:  336:    str->data = malloc(initial_capacity);
    #####:  337:    if (!str->data) {
branch  0 never executed
branch  1 never executed
    #####:  338:        free(str);
    #####:  339:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  340:        return NULL;
        -:  341:    }
        -:  342:    
    #####:  343:    str->data[0] = '\0';
    #####:  344:    str->length = 0;
    #####:  345:    str->capacity = initial_capacity;
        -:  346:    
    #####:  347:    return str;
        -:  348:}
------------------
mercury_string_create:
function mercury_string_create called 0 returned 0% blocks executed 0%
    #####:  325:MercuryString* mercury_string_create(size_t initial_capacity) {
    #####:  326:    if (initial_capacity == 0) {
branch  0 never executed
branch  1 never executed
        -:  327:        initial_capacity = 256;  // Default capacity
        -:  328:    }
        -:  329:    
    #####:  330:    MercuryString* str = malloc(sizeof(MercuryString));
    #####:  331:    if (!str) {
branch  0 never executed
branch  1 never executed
    #####:  332:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  333:        return NULL;
        -:  334:    }
        -:  335:    
    #####:  336:    str->data = malloc(initial_capacity);
    #####:  337:    if (!str->data) {
branch  0 never executed
branch  1 never executed
    #####:  338:        free(str);
    #####:  339:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  340:        return NULL;
        -:  341:    }
        -:  342:    
    #####:  343:    str->data[0] = '\0';
    #####:  344:    str->length = 0;
    #####:  345:    str->capacity = initial_capacity;
        -:  346:    
    #####:  347:    return str;
        -:  348:}
------------------
mercury_string_create:
function mercury_string_create called 0 returned 0% blocks executed 0%
    #####:  325:MercuryString* mercury_string_create(size_t initial_capacity) {
    #####:  326:    if (initial_capacity == 0) {
branch  0 never executed
branch  1 never executed
        -:  327:        initial_capacity = 256;  // Default capacity
        -:  328:    }
        -:  329:    
    #####:  330:    MercuryString* str = malloc(sizeof(MercuryString));
    #####:  331:    if (!str) {
branch  0 never executed
branch  1 never executed
    #####:  332:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  333:        return NULL;
        -:  334:    }
        -:  335:    
    #####:  336:    str->data = malloc(initial_capacity);
    #####:  337:    if (!str->data) {
branch  0 never executed
branch  1 never executed
    #####:  338:        free(str);
    #####:  339:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  340:        return NULL;
        -:  341:    }
        -:  342:    
    #####:  343:    str->data[0] = '\0';
    #####:  344:    str->length = 0;
    #####:  345:    str->capacity = initial_capacity;
        -:  346:    
    #####:  347:    return str;
        -:  348:}
------------------
mercury_string_create:
function mercury_string_create called 0 returned 0% blocks executed 0%
    #####:  325:MercuryString* mercury_string_create(size_t initial_capacity) {
    #####:  326:    if (initial_capacity == 0) {
branch  0 never executed
branch  1 never executed
        -:  327:        initial_capacity = 256;  // Default capacity
        -:  328:    }
        -:  329:    
    #####:  330:    MercuryString* str = malloc(sizeof(MercuryString));
    #####:  331:    if (!str) {
branch  0 never executed
branch  1 never executed
    #####:  332:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  333:        return NULL;
        -:  334:    }
        -:  335:    
    #####:  336:    str->data = malloc(initial_capacity);
    #####:  337:    if (!str->data) {
branch  0 never executed
branch  1 never executed
    #####:  338:        free(str);
    #####:  339:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  340:        return NULL;
        -:  341:    }
        -:  342:    
    #####:  343:    str->data[0] = '\0';
    #####:  344:    str->length = 0;
    #####:  345:    str->capacity = initial_capacity;
        -:  346:    
    #####:  347:    return str;
        -:  348:}
------------------
mercury_string_create:
function mercury_string_create called 0 returned 0% blocks executed 0%
    #####:  325:MercuryString* mercury_string_create(size_t initial_capacity) {
    #####:  326:    if (initial_capacity == 0) {
branch  0 never executed
branch  1 never executed
        -:  327:        initial_capacity = 256;  // Default capacity
        -:  328:    }
        -:  329:    
    #####:  330:    MercuryString* str = malloc(sizeof(MercuryString));
    #####:  331:    if (!str) {
branch  0 never executed
branch  1 never executed
    #####:  332:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  333:        return NULL;
        -:  334:    }
        -:  335:    
    #####:  336:    str->data = malloc(initial_capacity);
    #####:  337:    if (!str->data) {
branch  0 never executed
branch  1 never executed
    #####:  338:        free(str);
    #####:  339:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  340:        return NULL;
        -:  341:    }
        -:  342:    
    #####:  343:    str->data[0] = '\0';
    #####:  344:    str->length = 0;
    #####:  345:    str->capacity = initial_capacity;
        -:  346:    
    #####:  347:    return str;
        -:  348:}
------------------
mercury_string_create:
function mercury_string_create called 1 returned 100% blocks executed 62%
        1:  325:MercuryString* mercury_string_create(size_t initial_capacity) {
        1:  326:    if (initial_capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  327:        initial_capacity = 256;  // Default capacity
        -:  328:    }
        -:  329:    
        1:  330:    MercuryString* str = malloc(sizeof(MercuryString));
        1:  331:    if (!str) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  332:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  333:        return NULL;
        -:  334:    }
        -:  335:    
        1:  336:    str->data = malloc(initial_capacity);
        1:  337:    if (!str->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  338:        free(str);
    #####:  339:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  340:        return NULL;
        -:  341:    }
        -:  342:    
        1:  343:    str->data[0] = '\0';
        1:  344:    str->length = 0;
        1:  345:    str->capacity = initial_capacity;
        -:  346:    
        1:  347:    return str;
        -:  348:}
------------------
mercury_string_create:
function mercury_string_create called 2 returned 100% blocks executed 62%
        2:  325:MercuryString* mercury_string_create(size_t initial_capacity) {
        2:  326:    if (initial_capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  327:        initial_capacity = 256;  // Default capacity
        -:  328:    }
        -:  329:    
        2:  330:    MercuryString* str = malloc(sizeof(MercuryString));
        2:  331:    if (!str) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  332:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  333:        return NULL;
        -:  334:    }
        -:  335:    
        2:  336:    str->data = malloc(initial_capacity);
        2:  337:    if (!str->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  338:        free(str);
    #####:  339:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  340:        return NULL;
        -:  341:    }
        -:  342:    
        2:  343:    str->data[0] = '\0';
        2:  344:    str->length = 0;
        2:  345:    str->capacity = initial_capacity;
        -:  346:    
        2:  347:    return str;
        -:  348:}
------------------
mercury_string_create:
function mercury_string_create called 0 returned 0% blocks executed 0%
    #####:  325:MercuryString* mercury_string_create(size_t initial_capacity) {
    #####:  326:    if (initial_capacity == 0) {
branch  0 never executed
branch  1 never executed
        -:  327:        initial_capacity = 256;  // Default capacity
        -:  328:    }
        -:  329:    
    #####:  330:    MercuryString* str = malloc(sizeof(MercuryString));
    #####:  331:    if (!str) {
branch  0 never executed
branch  1 never executed
    #####:  332:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  333:        return NULL;
        -:  334:    }
        -:  335:    
    #####:  336:    str->data = malloc(initial_capacity);
    #####:  337:    if (!str->data) {
branch  0 never executed
branch  1 never executed
    #####:  338:        free(str);
    #####:  339:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  340:        return NULL;
        -:  341:    }
        -:  342:    
    #####:  343:    str->data[0] = '\0';
    #####:  344:    str->length = 0;
    #####:  345:    str->capacity = initial_capacity;
        -:  346:    
    #####:  347:    return str;
        -:  348:}
------------------
mercury_string_create:
function mercury_string_create called 0 returned 0% blocks executed 0%
    #####:  325:MercuryString* mercury_string_create(size_t initial_capacity) {
    #####:  326:    if (initial_capacity == 0) {
branch  0 never executed
branch  1 never executed
        -:  327:        initial_capacity = 256;  // Default capacity
        -:  328:    }
        -:  329:    
    #####:  330:    MercuryString* str = malloc(sizeof(MercuryString));
    #####:  331:    if (!str) {
branch  0 never executed
branch  1 never executed
    #####:  332:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  333:        return NULL;
        -:  334:    }
        -:  335:    
    #####:  336:    str->data = malloc(initial_capacity);
    #####:  337:    if (!str->data) {
branch  0 never executed
branch  1 never executed
    #####:  338:        free(str);
    #####:  339:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  340:        return NULL;
        -:  341:    }
        -:  342:    
    #####:  343:    str->data[0] = '\0';
    #####:  344:    str->length = 0;
    #####:  345:    str->capacity = initial_capacity;
        -:  346:    
    #####:  347:    return str;
        -:  348:}
------------------
mercury_string_create:
function mercury_string_create called 0 returned 0% blocks executed 0%
    #####:  325:MercuryString* mercury_string_create(size_t initial_capacity) {
    #####:  326:    if (initial_capacity == 0) {
branch  0 never executed
branch  1 never executed
        -:  327:        initial_capacity = 256;  // Default capacity
        -:  328:    }
        -:  329:    
    #####:  330:    MercuryString* str = malloc(sizeof(MercuryString));
    #####:  331:    if (!str) {
branch  0 never executed
branch  1 never executed
    #####:  332:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  333:        return NULL;
        -:  334:    }
        -:  335:    
    #####:  336:    str->data = malloc(initial_capacity);
    #####:  337:    if (!str->data) {
branch  0 never executed
branch  1 never executed
    #####:  338:        free(str);
    #####:  339:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  340:        return NULL;
        -:  341:    }
        -:  342:    
    #####:  343:    str->data[0] = '\0';
    #####:  344:    str->length = 0;
    #####:  345:    str->capacity = initial_capacity;
        -:  346:    
    #####:  347:    return str;
        -:  348:}
------------------
        -:  349:
      11*:  350:void mercury_string_destroy(MercuryString* str) {
      11*:  351:    if (!str) return;
        -:  352:    
      11*:  353:    free(str->data);
      11*:  354:    free(str);
        -:  355:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 1 returned 100% blocks executed 100%
        1:  350:void mercury_string_destroy(MercuryString* str) {
        1:  351:    if (!str) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  352:    
        1:  353:    free(str->data);
        1:  354:    free(str);
        -:  355:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 5 returned 100% blocks executed 100%
        5:  350:void mercury_string_destroy(MercuryString* str) {
        5:  351:    if (!str) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  352:    
        5:  353:    free(str->data);
        5:  354:    free(str);
        -:  355:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 1 returned 100% blocks executed 100%
        1:  350:void mercury_string_destroy(MercuryString* str) {
        1:  351:    if (!str) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  352:    
        1:  353:    free(str->data);
        1:  354:    free(str);
        -:  355:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 1 returned 100% blocks executed 100%
        1:  350:void mercury_string_destroy(MercuryString* str) {
        1:  351:    if (!str) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  352:    
        1:  353:    free(str->data);
        1:  354:    free(str);
        -:  355:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 0 returned 0% blocks executed 0%
    #####:  350:void mercury_string_destroy(MercuryString* str) {
    #####:  351:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  352:    
    #####:  353:    free(str->data);
    #####:  354:    free(str);
        -:  355:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 0 returned 0% blocks executed 0%
    #####:  350:void mercury_string_destroy(MercuryString* str) {
    #####:  351:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  352:    
    #####:  353:    free(str->data);
    #####:  354:    free(str);
        -:  355:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 0 returned 0% blocks executed 0%
    #####:  350:void mercury_string_destroy(MercuryString* str) {
    #####:  351:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  352:    
    #####:  353:    free(str->data);
    #####:  354:    free(str);
        -:  355:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 0 returned 0% blocks executed 0%
    #####:  350:void mercury_string_destroy(MercuryString* str) {
    #####:  351:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  352:    
    #####:  353:    free(str->data);
    #####:  354:    free(str);
        -:  355:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 0 returned 0% blocks executed 0%
    #####:  350:void mercury_string_destroy(MercuryString* str) {
    #####:  351:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  352:    
    #####:  353:    free(str->data);
    #####:  354:    free(str);
        -:  355:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 1 returned 100% blocks executed 100%
        1:  350:void mercury_string_destroy(MercuryString* str) {
        1:  351:    if (!str) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  352:    
        1:  353:    free(str->data);
        1:  354:    free(str);
        -:  355:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 2 returned 100% blocks executed 100%
        2:  350:void mercury_string_destroy(MercuryString* str) {
        2:  351:    if (!str) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  352:    
        2:  353:    free(str->data);
        2:  354:    free(str);
        -:  355:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 0 returned 0% blocks executed 0%
    #####:  350:void mercury_string_destroy(MercuryString* str) {
    #####:  351:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  352:    
    #####:  353:    free(str->data);
    #####:  354:    free(str);
        -:  355:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 0 returned 0% blocks executed 0%
    #####:  350:void mercury_string_destroy(MercuryString* str) {
    #####:  351:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  352:    
    #####:  353:    free(str->data);
    #####:  354:    free(str);
        -:  355:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 0 returned 0% blocks executed 0%
    #####:  350:void mercury_string_destroy(MercuryString* str) {
    #####:  351:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  352:    
    #####:  353:    free(str->data);
    #####:  354:    free(str);
        -:  355:}
------------------
        -:  356:
    1073*:  357:MercuryError mercury_string_append(MercuryString* str, const char* text) {
    1073*:  358:    if (MERCURY_UNLIKELY(!str || !text)) {
        -:  359:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  360:    }
        -:  361:    
    1070*:  362:    size_t text_len = strlen(text);
    1070*:  363:    if (MERCURY_UNLIKELY(text_len == 0)) {
        -:  364:        return MERCURY_SUCCESS;  // Nothing to append
        -:  365:    }
        -:  366:    
    1069*:  367:    size_t new_length = str->length + text_len;
        -:  368:    
        -:  369:    // Resize buffer if necessary with better growth strategy
    1069*:  370:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
        -:  371:        // Growth strategy: for small strings double, for large strings add 50%
        -:  372:        size_t new_capacity;
      30*:  373:        if (str->capacity < 4096) {
      21*:  374:            new_capacity = str->capacity * 2;
        -:  375:        } else {
       9*:  376:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  377:        }
        -:  378:        
        -:  379:        // Ensure we have enough space
      30*:  380:        if (new_capacity <= new_length) {
       3*:  381:            new_capacity = new_length + 256;  // Add some padding
        -:  382:        }
        -:  383:        
      30*:  384:        char* new_data = realloc(str->data, new_capacity);
      30*:  385:        if (MERCURY_UNLIKELY(!new_data)) {
    #####:  386:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  387:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  388:        }
        -:  389:        
      30*:  390:        str->data = new_data;
      30*:  391:        str->capacity = new_capacity;
        -:  392:    }
        -:  393:    
        -:  394:    // Use optimized copy based on text length
    1069*:  395:    char* dest = str->data + str->length;
        -:  396:    
        -:  397:    // Prefetch destination for write operations
    1069*:  398:    MERCURY_PREFETCH_WRITE(dest);
        -:  399:    
        -:  400:    // For larger strings, prefetch additional cache lines
    1069*:  401:    if (text_len >= 64) {
      18*:  402:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
        -:  403:    }
    1069*:  404:    if (text_len >= 128) {
      15*:  405:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
        -:  406:    }
        -:  407:    
    1069*:  408:    if (text_len >= 32) {
        -:  409:        // SIMD path for large appends
      19*:  410:        mercury_memcpy_simd(dest, text, text_len);
    1050*:  411:    } else if (text_len >= 8) {
        -:  412:        // Use 64-bit copies for medium strings
        -:  413:        const uint64_t* src64 = (const uint64_t*)text;
        -:  414:        uint64_t* dest64 = (uint64_t*)dest;
     993*:  415:        size_t chunks = text_len / 8;
     993*:  416:        size_t remainder = text_len % 8;
        -:  417:        
    1987*:  418:        for (size_t i = 0; i < chunks; i++) {
     994*:  419:            dest64[i] = src64[i];
        -:  420:        }
        -:  421:        
        -:  422:        // Handle remainder
     993*:  423:        if (remainder > 0) {
     901*:  424:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  425:        }
        -:  426:    } else {
        -:  427:        // Fast path for small strings
        -:  428:        memcpy(dest, text, text_len);
        -:  429:    }
        -:  430:    
    1069*:  431:    str->length = new_length;
    1069*:  432:    str->data[str->length] = '\0';
        -:  433:    
    1069*:  434:    return MERCURY_SUCCESS;
        -:  435:}
------------------
mercury_string_append:
function mercury_string_append called 1000 returned 100% blocks executed 81%
     1000:  357:MercuryError mercury_string_append(MercuryString* str, const char* text) {
     1000:  358:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  359:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  360:    }
        -:  361:    
     1000:  362:    size_t text_len = strlen(text);
     1000:  363:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  364:        return MERCURY_SUCCESS;  // Nothing to append
        -:  365:    }
        -:  366:    
     1000:  367:    size_t new_length = str->length + text_len;
        -:  368:    
        -:  369:    // Resize buffer if necessary with better growth strategy
     1000:  370:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  371:        // Growth strategy: for small strings double, for large strings add 50%
        -:  372:        size_t new_capacity;
       10:  373:        if (str->capacity < 4096) {
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        8:  374:            new_capacity = str->capacity * 2;
        -:  375:        } else {
        2:  376:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  377:        }
        -:  378:        
        -:  379:        // Ensure we have enough space
       10:  380:        if (new_capacity <= new_length) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  381:            new_capacity = new_length + 256;  // Add some padding
        -:  382:        }
        -:  383:        
       10:  384:        char* new_data = realloc(str->data, new_capacity);
       10:  385:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  386:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  387:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  388:        }
        -:  389:        
       10:  390:        str->data = new_data;
       10:  391:        str->capacity = new_capacity;
        -:  392:    }
        -:  393:    
        -:  394:    // Use optimized copy based on text length
     1000:  395:    char* dest = str->data + str->length;
        -:  396:    
        -:  397:    // Prefetch destination for write operations
     1000:  398:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  399:    
        -:  400:    // For larger strings, prefetch additional cache lines
     1000:  401:    if (text_len >= 64) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  402:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  403:    }
     1000:  404:    if (text_len >= 128) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  405:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  406:    }
        -:  407:    
     1000:  408:    if (text_len >= 32) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  409:        // SIMD path for large appends
    #####:  410:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
     1000:  411:    } else if (text_len >= 8) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  412:        // Use 64-bit copies for medium strings
        -:  413:        const uint64_t* src64 = (const uint64_t*)text;
        -:  414:        uint64_t* dest64 = (uint64_t*)dest;
      990:  415:        size_t chunks = text_len / 8;
      990:  416:        size_t remainder = text_len % 8;
        -:  417:        
     1980:  418:        for (size_t i = 0; i < chunks; i++) {
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
      990:  419:            dest64[i] = src64[i];
        -:  420:        }
        -:  421:        
        -:  422:        // Handle remainder
      990:  423:        if (remainder > 0) {
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
      900:  424:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  425:        }
        -:  426:    } else {
        -:  427:        // Fast path for small strings
        -:  428:        memcpy(dest, text, text_len);
        -:  429:    }
        -:  430:    
     1000:  431:    str->length = new_length;
     1000:  432:    str->data[str->length] = '\0';
        -:  433:    
     1000:  434:    return MERCURY_SUCCESS;
        -:  435:}
------------------
mercury_string_append:
function mercury_string_append called 26 returned 100% blocks executed 78%
       26:  357:MercuryError mercury_string_append(MercuryString* str, const char* text) {
       26:  358:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  359:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  360:    }
        -:  361:    
       23:  362:    size_t text_len = strlen(text);
       23:  363:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  364:        return MERCURY_SUCCESS;  // Nothing to append
        -:  365:    }
        -:  366:    
       23:  367:    size_t new_length = str->length + text_len;
        -:  368:    
        -:  369:    // Resize buffer if necessary with better growth strategy
       23:  370:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 taken 52% (fallthrough)
branch  1 taken 48%
        -:  371:        // Growth strategy: for small strings double, for large strings add 50%
        -:  372:        size_t new_capacity;
       12:  373:        if (str->capacity < 4096) {
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
        5:  374:            new_capacity = str->capacity * 2;
        -:  375:        } else {
        7:  376:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  377:        }
        -:  378:        
        -:  379:        // Ensure we have enough space
       12:  380:        if (new_capacity <= new_length) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        3:  381:            new_capacity = new_length + 256;  // Add some padding
        -:  382:        }
        -:  383:        
       12:  384:        char* new_data = realloc(str->data, new_capacity);
       12:  385:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  386:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  387:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  388:        }
        -:  389:        
       12:  390:        str->data = new_data;
       12:  391:        str->capacity = new_capacity;
        -:  392:    }
        -:  393:    
        -:  394:    // Use optimized copy based on text length
       23:  395:    char* dest = str->data + str->length;
        -:  396:    
        -:  397:    // Prefetch destination for write operations
       23:  398:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  399:    
        -:  400:    // For larger strings, prefetch additional cache lines
       23:  401:    if (text_len >= 64) {
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
       15:  402:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 returned 100%
        -:  403:    }
       23:  404:    if (text_len >= 128) {
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
       15:  405:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 returned 100%
        -:  406:    }
        -:  407:    
       23:  408:    if (text_len >= 32) {
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
        -:  409:        // SIMD path for large appends
       15:  410:        mercury_memcpy_simd(dest, text, text_len);
call    0 returned 100%
        8:  411:    } else if (text_len >= 8) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  412:        // Use 64-bit copies for medium strings
        -:  413:        const uint64_t* src64 = (const uint64_t*)text;
        -:  414:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  415:        size_t chunks = text_len / 8;
    #####:  416:        size_t remainder = text_len % 8;
        -:  417:        
    #####:  418:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  419:            dest64[i] = src64[i];
        -:  420:        }
        -:  421:        
        -:  422:        // Handle remainder
    #####:  423:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  424:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  425:        }
        -:  426:    } else {
        -:  427:        // Fast path for small strings
        -:  428:        memcpy(dest, text, text_len);
        -:  429:    }
        -:  430:    
       23:  431:    str->length = new_length;
       23:  432:    str->data[str->length] = '\0';
        -:  433:    
       23:  434:    return MERCURY_SUCCESS;
        -:  435:}
------------------
mercury_string_append:
function mercury_string_append called 11 returned 100% blocks executed 59%
       11:  357:MercuryError mercury_string_append(MercuryString* str, const char* text) {
       11:  358:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  359:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  360:    }
        -:  361:    
       11:  362:    size_t text_len = strlen(text);
       11:  363:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
        -:  364:        return MERCURY_SUCCESS;  // Nothing to append
        -:  365:    }
        -:  366:    
       10:  367:    size_t new_length = str->length + text_len;
        -:  368:    
        -:  369:    // Resize buffer if necessary with better growth strategy
       10:  370:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
        -:  371:        // Growth strategy: for small strings double, for large strings add 50%
        -:  372:        size_t new_capacity;
        1:  373:        if (str->capacity < 4096) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  374:            new_capacity = str->capacity * 2;
        -:  375:        } else {
    #####:  376:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  377:        }
        -:  378:        
        -:  379:        // Ensure we have enough space
        1:  380:        if (new_capacity <= new_length) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  381:            new_capacity = new_length + 256;  // Add some padding
        -:  382:        }
        -:  383:        
        1:  384:        char* new_data = realloc(str->data, new_capacity);
        1:  385:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  386:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  387:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  388:        }
        -:  389:        
        1:  390:        str->data = new_data;
        1:  391:        str->capacity = new_capacity;
        -:  392:    }
        -:  393:    
        -:  394:    // Use optimized copy based on text length
       10:  395:    char* dest = str->data + str->length;
        -:  396:    
        -:  397:    // Prefetch destination for write operations
       10:  398:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  399:    
        -:  400:    // For larger strings, prefetch additional cache lines
       10:  401:    if (text_len >= 64) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  402:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  403:    }
       10:  404:    if (text_len >= 128) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  405:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  406:    }
        -:  407:    
       10:  408:    if (text_len >= 32) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  409:        // SIMD path for large appends
    #####:  410:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
       10:  411:    } else if (text_len >= 8) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  412:        // Use 64-bit copies for medium strings
        -:  413:        const uint64_t* src64 = (const uint64_t*)text;
        -:  414:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  415:        size_t chunks = text_len / 8;
    #####:  416:        size_t remainder = text_len % 8;
        -:  417:        
    #####:  418:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  419:            dest64[i] = src64[i];
        -:  420:        }
        -:  421:        
        -:  422:        // Handle remainder
    #####:  423:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  424:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  425:        }
        -:  426:    } else {
        -:  427:        // Fast path for small strings
        -:  428:        memcpy(dest, text, text_len);
        -:  429:    }
        -:  430:    
       10:  431:    str->length = new_length;
       10:  432:    str->data[str->length] = '\0';
        -:  433:    
       10:  434:    return MERCURY_SUCCESS;
        -:  435:}
------------------
mercury_string_append:
function mercury_string_append called 33 returned 100% blocks executed 81%
       33:  357:MercuryError mercury_string_append(MercuryString* str, const char* text) {
       33:  358:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  359:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  360:    }
        -:  361:    
       33:  362:    size_t text_len = strlen(text);
       33:  363:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  364:        return MERCURY_SUCCESS;  // Nothing to append
        -:  365:    }
        -:  366:    
       33:  367:    size_t new_length = str->length + text_len;
        -:  368:    
        -:  369:    // Resize buffer if necessary with better growth strategy
       33:  370:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
        -:  371:        // Growth strategy: for small strings double, for large strings add 50%
        -:  372:        size_t new_capacity;
        7:  373:        if (str->capacity < 4096) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        7:  374:            new_capacity = str->capacity * 2;
        -:  375:        } else {
    #####:  376:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  377:        }
        -:  378:        
        -:  379:        // Ensure we have enough space
        7:  380:        if (new_capacity <= new_length) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  381:            new_capacity = new_length + 256;  // Add some padding
        -:  382:        }
        -:  383:        
        7:  384:        char* new_data = realloc(str->data, new_capacity);
        7:  385:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  386:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  387:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  388:        }
        -:  389:        
        7:  390:        str->data = new_data;
        7:  391:        str->capacity = new_capacity;
        -:  392:    }
        -:  393:    
        -:  394:    // Use optimized copy based on text length
       33:  395:    char* dest = str->data + str->length;
        -:  396:    
        -:  397:    // Prefetch destination for write operations
       33:  398:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  399:    
        -:  400:    // For larger strings, prefetch additional cache lines
       33:  401:    if (text_len >= 64) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  402:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  403:    }
       33:  404:    if (text_len >= 128) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  405:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  406:    }
        -:  407:    
       33:  408:    if (text_len >= 32) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -:  409:        // SIMD path for large appends
        1:  410:        mercury_memcpy_simd(dest, text, text_len);
call    0 returned 100%
       32:  411:    } else if (text_len >= 8) {
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
        -:  412:        // Use 64-bit copies for medium strings
        -:  413:        const uint64_t* src64 = (const uint64_t*)text;
        -:  414:        uint64_t* dest64 = (uint64_t*)dest;
        3:  415:        size_t chunks = text_len / 8;
        3:  416:        size_t remainder = text_len % 8;
        -:  417:        
        7:  418:        for (size_t i = 0; i < chunks; i++) {
branch  0 taken 57%
branch  1 taken 43% (fallthrough)
        4:  419:            dest64[i] = src64[i];
        -:  420:        }
        -:  421:        
        -:  422:        // Handle remainder
        3:  423:        if (remainder > 0) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:  424:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  425:        }
        -:  426:    } else {
        -:  427:        // Fast path for small strings
        -:  428:        memcpy(dest, text, text_len);
        -:  429:    }
        -:  430:    
       33:  431:    str->length = new_length;
       33:  432:    str->data[str->length] = '\0';
        -:  433:    
       33:  434:    return MERCURY_SUCCESS;
        -:  435:}
------------------
mercury_string_append:
function mercury_string_append called 0 returned 0% blocks executed 0%
    #####:  357:MercuryError mercury_string_append(MercuryString* str, const char* text) {
    #####:  358:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 never executed
branch  1 never executed
        -:  359:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  360:    }
        -:  361:    
    #####:  362:    size_t text_len = strlen(text);
    #####:  363:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 never executed
branch  1 never executed
        -:  364:        return MERCURY_SUCCESS;  // Nothing to append
        -:  365:    }
        -:  366:    
    #####:  367:    size_t new_length = str->length + text_len;
        -:  368:    
        -:  369:    // Resize buffer if necessary with better growth strategy
    #####:  370:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  371:        // Growth strategy: for small strings double, for large strings add 50%
        -:  372:        size_t new_capacity;
    #####:  373:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  374:            new_capacity = str->capacity * 2;
        -:  375:        } else {
    #####:  376:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  377:        }
        -:  378:        
        -:  379:        // Ensure we have enough space
    #####:  380:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  381:            new_capacity = new_length + 256;  // Add some padding
        -:  382:        }
        -:  383:        
    #####:  384:        char* new_data = realloc(str->data, new_capacity);
    #####:  385:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  386:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  387:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  388:        }
        -:  389:        
    #####:  390:        str->data = new_data;
    #####:  391:        str->capacity = new_capacity;
        -:  392:    }
        -:  393:    
        -:  394:    // Use optimized copy based on text length
    #####:  395:    char* dest = str->data + str->length;
        -:  396:    
        -:  397:    // Prefetch destination for write operations
    #####:  398:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  399:    
        -:  400:    // For larger strings, prefetch additional cache lines
    #####:  401:    if (text_len >= 64) {
branch  0 never executed
branch  1 never executed
    #####:  402:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  403:    }
    #####:  404:    if (text_len >= 128) {
branch  0 never executed
branch  1 never executed
    #####:  405:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  406:    }
        -:  407:    
    #####:  408:    if (text_len >= 32) {
branch  0 never executed
branch  1 never executed
        -:  409:        // SIMD path for large appends
    #####:  410:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
    #####:  411:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  412:        // Use 64-bit copies for medium strings
        -:  413:        const uint64_t* src64 = (const uint64_t*)text;
        -:  414:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  415:        size_t chunks = text_len / 8;
    #####:  416:        size_t remainder = text_len % 8;
        -:  417:        
    #####:  418:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  419:            dest64[i] = src64[i];
        -:  420:        }
        -:  421:        
        -:  422:        // Handle remainder
    #####:  423:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  424:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  425:        }
        -:  426:    } else {
        -:  427:        // Fast path for small strings
        -:  428:        memcpy(dest, text, text_len);
        -:  429:    }
        -:  430:    
    #####:  431:    str->length = new_length;
    #####:  432:    str->data[str->length] = '\0';
        -:  433:    
    #####:  434:    return MERCURY_SUCCESS;
        -:  435:}
------------------
mercury_string_append:
function mercury_string_append called 0 returned 0% blocks executed 0%
    #####:  357:MercuryError mercury_string_append(MercuryString* str, const char* text) {
    #####:  358:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 never executed
branch  1 never executed
        -:  359:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  360:    }
        -:  361:    
    #####:  362:    size_t text_len = strlen(text);
    #####:  363:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 never executed
branch  1 never executed
        -:  364:        return MERCURY_SUCCESS;  // Nothing to append
        -:  365:    }
        -:  366:    
    #####:  367:    size_t new_length = str->length + text_len;
        -:  368:    
        -:  369:    // Resize buffer if necessary with better growth strategy
    #####:  370:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  371:        // Growth strategy: for small strings double, for large strings add 50%
        -:  372:        size_t new_capacity;
    #####:  373:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  374:            new_capacity = str->capacity * 2;
        -:  375:        } else {
    #####:  376:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  377:        }
        -:  378:        
        -:  379:        // Ensure we have enough space
    #####:  380:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  381:            new_capacity = new_length + 256;  // Add some padding
        -:  382:        }
        -:  383:        
    #####:  384:        char* new_data = realloc(str->data, new_capacity);
    #####:  385:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  386:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  387:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  388:        }
        -:  389:        
    #####:  390:        str->data = new_data;
    #####:  391:        str->capacity = new_capacity;
        -:  392:    }
        -:  393:    
        -:  394:    // Use optimized copy based on text length
    #####:  395:    char* dest = str->data + str->length;
        -:  396:    
        -:  397:    // Prefetch destination for write operations
    #####:  398:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  399:    
        -:  400:    // For larger strings, prefetch additional cache lines
    #####:  401:    if (text_len >= 64) {
branch  0 never executed
branch  1 never executed
    #####:  402:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  403:    }
    #####:  404:    if (text_len >= 128) {
branch  0 never executed
branch  1 never executed
    #####:  405:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  406:    }
        -:  407:    
    #####:  408:    if (text_len >= 32) {
branch  0 never executed
branch  1 never executed
        -:  409:        // SIMD path for large appends
    #####:  410:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
    #####:  411:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  412:        // Use 64-bit copies for medium strings
        -:  413:        const uint64_t* src64 = (const uint64_t*)text;
        -:  414:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  415:        size_t chunks = text_len / 8;
    #####:  416:        size_t remainder = text_len % 8;
        -:  417:        
    #####:  418:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  419:            dest64[i] = src64[i];
        -:  420:        }
        -:  421:        
        -:  422:        // Handle remainder
    #####:  423:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  424:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  425:        }
        -:  426:    } else {
        -:  427:        // Fast path for small strings
        -:  428:        memcpy(dest, text, text_len);
        -:  429:    }
        -:  430:    
    #####:  431:    str->length = new_length;
    #####:  432:    str->data[str->length] = '\0';
        -:  433:    
    #####:  434:    return MERCURY_SUCCESS;
        -:  435:}
------------------
mercury_string_append:
function mercury_string_append called 0 returned 0% blocks executed 0%
    #####:  357:MercuryError mercury_string_append(MercuryString* str, const char* text) {
    #####:  358:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 never executed
branch  1 never executed
        -:  359:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  360:    }
        -:  361:    
    #####:  362:    size_t text_len = strlen(text);
    #####:  363:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 never executed
branch  1 never executed
        -:  364:        return MERCURY_SUCCESS;  // Nothing to append
        -:  365:    }
        -:  366:    
    #####:  367:    size_t new_length = str->length + text_len;
        -:  368:    
        -:  369:    // Resize buffer if necessary with better growth strategy
    #####:  370:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  371:        // Growth strategy: for small strings double, for large strings add 50%
        -:  372:        size_t new_capacity;
    #####:  373:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  374:            new_capacity = str->capacity * 2;
        -:  375:        } else {
    #####:  376:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  377:        }
        -:  378:        
        -:  379:        // Ensure we have enough space
    #####:  380:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  381:            new_capacity = new_length + 256;  // Add some padding
        -:  382:        }
        -:  383:        
    #####:  384:        char* new_data = realloc(str->data, new_capacity);
    #####:  385:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  386:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  387:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  388:        }
        -:  389:        
    #####:  390:        str->data = new_data;
    #####:  391:        str->capacity = new_capacity;
        -:  392:    }
        -:  393:    
        -:  394:    // Use optimized copy based on text length
    #####:  395:    char* dest = str->data + str->length;
        -:  396:    
        -:  397:    // Prefetch destination for write operations
    #####:  398:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  399:    
        -:  400:    // For larger strings, prefetch additional cache lines
    #####:  401:    if (text_len >= 64) {
branch  0 never executed
branch  1 never executed
    #####:  402:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  403:    }
    #####:  404:    if (text_len >= 128) {
branch  0 never executed
branch  1 never executed
    #####:  405:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  406:    }
        -:  407:    
    #####:  408:    if (text_len >= 32) {
branch  0 never executed
branch  1 never executed
        -:  409:        // SIMD path for large appends
    #####:  410:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
    #####:  411:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  412:        // Use 64-bit copies for medium strings
        -:  413:        const uint64_t* src64 = (const uint64_t*)text;
        -:  414:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  415:        size_t chunks = text_len / 8;
    #####:  416:        size_t remainder = text_len % 8;
        -:  417:        
    #####:  418:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  419:            dest64[i] = src64[i];
        -:  420:        }
        -:  421:        
        -:  422:        // Handle remainder
    #####:  423:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  424:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  425:        }
        -:  426:    } else {
        -:  427:        // Fast path for small strings
        -:  428:        memcpy(dest, text, text_len);
        -:  429:    }
        -:  430:    
    #####:  431:    str->length = new_length;
    #####:  432:    str->data[str->length] = '\0';
        -:  433:    
    #####:  434:    return MERCURY_SUCCESS;
        -:  435:}
------------------
mercury_string_append:
function mercury_string_append called 0 returned 0% blocks executed 0%
    #####:  357:MercuryError mercury_string_append(MercuryString* str, const char* text) {
    #####:  358:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 never executed
branch  1 never executed
        -:  359:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  360:    }
        -:  361:    
    #####:  362:    size_t text_len = strlen(text);
    #####:  363:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 never executed
branch  1 never executed
        -:  364:        return MERCURY_SUCCESS;  // Nothing to append
        -:  365:    }
        -:  366:    
    #####:  367:    size_t new_length = str->length + text_len;
        -:  368:    
        -:  369:    // Resize buffer if necessary with better growth strategy
    #####:  370:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  371:        // Growth strategy: for small strings double, for large strings add 50%
        -:  372:        size_t new_capacity;
    #####:  373:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  374:            new_capacity = str->capacity * 2;
        -:  375:        } else {
    #####:  376:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  377:        }
        -:  378:        
        -:  379:        // Ensure we have enough space
    #####:  380:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  381:            new_capacity = new_length + 256;  // Add some padding
        -:  382:        }
        -:  383:        
    #####:  384:        char* new_data = realloc(str->data, new_capacity);
    #####:  385:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  386:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  387:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  388:        }
        -:  389:        
    #####:  390:        str->data = new_data;
    #####:  391:        str->capacity = new_capacity;
        -:  392:    }
        -:  393:    
        -:  394:    // Use optimized copy based on text length
    #####:  395:    char* dest = str->data + str->length;
        -:  396:    
        -:  397:    // Prefetch destination for write operations
    #####:  398:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  399:    
        -:  400:    // For larger strings, prefetch additional cache lines
    #####:  401:    if (text_len >= 64) {
branch  0 never executed
branch  1 never executed
    #####:  402:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  403:    }
    #####:  404:    if (text_len >= 128) {
branch  0 never executed
branch  1 never executed
    #####:  405:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  406:    }
        -:  407:    
    #####:  408:    if (text_len >= 32) {
branch  0 never executed
branch  1 never executed
        -:  409:        // SIMD path for large appends
    #####:  410:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
    #####:  411:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  412:        // Use 64-bit copies for medium strings
        -:  413:        const uint64_t* src64 = (const uint64_t*)text;
        -:  414:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  415:        size_t chunks = text_len / 8;
    #####:  416:        size_t remainder = text_len % 8;
        -:  417:        
    #####:  418:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  419:            dest64[i] = src64[i];
        -:  420:        }
        -:  421:        
        -:  422:        // Handle remainder
    #####:  423:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  424:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  425:        }
        -:  426:    } else {
        -:  427:        // Fast path for small strings
        -:  428:        memcpy(dest, text, text_len);
        -:  429:    }
        -:  430:    
    #####:  431:    str->length = new_length;
    #####:  432:    str->data[str->length] = '\0';
        -:  433:    
    #####:  434:    return MERCURY_SUCCESS;
        -:  435:}
------------------
mercury_string_append:
function mercury_string_append called 0 returned 0% blocks executed 0%
    #####:  357:MercuryError mercury_string_append(MercuryString* str, const char* text) {
    #####:  358:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 never executed
branch  1 never executed
        -:  359:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  360:    }
        -:  361:    
    #####:  362:    size_t text_len = strlen(text);
    #####:  363:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 never executed
branch  1 never executed
        -:  364:        return MERCURY_SUCCESS;  // Nothing to append
        -:  365:    }
        -:  366:    
    #####:  367:    size_t new_length = str->length + text_len;
        -:  368:    
        -:  369:    // Resize buffer if necessary with better growth strategy
    #####:  370:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  371:        // Growth strategy: for small strings double, for large strings add 50%
        -:  372:        size_t new_capacity;
    #####:  373:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  374:            new_capacity = str->capacity * 2;
        -:  375:        } else {
    #####:  376:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  377:        }
        -:  378:        
        -:  379:        // Ensure we have enough space
    #####:  380:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  381:            new_capacity = new_length + 256;  // Add some padding
        -:  382:        }
        -:  383:        
    #####:  384:        char* new_data = realloc(str->data, new_capacity);
    #####:  385:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  386:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  387:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  388:        }
        -:  389:        
    #####:  390:        str->data = new_data;
    #####:  391:        str->capacity = new_capacity;
        -:  392:    }
        -:  393:    
        -:  394:    // Use optimized copy based on text length
    #####:  395:    char* dest = str->data + str->length;
        -:  396:    
        -:  397:    // Prefetch destination for write operations
    #####:  398:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  399:    
        -:  400:    // For larger strings, prefetch additional cache lines
    #####:  401:    if (text_len >= 64) {
branch  0 never executed
branch  1 never executed
    #####:  402:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  403:    }
    #####:  404:    if (text_len >= 128) {
branch  0 never executed
branch  1 never executed
    #####:  405:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  406:    }
        -:  407:    
    #####:  408:    if (text_len >= 32) {
branch  0 never executed
branch  1 never executed
        -:  409:        // SIMD path for large appends
    #####:  410:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
    #####:  411:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  412:        // Use 64-bit copies for medium strings
        -:  413:        const uint64_t* src64 = (const uint64_t*)text;
        -:  414:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  415:        size_t chunks = text_len / 8;
    #####:  416:        size_t remainder = text_len % 8;
        -:  417:        
    #####:  418:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  419:            dest64[i] = src64[i];
        -:  420:        }
        -:  421:        
        -:  422:        // Handle remainder
    #####:  423:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  424:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  425:        }
        -:  426:    } else {
        -:  427:        // Fast path for small strings
        -:  428:        memcpy(dest, text, text_len);
        -:  429:    }
        -:  430:    
    #####:  431:    str->length = new_length;
    #####:  432:    str->data[str->length] = '\0';
        -:  433:    
    #####:  434:    return MERCURY_SUCCESS;
        -:  435:}
------------------
mercury_string_append:
function mercury_string_append called 1 returned 100% blocks executed 41%
        1:  357:MercuryError mercury_string_append(MercuryString* str, const char* text) {
        1:  358:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  359:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  360:    }
        -:  361:    
        1:  362:    size_t text_len = strlen(text);
        1:  363:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  364:        return MERCURY_SUCCESS;  // Nothing to append
        -:  365:    }
        -:  366:    
        1:  367:    size_t new_length = str->length + text_len;
        -:  368:    
        -:  369:    // Resize buffer if necessary with better growth strategy
        1:  370:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  371:        // Growth strategy: for small strings double, for large strings add 50%
        -:  372:        size_t new_capacity;
    #####:  373:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  374:            new_capacity = str->capacity * 2;
        -:  375:        } else {
    #####:  376:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  377:        }
        -:  378:        
        -:  379:        // Ensure we have enough space
    #####:  380:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  381:            new_capacity = new_length + 256;  // Add some padding
        -:  382:        }
        -:  383:        
    #####:  384:        char* new_data = realloc(str->data, new_capacity);
    #####:  385:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  386:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  387:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  388:        }
        -:  389:        
    #####:  390:        str->data = new_data;
    #####:  391:        str->capacity = new_capacity;
        -:  392:    }
        -:  393:    
        -:  394:    // Use optimized copy based on text length
        1:  395:    char* dest = str->data + str->length;
        -:  396:    
        -:  397:    // Prefetch destination for write operations
        1:  398:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  399:    
        -:  400:    // For larger strings, prefetch additional cache lines
        1:  401:    if (text_len >= 64) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  402:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 returned 100%
        -:  403:    }
        1:  404:    if (text_len >= 128) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  405:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  406:    }
        -:  407:    
        1:  408:    if (text_len >= 32) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  409:        // SIMD path for large appends
        1:  410:        mercury_memcpy_simd(dest, text, text_len);
call    0 returned 100%
    #####:  411:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  412:        // Use 64-bit copies for medium strings
        -:  413:        const uint64_t* src64 = (const uint64_t*)text;
        -:  414:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  415:        size_t chunks = text_len / 8;
    #####:  416:        size_t remainder = text_len % 8;
        -:  417:        
    #####:  418:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  419:            dest64[i] = src64[i];
        -:  420:        }
        -:  421:        
        -:  422:        // Handle remainder
    #####:  423:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  424:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  425:        }
        -:  426:    } else {
        -:  427:        // Fast path for small strings
        -:  428:        memcpy(dest, text, text_len);
        -:  429:    }
        -:  430:    
        1:  431:    str->length = new_length;
        1:  432:    str->data[str->length] = '\0';
        -:  433:    
        1:  434:    return MERCURY_SUCCESS;
        -:  435:}
------------------
mercury_string_append:
function mercury_string_append called 2 returned 100% blocks executed 41%
        2:  357:MercuryError mercury_string_append(MercuryString* str, const char* text) {
        2:  358:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  359:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  360:    }
        -:  361:    
        2:  362:    size_t text_len = strlen(text);
        2:  363:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  364:        return MERCURY_SUCCESS;  // Nothing to append
        -:  365:    }
        -:  366:    
        2:  367:    size_t new_length = str->length + text_len;
        -:  368:    
        -:  369:    // Resize buffer if necessary with better growth strategy
        2:  370:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  371:        // Growth strategy: for small strings double, for large strings add 50%
        -:  372:        size_t new_capacity;
    #####:  373:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  374:            new_capacity = str->capacity * 2;
        -:  375:        } else {
    #####:  376:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  377:        }
        -:  378:        
        -:  379:        // Ensure we have enough space
    #####:  380:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  381:            new_capacity = new_length + 256;  // Add some padding
        -:  382:        }
        -:  383:        
    #####:  384:        char* new_data = realloc(str->data, new_capacity);
    #####:  385:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  386:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  387:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  388:        }
        -:  389:        
    #####:  390:        str->data = new_data;
    #####:  391:        str->capacity = new_capacity;
        -:  392:    }
        -:  393:    
        -:  394:    // Use optimized copy based on text length
        2:  395:    char* dest = str->data + str->length;
        -:  396:    
        -:  397:    // Prefetch destination for write operations
        2:  398:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  399:    
        -:  400:    // For larger strings, prefetch additional cache lines
        2:  401:    if (text_len >= 64) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  402:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 returned 100%
        -:  403:    }
        2:  404:    if (text_len >= 128) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  405:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  406:    }
        -:  407:    
        2:  408:    if (text_len >= 32) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  409:        // SIMD path for large appends
        2:  410:        mercury_memcpy_simd(dest, text, text_len);
call    0 returned 100%
    #####:  411:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  412:        // Use 64-bit copies for medium strings
        -:  413:        const uint64_t* src64 = (const uint64_t*)text;
        -:  414:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  415:        size_t chunks = text_len / 8;
    #####:  416:        size_t remainder = text_len % 8;
        -:  417:        
    #####:  418:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  419:            dest64[i] = src64[i];
        -:  420:        }
        -:  421:        
        -:  422:        // Handle remainder
    #####:  423:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  424:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  425:        }
        -:  426:    } else {
        -:  427:        // Fast path for small strings
        -:  428:        memcpy(dest, text, text_len);
        -:  429:    }
        -:  430:    
        2:  431:    str->length = new_length;
        2:  432:    str->data[str->length] = '\0';
        -:  433:    
        2:  434:    return MERCURY_SUCCESS;
        -:  435:}
------------------
mercury_string_append:
function mercury_string_append called 0 returned 0% blocks executed 0%
    #####:  357:MercuryError mercury_string_append(MercuryString* str, const char* text) {
    #####:  358:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 never executed
branch  1 never executed
        -:  359:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  360:    }
        -:  361:    
    #####:  362:    size_t text_len = strlen(text);
    #####:  363:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 never executed
branch  1 never executed
        -:  364:        return MERCURY_SUCCESS;  // Nothing to append
        -:  365:    }
        -:  366:    
    #####:  367:    size_t new_length = str->length + text_len;
        -:  368:    
        -:  369:    // Resize buffer if necessary with better growth strategy
    #####:  370:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  371:        // Growth strategy: for small strings double, for large strings add 50%
        -:  372:        size_t new_capacity;
    #####:  373:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  374:            new_capacity = str->capacity * 2;
        -:  375:        } else {
    #####:  376:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  377:        }
        -:  378:        
        -:  379:        // Ensure we have enough space
    #####:  380:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  381:            new_capacity = new_length + 256;  // Add some padding
        -:  382:        }
        -:  383:        
    #####:  384:        char* new_data = realloc(str->data, new_capacity);
    #####:  385:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  386:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  387:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  388:        }
        -:  389:        
    #####:  390:        str->data = new_data;
    #####:  391:        str->capacity = new_capacity;
        -:  392:    }
        -:  393:    
        -:  394:    // Use optimized copy based on text length
    #####:  395:    char* dest = str->data + str->length;
        -:  396:    
        -:  397:    // Prefetch destination for write operations
    #####:  398:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  399:    
        -:  400:    // For larger strings, prefetch additional cache lines
    #####:  401:    if (text_len >= 64) {
branch  0 never executed
branch  1 never executed
    #####:  402:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  403:    }
    #####:  404:    if (text_len >= 128) {
branch  0 never executed
branch  1 never executed
    #####:  405:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  406:    }
        -:  407:    
    #####:  408:    if (text_len >= 32) {
branch  0 never executed
branch  1 never executed
        -:  409:        // SIMD path for large appends
    #####:  410:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
    #####:  411:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  412:        // Use 64-bit copies for medium strings
        -:  413:        const uint64_t* src64 = (const uint64_t*)text;
        -:  414:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  415:        size_t chunks = text_len / 8;
    #####:  416:        size_t remainder = text_len % 8;
        -:  417:        
    #####:  418:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  419:            dest64[i] = src64[i];
        -:  420:        }
        -:  421:        
        -:  422:        // Handle remainder
    #####:  423:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  424:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  425:        }
        -:  426:    } else {
        -:  427:        // Fast path for small strings
        -:  428:        memcpy(dest, text, text_len);
        -:  429:    }
        -:  430:    
    #####:  431:    str->length = new_length;
    #####:  432:    str->data[str->length] = '\0';
        -:  433:    
    #####:  434:    return MERCURY_SUCCESS;
        -:  435:}
------------------
mercury_string_append:
function mercury_string_append called 0 returned 0% blocks executed 0%
    #####:  357:MercuryError mercury_string_append(MercuryString* str, const char* text) {
    #####:  358:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 never executed
branch  1 never executed
        -:  359:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  360:    }
        -:  361:    
    #####:  362:    size_t text_len = strlen(text);
    #####:  363:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 never executed
branch  1 never executed
        -:  364:        return MERCURY_SUCCESS;  // Nothing to append
        -:  365:    }
        -:  366:    
    #####:  367:    size_t new_length = str->length + text_len;
        -:  368:    
        -:  369:    // Resize buffer if necessary with better growth strategy
    #####:  370:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  371:        // Growth strategy: for small strings double, for large strings add 50%
        -:  372:        size_t new_capacity;
    #####:  373:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  374:            new_capacity = str->capacity * 2;
        -:  375:        } else {
    #####:  376:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  377:        }
        -:  378:        
        -:  379:        // Ensure we have enough space
    #####:  380:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  381:            new_capacity = new_length + 256;  // Add some padding
        -:  382:        }
        -:  383:        
    #####:  384:        char* new_data = realloc(str->data, new_capacity);
    #####:  385:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  386:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  387:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  388:        }
        -:  389:        
    #####:  390:        str->data = new_data;
    #####:  391:        str->capacity = new_capacity;
        -:  392:    }
        -:  393:    
        -:  394:    // Use optimized copy based on text length
    #####:  395:    char* dest = str->data + str->length;
        -:  396:    
        -:  397:    // Prefetch destination for write operations
    #####:  398:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  399:    
        -:  400:    // For larger strings, prefetch additional cache lines
    #####:  401:    if (text_len >= 64) {
branch  0 never executed
branch  1 never executed
    #####:  402:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  403:    }
    #####:  404:    if (text_len >= 128) {
branch  0 never executed
branch  1 never executed
    #####:  405:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  406:    }
        -:  407:    
    #####:  408:    if (text_len >= 32) {
branch  0 never executed
branch  1 never executed
        -:  409:        // SIMD path for large appends
    #####:  410:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
    #####:  411:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  412:        // Use 64-bit copies for medium strings
        -:  413:        const uint64_t* src64 = (const uint64_t*)text;
        -:  414:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  415:        size_t chunks = text_len / 8;
    #####:  416:        size_t remainder = text_len % 8;
        -:  417:        
    #####:  418:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  419:            dest64[i] = src64[i];
        -:  420:        }
        -:  421:        
        -:  422:        // Handle remainder
    #####:  423:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  424:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  425:        }
        -:  426:    } else {
        -:  427:        // Fast path for small strings
        -:  428:        memcpy(dest, text, text_len);
        -:  429:    }
        -:  430:    
    #####:  431:    str->length = new_length;
    #####:  432:    str->data[str->length] = '\0';
        -:  433:    
    #####:  434:    return MERCURY_SUCCESS;
        -:  435:}
------------------
mercury_string_append:
function mercury_string_append called 0 returned 0% blocks executed 0%
    #####:  357:MercuryError mercury_string_append(MercuryString* str, const char* text) {
    #####:  358:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 never executed
branch  1 never executed
        -:  359:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  360:    }
        -:  361:    
    #####:  362:    size_t text_len = strlen(text);
    #####:  363:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 never executed
branch  1 never executed
        -:  364:        return MERCURY_SUCCESS;  // Nothing to append
        -:  365:    }
        -:  366:    
    #####:  367:    size_t new_length = str->length + text_len;
        -:  368:    
        -:  369:    // Resize buffer if necessary with better growth strategy
    #####:  370:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  371:        // Growth strategy: for small strings double, for large strings add 50%
        -:  372:        size_t new_capacity;
    #####:  373:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  374:            new_capacity = str->capacity * 2;
        -:  375:        } else {
    #####:  376:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  377:        }
        -:  378:        
        -:  379:        // Ensure we have enough space
    #####:  380:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  381:            new_capacity = new_length + 256;  // Add some padding
        -:  382:        }
        -:  383:        
    #####:  384:        char* new_data = realloc(str->data, new_capacity);
    #####:  385:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  386:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  387:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  388:        }
        -:  389:        
    #####:  390:        str->data = new_data;
    #####:  391:        str->capacity = new_capacity;
        -:  392:    }
        -:  393:    
        -:  394:    // Use optimized copy based on text length
    #####:  395:    char* dest = str->data + str->length;
        -:  396:    
        -:  397:    // Prefetch destination for write operations
    #####:  398:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  399:    
        -:  400:    // For larger strings, prefetch additional cache lines
    #####:  401:    if (text_len >= 64) {
branch  0 never executed
branch  1 never executed
    #####:  402:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  403:    }
    #####:  404:    if (text_len >= 128) {
branch  0 never executed
branch  1 never executed
    #####:  405:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  406:    }
        -:  407:    
    #####:  408:    if (text_len >= 32) {
branch  0 never executed
branch  1 never executed
        -:  409:        // SIMD path for large appends
    #####:  410:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
    #####:  411:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  412:        // Use 64-bit copies for medium strings
        -:  413:        const uint64_t* src64 = (const uint64_t*)text;
        -:  414:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  415:        size_t chunks = text_len / 8;
    #####:  416:        size_t remainder = text_len % 8;
        -:  417:        
    #####:  418:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  419:            dest64[i] = src64[i];
        -:  420:        }
        -:  421:        
        -:  422:        // Handle remainder
    #####:  423:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  424:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  425:        }
        -:  426:    } else {
        -:  427:        // Fast path for small strings
        -:  428:        memcpy(dest, text, text_len);
        -:  429:    }
        -:  430:    
    #####:  431:    str->length = new_length;
    #####:  432:    str->data[str->length] = '\0';
        -:  433:    
    #####:  434:    return MERCURY_SUCCESS;
        -:  435:}
------------------
        -:  436:
      39*:  437:MercuryError mercury_string_append_char(MercuryString* str, char c) {
      39*:  438:    char temp[2] = {c, '\0'};
      39*:  439:    return mercury_string_append(str, temp);
        -:  440:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  437:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  438:    char temp[2] = {c, '\0'};
    #####:  439:    return mercury_string_append(str, temp);
call    0 never executed
        -:  440:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 2 returned 100% blocks executed 100%
        2:  437:MercuryError mercury_string_append_char(MercuryString* str, char c) {
        2:  438:    char temp[2] = {c, '\0'};
        2:  439:    return mercury_string_append(str, temp);
call    0 returned 100%
        -:  440:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 11 returned 100% blocks executed 100%
       11:  437:MercuryError mercury_string_append_char(MercuryString* str, char c) {
       11:  438:    char temp[2] = {c, '\0'};
       11:  439:    return mercury_string_append(str, temp);
call    0 returned 100%
        -:  440:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 26 returned 100% blocks executed 100%
       26:  437:MercuryError mercury_string_append_char(MercuryString* str, char c) {
       26:  438:    char temp[2] = {c, '\0'};
       26:  439:    return mercury_string_append(str, temp);
call    0 returned 100%
        -:  440:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  437:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  438:    char temp[2] = {c, '\0'};
    #####:  439:    return mercury_string_append(str, temp);
call    0 never executed
        -:  440:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  437:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  438:    char temp[2] = {c, '\0'};
    #####:  439:    return mercury_string_append(str, temp);
call    0 never executed
        -:  440:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  437:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  438:    char temp[2] = {c, '\0'};
    #####:  439:    return mercury_string_append(str, temp);
call    0 never executed
        -:  440:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  437:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  438:    char temp[2] = {c, '\0'};
    #####:  439:    return mercury_string_append(str, temp);
call    0 never executed
        -:  440:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  437:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  438:    char temp[2] = {c, '\0'};
    #####:  439:    return mercury_string_append(str, temp);
call    0 never executed
        -:  440:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  437:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  438:    char temp[2] = {c, '\0'};
    #####:  439:    return mercury_string_append(str, temp);
call    0 never executed
        -:  440:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  437:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  438:    char temp[2] = {c, '\0'};
    #####:  439:    return mercury_string_append(str, temp);
call    0 never executed
        -:  440:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  437:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  438:    char temp[2] = {c, '\0'};
    #####:  439:    return mercury_string_append(str, temp);
call    0 never executed
        -:  440:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  437:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  438:    char temp[2] = {c, '\0'};
    #####:  439:    return mercury_string_append(str, temp);
call    0 never executed
        -:  440:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  437:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  438:    char temp[2] = {c, '\0'};
    #####:  439:    return mercury_string_append(str, temp);
call    0 never executed
        -:  440:}
------------------
        -:  441:
       3*:  442:void mercury_string_clear(MercuryString* str) {
       3*:  443:    if (!str) return;
        -:  444:    
       3*:  445:    str->length = 0;
       3*:  446:    if (str->data) {
       3*:  447:        str->data[0] = '\0';
        -:  448:    }
        -:  449:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  442:void mercury_string_clear(MercuryString* str) {
    #####:  443:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  444:    
    #####:  445:    str->length = 0;
    #####:  446:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  447:        str->data[0] = '\0';
        -:  448:    }
        -:  449:}
------------------
mercury_string_clear:
function mercury_string_clear called 2 returned 100% blocks executed 100%
        2:  442:void mercury_string_clear(MercuryString* str) {
        2:  443:    if (!str) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  444:    
        2:  445:    str->length = 0;
        2:  446:    if (str->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  447:        str->data[0] = '\0';
        -:  448:    }
        -:  449:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  442:void mercury_string_clear(MercuryString* str) {
    #####:  443:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  444:    
    #####:  445:    str->length = 0;
    #####:  446:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  447:        str->data[0] = '\0';
        -:  448:    }
        -:  449:}
------------------
mercury_string_clear:
function mercury_string_clear called 1 returned 100% blocks executed 100%
        1:  442:void mercury_string_clear(MercuryString* str) {
        1:  443:    if (!str) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  444:    
        1:  445:    str->length = 0;
        1:  446:    if (str->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  447:        str->data[0] = '\0';
        -:  448:    }
        -:  449:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  442:void mercury_string_clear(MercuryString* str) {
    #####:  443:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  444:    
    #####:  445:    str->length = 0;
    #####:  446:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  447:        str->data[0] = '\0';
        -:  448:    }
        -:  449:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  442:void mercury_string_clear(MercuryString* str) {
    #####:  443:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  444:    
    #####:  445:    str->length = 0;
    #####:  446:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  447:        str->data[0] = '\0';
        -:  448:    }
        -:  449:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  442:void mercury_string_clear(MercuryString* str) {
    #####:  443:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  444:    
    #####:  445:    str->length = 0;
    #####:  446:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  447:        str->data[0] = '\0';
        -:  448:    }
        -:  449:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  442:void mercury_string_clear(MercuryString* str) {
    #####:  443:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  444:    
    #####:  445:    str->length = 0;
    #####:  446:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  447:        str->data[0] = '\0';
        -:  448:    }
        -:  449:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  442:void mercury_string_clear(MercuryString* str) {
    #####:  443:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  444:    
    #####:  445:    str->length = 0;
    #####:  446:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  447:        str->data[0] = '\0';
        -:  448:    }
        -:  449:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  442:void mercury_string_clear(MercuryString* str) {
    #####:  443:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  444:    
    #####:  445:    str->length = 0;
    #####:  446:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  447:        str->data[0] = '\0';
        -:  448:    }
        -:  449:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  442:void mercury_string_clear(MercuryString* str) {
    #####:  443:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  444:    
    #####:  445:    str->length = 0;
    #####:  446:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  447:        str->data[0] = '\0';
        -:  448:    }
        -:  449:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  442:void mercury_string_clear(MercuryString* str) {
    #####:  443:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  444:    
    #####:  445:    str->length = 0;
    #####:  446:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  447:        str->data[0] = '\0';
        -:  448:    }
        -:  449:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  442:void mercury_string_clear(MercuryString* str) {
    #####:  443:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  444:    
    #####:  445:    str->length = 0;
    #####:  446:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  447:        str->data[0] = '\0';
        -:  448:    }
        -:  449:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  442:void mercury_string_clear(MercuryString* str) {
    #####:  443:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  444:    
    #####:  445:    str->length = 0;
    #####:  446:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  447:        str->data[0] = '\0';
        -:  448:    }
        -:  449:}
------------------
        -:  450:
      11*:  451:const char* mercury_string_cstr(const MercuryString* str) {
      11*:  452:    if (!str || !str->data) {
    #####:  453:        return "";
        -:  454:    }
        -:  455:    return str->data;
        -:  456:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 1 returned 100% blocks executed 75%
        1:  451:const char* mercury_string_cstr(const MercuryString* str) {
        1:  452:    if (!str || !str->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  453:        return "";
        -:  454:    }
        -:  455:    return str->data;
        -:  456:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 6 returned 100% blocks executed 75%
        6:  451:const char* mercury_string_cstr(const MercuryString* str) {
        6:  452:    if (!str || !str->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  453:        return "";
        -:  454:    }
        -:  455:    return str->data;
        -:  456:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 1 returned 100% blocks executed 75%
        1:  451:const char* mercury_string_cstr(const MercuryString* str) {
        1:  452:    if (!str || !str->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  453:        return "";
        -:  454:    }
        -:  455:    return str->data;
        -:  456:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 0 returned 0% blocks executed 0%
    #####:  451:const char* mercury_string_cstr(const MercuryString* str) {
    #####:  452:    if (!str || !str->data) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  453:        return "";
        -:  454:    }
        -:  455:    return str->data;
        -:  456:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 0 returned 0% blocks executed 0%
    #####:  451:const char* mercury_string_cstr(const MercuryString* str) {
    #####:  452:    if (!str || !str->data) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  453:        return "";
        -:  454:    }
        -:  455:    return str->data;
        -:  456:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 0 returned 0% blocks executed 0%
    #####:  451:const char* mercury_string_cstr(const MercuryString* str) {
    #####:  452:    if (!str || !str->data) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  453:        return "";
        -:  454:    }
        -:  455:    return str->data;
        -:  456:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 0 returned 0% blocks executed 0%
    #####:  451:const char* mercury_string_cstr(const MercuryString* str) {
    #####:  452:    if (!str || !str->data) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  453:        return "";
        -:  454:    }
        -:  455:    return str->data;
        -:  456:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 0 returned 0% blocks executed 0%
    #####:  451:const char* mercury_string_cstr(const MercuryString* str) {
    #####:  452:    if (!str || !str->data) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  453:        return "";
        -:  454:    }
        -:  455:    return str->data;
        -:  456:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 0 returned 0% blocks executed 0%
    #####:  451:const char* mercury_string_cstr(const MercuryString* str) {
    #####:  452:    if (!str || !str->data) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  453:        return "";
        -:  454:    }
        -:  455:    return str->data;
        -:  456:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 1 returned 100% blocks executed 75%
        1:  451:const char* mercury_string_cstr(const MercuryString* str) {
        1:  452:    if (!str || !str->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  453:        return "";
        -:  454:    }
        -:  455:    return str->data;
        -:  456:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 2 returned 100% blocks executed 75%
        2:  451:const char* mercury_string_cstr(const MercuryString* str) {
        2:  452:    if (!str || !str->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  453:        return "";
        -:  454:    }
        -:  455:    return str->data;
        -:  456:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 0 returned 0% blocks executed 0%
    #####:  451:const char* mercury_string_cstr(const MercuryString* str) {
    #####:  452:    if (!str || !str->data) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  453:        return "";
        -:  454:    }
        -:  455:    return str->data;
        -:  456:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 0 returned 0% blocks executed 0%
    #####:  451:const char* mercury_string_cstr(const MercuryString* str) {
    #####:  452:    if (!str || !str->data) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  453:        return "";
        -:  454:    }
        -:  455:    return str->data;
        -:  456:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 0 returned 0% blocks executed 0%
    #####:  451:const char* mercury_string_cstr(const MercuryString* str) {
    #####:  452:    if (!str || !str->data) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  453:        return "";
        -:  454:    }
        -:  455:    return str->data;
        -:  456:}
------------------
        -:  457:
        -:  458:// === BOYER-MOORE IMPLEMENTATION ===
        -:  459:
        -:  460:static void compute_bad_char_table(const char* pattern, size_t pattern_len, int* bad_char_table) {
        -:  461:    // Initialize all entries to -1
   15420*:  462:    for (int i = 0; i < 256; i++) {
branch  0 taken 100%
branch  1 taken 1%
branch  2 taken 100%
branch  3 taken 1%
branch  4 taken 100%
branch  5 taken 1%
branch  6 taken 100%
branch  7 taken 1%
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 taken 100%
branch 19 taken 1%
branch 20 taken 100%
branch 21 taken 1%
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
   15360*:  463:        bad_char_table[i] = -1;
        -:  464:    }
        -:  465:    
        -:  466:    // Fill the actual positions of characters in pattern
    1450*:  467:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 taken 89%
branch  1 taken 11% (fallthrough)
branch  2 taken 95%
branch  3 taken 5% (fallthrough)
branch  4 taken 90%
branch  5 taken 10% (fallthrough)
branch  6 taken 97%
branch  7 taken 3% (fallthrough)
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 taken 96%
branch 19 taken 4% (fallthrough)
branch 20 taken 96%
branch 21 taken 4% (fallthrough)
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
    1390*:  468:        bad_char_table[(unsigned char)pattern[i]] = (int)i;
        -:  469:    }
        -:  470:}
        -:  471:
      60*:  472:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
      60*:  473:    int* suffix = malloc(pattern_len * sizeof(int));
      60*:  474:    if (!suffix) return;
        -:  475:    
        -:  476:    // Compute suffix array
      60*:  477:    suffix[pattern_len - 1] = pattern_len;
      60*:  478:    int g = pattern_len - 1;
        -:  479:    int f = 0;
        -:  480:    
    1390*:  481:    for (int i = pattern_len - 2; i >= 0; i--) {
    1330*:  482:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
      16*:  483:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  484:        } else {
        -:  485:            if (i < g) g = i;
        -:  486:            f = i;
    1437*:  487:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
     123*:  488:                g--;
        -:  489:            }
    1314*:  490:            suffix[i] = f - g;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Compute good suffix table
    1450*:  495:    for (size_t i = 0; i < pattern_len; i++) {
    1390*:  496:        good_suffix_table[i] = pattern_len;
        -:  497:    }
        -:  498:    
        -:  499:    int j = 0;
    1450*:  500:    for (int i = pattern_len - 1; i >= 0; i--) {
    1390*:  501:        if (suffix[i] == i + 1) {
     106*:  502:            for (; j < (int)(pattern_len - 1 - i); j++) {
      35*:  503:                if (good_suffix_table[j] == (int)pattern_len) {
      35*:  504:                    good_suffix_table[j] = pattern_len - 1 - i;
        -:  505:                }
        -:  506:            }
        -:  507:        }
        -:  508:    }
        -:  509:    
    1390*:  510:    for (size_t i = 0; i <= pattern_len - 2; i++) {
    1330*:  511:        good_suffix_table[pattern_len - 1 - suffix[i]] = pattern_len - 1 - i;
        -:  512:    }
        -:  513:    
      60*:  514:    free(suffix);
        -:  515:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 1 returned 100% blocks executed 76%
        1:  472:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
        1:  473:    int* suffix = malloc(pattern_len * sizeof(int));
        1:  474:    if (!suffix) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  475:    
        -:  476:    // Compute suffix array
        1:  477:    suffix[pattern_len - 1] = pattern_len;
        1:  478:    int g = pattern_len - 1;
        -:  479:    int f = 0;
        -:  480:    
        8:  481:    for (int i = pattern_len - 2; i >= 0; i--) {
branch  0 taken 88%
branch  1 taken 12%
       7*:  482:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  483:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  484:        } else {
        -:  485:            if (i < g) g = i;
        -:  486:            f = i;
        7:  487:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
    #####:  488:                g--;
        -:  489:            }
        7:  490:            suffix[i] = f - g;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Compute good suffix table
        9:  495:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 taken 89%
branch  1 taken 11%
        8:  496:        good_suffix_table[i] = pattern_len;
        -:  497:    }
        -:  498:    
        -:  499:    int j = 0;
        9:  500:    for (int i = pattern_len - 1; i >= 0; i--) {
branch  0 taken 89%
branch  1 taken 11%
        8:  501:        if (suffix[i] == i + 1) {
branch  0 taken 12%
branch  1 taken 88%
       1*:  502:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  503:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  504:                    good_suffix_table[j] = pattern_len - 1 - i;
        -:  505:                }
        -:  506:            }
        -:  507:        }
        -:  508:    }
        -:  509:    
        8:  510:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
        7:  511:        good_suffix_table[pattern_len - 1 - suffix[i]] = pattern_len - 1 - i;
        -:  512:    }
        -:  513:    
        1:  514:    free(suffix);
        -:  515:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 13 returned 100% blocks executed 100%
       13:  472:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
       13:  473:    int* suffix = malloc(pattern_len * sizeof(int));
       13:  474:    if (!suffix) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  475:    
        -:  476:    // Compute suffix array
       13:  477:    suffix[pattern_len - 1] = pattern_len;
       13:  478:    int g = pattern_len - 1;
        -:  479:    int f = 0;
        -:  480:    
      241:  481:    for (int i = pattern_len - 2; i >= 0; i--) {
branch  0 taken 95%
branch  1 taken 5%
      228:  482:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  483:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  484:        } else {
        -:  485:            if (i < g) g = i;
        -:  486:            f = i;
      246:  487:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 8%
branch  3 taken 92% (fallthrough)
       19:  488:                g--;
        -:  489:            }
      227:  490:            suffix[i] = f - g;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Compute good suffix table
      254:  495:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 taken 95%
branch  1 taken 5%
      241:  496:        good_suffix_table[i] = pattern_len;
        -:  497:    }
        -:  498:    
        -:  499:    int j = 0;
      254:  500:    for (int i = pattern_len - 1; i >= 0; i--) {
branch  0 taken 95%
branch  1 taken 5%
      241:  501:        if (suffix[i] == i + 1) {
branch  0 taken 6%
branch  1 taken 94%
       21:  502:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 taken 29%
branch  1 taken 71% (fallthrough)
        6:  503:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6:  504:                    good_suffix_table[j] = pattern_len - 1 - i;
        -:  505:                }
        -:  506:            }
        -:  507:        }
        -:  508:    }
        -:  509:    
      241:  510:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
      228:  511:        good_suffix_table[pattern_len - 1 - suffix[i]] = pattern_len - 1 - i;
        -:  512:    }
        -:  513:    
       13:  514:    free(suffix);
        -:  515:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 5 returned 100% blocks executed 100%
        5:  472:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
        5:  473:    int* suffix = malloc(pattern_len * sizeof(int));
        5:  474:    if (!suffix) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  475:    
        -:  476:    // Compute suffix array
        5:  477:    suffix[pattern_len - 1] = pattern_len;
        5:  478:    int g = pattern_len - 1;
        -:  479:    int f = 0;
        -:  480:    
       44:  481:    for (int i = pattern_len - 2; i >= 0; i--) {
branch  0 taken 89%
branch  1 taken 11%
       39:  482:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
branch  2 taken 79% (fallthrough)
branch  3 taken 21%
       15:  483:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  484:        } else {
        -:  485:            if (i < g) g = i;
        -:  486:            f = i;
       48:  487:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
branch  2 taken 62%
branch  3 taken 38% (fallthrough)
       24:  488:                g--;
        -:  489:            }
       24:  490:            suffix[i] = f - g;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Compute good suffix table
       49:  495:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 taken 90%
branch  1 taken 10%
       44:  496:        good_suffix_table[i] = pattern_len;
        -:  497:    }
        -:  498:    
        -:  499:    int j = 0;
       49:  500:    for (int i = pattern_len - 1; i >= 0; i--) {
branch  0 taken 90%
branch  1 taken 10%
       44:  501:        if (suffix[i] == i + 1) {
branch  0 taken 32%
branch  1 taken 68%
       43:  502:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       29:  503:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       29:  504:                    good_suffix_table[j] = pattern_len - 1 - i;
        -:  505:                }
        -:  506:            }
        -:  507:        }
        -:  508:    }
        -:  509:    
       44:  510:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 taken 89%
branch  1 taken 11% (fallthrough)
       39:  511:        good_suffix_table[pattern_len - 1 - suffix[i]] = pattern_len - 1 - i;
        -:  512:    }
        -:  513:    
        5:  514:    free(suffix);
        -:  515:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 3 returned 100% blocks executed 80%
        3:  472:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
        3:  473:    int* suffix = malloc(pattern_len * sizeof(int));
        3:  474:    if (!suffix) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  475:    
        -:  476:    // Compute suffix array
        3:  477:    suffix[pattern_len - 1] = pattern_len;
        3:  478:    int g = pattern_len - 1;
        -:  479:    int f = 0;
        -:  480:    
       95:  481:    for (int i = pattern_len - 2; i >= 0; i--) {
branch  0 taken 97%
branch  1 taken 3%
      92*:  482:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  483:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  484:        } else {
        -:  485:            if (i < g) g = i;
        -:  486:            f = i;
       94:  487:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 2%
branch  3 taken 98% (fallthrough)
        2:  488:                g--;
        -:  489:            }
       92:  490:            suffix[i] = f - g;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Compute good suffix table
       98:  495:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 taken 97%
branch  1 taken 3%
       95:  496:        good_suffix_table[i] = pattern_len;
        -:  497:    }
        -:  498:    
        -:  499:    int j = 0;
       98:  500:    for (int i = pattern_len - 1; i >= 0; i--) {
branch  0 taken 97%
branch  1 taken 3%
       95:  501:        if (suffix[i] == i + 1) {
branch  0 taken 3%
branch  1 taken 97%
       3*:  502:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  503:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  504:                    good_suffix_table[j] = pattern_len - 1 - i;
        -:  505:                }
        -:  506:            }
        -:  507:        }
        -:  508:    }
        -:  509:    
       95:  510:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
       92:  511:        good_suffix_table[pattern_len - 1 - suffix[i]] = pattern_len - 1 - i;
        -:  512:    }
        -:  513:    
        3:  514:    free(suffix);
        -:  515:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 0 returned 0% blocks executed 0%
    #####:  472:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
    #####:  473:    int* suffix = malloc(pattern_len * sizeof(int));
    #####:  474:    if (!suffix) return;
branch  0 never executed
branch  1 never executed
        -:  475:    
        -:  476:    // Compute suffix array
    #####:  477:    suffix[pattern_len - 1] = pattern_len;
    #####:  478:    int g = pattern_len - 1;
        -:  479:    int f = 0;
        -:  480:    
    #####:  481:    for (int i = pattern_len - 2; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  482:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  483:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  484:        } else {
        -:  485:            if (i < g) g = i;
        -:  486:            f = i;
    #####:  487:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  488:                g--;
        -:  489:            }
    #####:  490:            suffix[i] = f - g;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Compute good suffix table
    #####:  495:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 never executed
branch  1 never executed
    #####:  496:        good_suffix_table[i] = pattern_len;
        -:  497:    }
        -:  498:    
        -:  499:    int j = 0;
    #####:  500:    for (int i = pattern_len - 1; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  501:        if (suffix[i] == i + 1) {
branch  0 never executed
branch  1 never executed
    #####:  502:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 never executed
branch  1 never executed
    #####:  503:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  504:                    good_suffix_table[j] = pattern_len - 1 - i;
        -:  505:                }
        -:  506:            }
        -:  507:        }
        -:  508:    }
        -:  509:    
    #####:  510:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 never executed
branch  1 never executed
    #####:  511:        good_suffix_table[pattern_len - 1 - suffix[i]] = pattern_len - 1 - i;
        -:  512:    }
        -:  513:    
    #####:  514:    free(suffix);
        -:  515:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 0 returned 0% blocks executed 0%
    #####:  472:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
    #####:  473:    int* suffix = malloc(pattern_len * sizeof(int));
    #####:  474:    if (!suffix) return;
branch  0 never executed
branch  1 never executed
        -:  475:    
        -:  476:    // Compute suffix array
    #####:  477:    suffix[pattern_len - 1] = pattern_len;
    #####:  478:    int g = pattern_len - 1;
        -:  479:    int f = 0;
        -:  480:    
    #####:  481:    for (int i = pattern_len - 2; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  482:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  483:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  484:        } else {
        -:  485:            if (i < g) g = i;
        -:  486:            f = i;
    #####:  487:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  488:                g--;
        -:  489:            }
    #####:  490:            suffix[i] = f - g;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Compute good suffix table
    #####:  495:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 never executed
branch  1 never executed
    #####:  496:        good_suffix_table[i] = pattern_len;
        -:  497:    }
        -:  498:    
        -:  499:    int j = 0;
    #####:  500:    for (int i = pattern_len - 1; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  501:        if (suffix[i] == i + 1) {
branch  0 never executed
branch  1 never executed
    #####:  502:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 never executed
branch  1 never executed
    #####:  503:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  504:                    good_suffix_table[j] = pattern_len - 1 - i;
        -:  505:                }
        -:  506:            }
        -:  507:        }
        -:  508:    }
        -:  509:    
    #####:  510:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 never executed
branch  1 never executed
    #####:  511:        good_suffix_table[pattern_len - 1 - suffix[i]] = pattern_len - 1 - i;
        -:  512:    }
        -:  513:    
    #####:  514:    free(suffix);
        -:  515:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 0 returned 0% blocks executed 0%
    #####:  472:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
    #####:  473:    int* suffix = malloc(pattern_len * sizeof(int));
    #####:  474:    if (!suffix) return;
branch  0 never executed
branch  1 never executed
        -:  475:    
        -:  476:    // Compute suffix array
    #####:  477:    suffix[pattern_len - 1] = pattern_len;
    #####:  478:    int g = pattern_len - 1;
        -:  479:    int f = 0;
        -:  480:    
    #####:  481:    for (int i = pattern_len - 2; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  482:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  483:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  484:        } else {
        -:  485:            if (i < g) g = i;
        -:  486:            f = i;
    #####:  487:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  488:                g--;
        -:  489:            }
    #####:  490:            suffix[i] = f - g;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Compute good suffix table
    #####:  495:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 never executed
branch  1 never executed
    #####:  496:        good_suffix_table[i] = pattern_len;
        -:  497:    }
        -:  498:    
        -:  499:    int j = 0;
    #####:  500:    for (int i = pattern_len - 1; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  501:        if (suffix[i] == i + 1) {
branch  0 never executed
branch  1 never executed
    #####:  502:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 never executed
branch  1 never executed
    #####:  503:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  504:                    good_suffix_table[j] = pattern_len - 1 - i;
        -:  505:                }
        -:  506:            }
        -:  507:        }
        -:  508:    }
        -:  509:    
    #####:  510:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 never executed
branch  1 never executed
    #####:  511:        good_suffix_table[pattern_len - 1 - suffix[i]] = pattern_len - 1 - i;
        -:  512:    }
        -:  513:    
    #####:  514:    free(suffix);
        -:  515:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 0 returned 0% blocks executed 0%
    #####:  472:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
    #####:  473:    int* suffix = malloc(pattern_len * sizeof(int));
    #####:  474:    if (!suffix) return;
branch  0 never executed
branch  1 never executed
        -:  475:    
        -:  476:    // Compute suffix array
    #####:  477:    suffix[pattern_len - 1] = pattern_len;
    #####:  478:    int g = pattern_len - 1;
        -:  479:    int f = 0;
        -:  480:    
    #####:  481:    for (int i = pattern_len - 2; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  482:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  483:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  484:        } else {
        -:  485:            if (i < g) g = i;
        -:  486:            f = i;
    #####:  487:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  488:                g--;
        -:  489:            }
    #####:  490:            suffix[i] = f - g;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Compute good suffix table
    #####:  495:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 never executed
branch  1 never executed
    #####:  496:        good_suffix_table[i] = pattern_len;
        -:  497:    }
        -:  498:    
        -:  499:    int j = 0;
    #####:  500:    for (int i = pattern_len - 1; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  501:        if (suffix[i] == i + 1) {
branch  0 never executed
branch  1 never executed
    #####:  502:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 never executed
branch  1 never executed
    #####:  503:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  504:                    good_suffix_table[j] = pattern_len - 1 - i;
        -:  505:                }
        -:  506:            }
        -:  507:        }
        -:  508:    }
        -:  509:    
    #####:  510:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 never executed
branch  1 never executed
    #####:  511:        good_suffix_table[pattern_len - 1 - suffix[i]] = pattern_len - 1 - i;
        -:  512:    }
        -:  513:    
    #####:  514:    free(suffix);
        -:  515:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 0 returned 0% blocks executed 0%
    #####:  472:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
    #####:  473:    int* suffix = malloc(pattern_len * sizeof(int));
    #####:  474:    if (!suffix) return;
branch  0 never executed
branch  1 never executed
        -:  475:    
        -:  476:    // Compute suffix array
    #####:  477:    suffix[pattern_len - 1] = pattern_len;
    #####:  478:    int g = pattern_len - 1;
        -:  479:    int f = 0;
        -:  480:    
    #####:  481:    for (int i = pattern_len - 2; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  482:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  483:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  484:        } else {
        -:  485:            if (i < g) g = i;
        -:  486:            f = i;
    #####:  487:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  488:                g--;
        -:  489:            }
    #####:  490:            suffix[i] = f - g;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Compute good suffix table
    #####:  495:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 never executed
branch  1 never executed
    #####:  496:        good_suffix_table[i] = pattern_len;
        -:  497:    }
        -:  498:    
        -:  499:    int j = 0;
    #####:  500:    for (int i = pattern_len - 1; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  501:        if (suffix[i] == i + 1) {
branch  0 never executed
branch  1 never executed
    #####:  502:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 never executed
branch  1 never executed
    #####:  503:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  504:                    good_suffix_table[j] = pattern_len - 1 - i;
        -:  505:                }
        -:  506:            }
        -:  507:        }
        -:  508:    }
        -:  509:    
    #####:  510:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 never executed
branch  1 never executed
    #####:  511:        good_suffix_table[pattern_len - 1 - suffix[i]] = pattern_len - 1 - i;
        -:  512:    }
        -:  513:    
    #####:  514:    free(suffix);
        -:  515:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 19 returned 100% blocks executed 80%
       19:  472:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
       19:  473:    int* suffix = malloc(pattern_len * sizeof(int));
       19:  474:    if (!suffix) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  475:    
        -:  476:    // Compute suffix array
       19:  477:    suffix[pattern_len - 1] = pattern_len;
       19:  478:    int g = pattern_len - 1;
        -:  479:    int f = 0;
        -:  480:    
      501:  481:    for (int i = pattern_len - 2; i >= 0; i--) {
branch  0 taken 96%
branch  1 taken 4%
     482*:  482:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  483:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  484:        } else {
        -:  485:            if (i < g) g = i;
        -:  486:            f = i;
      521:  487:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 7%
branch  3 taken 93% (fallthrough)
       39:  488:                g--;
        -:  489:            }
      482:  490:            suffix[i] = f - g;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Compute good suffix table
      520:  495:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 taken 96%
branch  1 taken 4%
      501:  496:        good_suffix_table[i] = pattern_len;
        -:  497:    }
        -:  498:    
        -:  499:    int j = 0;
      520:  500:    for (int i = pattern_len - 1; i >= 0; i--) {
branch  0 taken 96%
branch  1 taken 4%
      501:  501:        if (suffix[i] == i + 1) {
branch  0 taken 4%
branch  1 taken 96%
      19*:  502:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  503:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  504:                    good_suffix_table[j] = pattern_len - 1 - i;
        -:  505:                }
        -:  506:            }
        -:  507:        }
        -:  508:    }
        -:  509:    
      501:  510:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
      482:  511:        good_suffix_table[pattern_len - 1 - suffix[i]] = pattern_len - 1 - i;
        -:  512:    }
        -:  513:    
       19:  514:    free(suffix);
        -:  515:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 19 returned 100% blocks executed 80%
       19:  472:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
       19:  473:    int* suffix = malloc(pattern_len * sizeof(int));
       19:  474:    if (!suffix) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  475:    
        -:  476:    // Compute suffix array
       19:  477:    suffix[pattern_len - 1] = pattern_len;
       19:  478:    int g = pattern_len - 1;
        -:  479:    int f = 0;
        -:  480:    
      501:  481:    for (int i = pattern_len - 2; i >= 0; i--) {
branch  0 taken 96%
branch  1 taken 4%
     482*:  482:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  483:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  484:        } else {
        -:  485:            if (i < g) g = i;
        -:  486:            f = i;
      521:  487:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 7%
branch  3 taken 93% (fallthrough)
       39:  488:                g--;
        -:  489:            }
      482:  490:            suffix[i] = f - g;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Compute good suffix table
      520:  495:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 taken 96%
branch  1 taken 4%
      501:  496:        good_suffix_table[i] = pattern_len;
        -:  497:    }
        -:  498:    
        -:  499:    int j = 0;
      520:  500:    for (int i = pattern_len - 1; i >= 0; i--) {
branch  0 taken 96%
branch  1 taken 4%
      501:  501:        if (suffix[i] == i + 1) {
branch  0 taken 4%
branch  1 taken 96%
      19*:  502:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  503:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  504:                    good_suffix_table[j] = pattern_len - 1 - i;
        -:  505:                }
        -:  506:            }
        -:  507:        }
        -:  508:    }
        -:  509:    
      501:  510:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
      482:  511:        good_suffix_table[pattern_len - 1 - suffix[i]] = pattern_len - 1 - i;
        -:  512:    }
        -:  513:    
       19:  514:    free(suffix);
        -:  515:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 0 returned 0% blocks executed 0%
    #####:  472:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
    #####:  473:    int* suffix = malloc(pattern_len * sizeof(int));
    #####:  474:    if (!suffix) return;
branch  0 never executed
branch  1 never executed
        -:  475:    
        -:  476:    // Compute suffix array
    #####:  477:    suffix[pattern_len - 1] = pattern_len;
    #####:  478:    int g = pattern_len - 1;
        -:  479:    int f = 0;
        -:  480:    
    #####:  481:    for (int i = pattern_len - 2; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  482:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  483:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  484:        } else {
        -:  485:            if (i < g) g = i;
        -:  486:            f = i;
    #####:  487:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  488:                g--;
        -:  489:            }
    #####:  490:            suffix[i] = f - g;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Compute good suffix table
    #####:  495:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 never executed
branch  1 never executed
    #####:  496:        good_suffix_table[i] = pattern_len;
        -:  497:    }
        -:  498:    
        -:  499:    int j = 0;
    #####:  500:    for (int i = pattern_len - 1; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  501:        if (suffix[i] == i + 1) {
branch  0 never executed
branch  1 never executed
    #####:  502:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 never executed
branch  1 never executed
    #####:  503:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  504:                    good_suffix_table[j] = pattern_len - 1 - i;
        -:  505:                }
        -:  506:            }
        -:  507:        }
        -:  508:    }
        -:  509:    
    #####:  510:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 never executed
branch  1 never executed
    #####:  511:        good_suffix_table[pattern_len - 1 - suffix[i]] = pattern_len - 1 - i;
        -:  512:    }
        -:  513:    
    #####:  514:    free(suffix);
        -:  515:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 0 returned 0% blocks executed 0%
    #####:  472:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
    #####:  473:    int* suffix = malloc(pattern_len * sizeof(int));
    #####:  474:    if (!suffix) return;
branch  0 never executed
branch  1 never executed
        -:  475:    
        -:  476:    // Compute suffix array
    #####:  477:    suffix[pattern_len - 1] = pattern_len;
    #####:  478:    int g = pattern_len - 1;
        -:  479:    int f = 0;
        -:  480:    
    #####:  481:    for (int i = pattern_len - 2; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  482:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  483:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  484:        } else {
        -:  485:            if (i < g) g = i;
        -:  486:            f = i;
    #####:  487:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  488:                g--;
        -:  489:            }
    #####:  490:            suffix[i] = f - g;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Compute good suffix table
    #####:  495:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 never executed
branch  1 never executed
    #####:  496:        good_suffix_table[i] = pattern_len;
        -:  497:    }
        -:  498:    
        -:  499:    int j = 0;
    #####:  500:    for (int i = pattern_len - 1; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  501:        if (suffix[i] == i + 1) {
branch  0 never executed
branch  1 never executed
    #####:  502:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 never executed
branch  1 never executed
    #####:  503:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  504:                    good_suffix_table[j] = pattern_len - 1 - i;
        -:  505:                }
        -:  506:            }
        -:  507:        }
        -:  508:    }
        -:  509:    
    #####:  510:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 never executed
branch  1 never executed
    #####:  511:        good_suffix_table[pattern_len - 1 - suffix[i]] = pattern_len - 1 - i;
        -:  512:    }
        -:  513:    
    #####:  514:    free(suffix);
        -:  515:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 0 returned 0% blocks executed 0%
    #####:  472:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
    #####:  473:    int* suffix = malloc(pattern_len * sizeof(int));
    #####:  474:    if (!suffix) return;
branch  0 never executed
branch  1 never executed
        -:  475:    
        -:  476:    // Compute suffix array
    #####:  477:    suffix[pattern_len - 1] = pattern_len;
    #####:  478:    int g = pattern_len - 1;
        -:  479:    int f = 0;
        -:  480:    
    #####:  481:    for (int i = pattern_len - 2; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  482:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  483:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  484:        } else {
        -:  485:            if (i < g) g = i;
        -:  486:            f = i;
    #####:  487:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  488:                g--;
        -:  489:            }
    #####:  490:            suffix[i] = f - g;
        -:  491:        }
        -:  492:    }
        -:  493:    
        -:  494:    // Compute good suffix table
    #####:  495:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 never executed
branch  1 never executed
    #####:  496:        good_suffix_table[i] = pattern_len;
        -:  497:    }
        -:  498:    
        -:  499:    int j = 0;
    #####:  500:    for (int i = pattern_len - 1; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  501:        if (suffix[i] == i + 1) {
branch  0 never executed
branch  1 never executed
    #####:  502:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 never executed
branch  1 never executed
    #####:  503:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  504:                    good_suffix_table[j] = pattern_len - 1 - i;
        -:  505:                }
        -:  506:            }
        -:  507:        }
        -:  508:    }
        -:  509:    
    #####:  510:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 never executed
branch  1 never executed
    #####:  511:        good_suffix_table[pattern_len - 1 - suffix[i]] = pattern_len - 1 - i;
        -:  512:    }
        -:  513:    
    #####:  514:    free(suffix);
        -:  515:}
------------------
        -:  516:
      62*:  517:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
      62*:  518:    if (!pattern) {
       1*:  519:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
       1*:  520:        return NULL;
        -:  521:    }
        -:  522:    
      61*:  523:    size_t pattern_len = strlen(pattern);
      61*:  524:    if (pattern_len == 0) {
       1*:  525:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
       1*:  526:        return NULL;
        -:  527:    }
        -:  528:    
      60*:  529:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
      60*:  530:    if (!bm) {
    #####:  531:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  532:        return NULL;
        -:  533:    }
        -:  534:    
      60*:  535:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
      60*:  536:    if (!bm->good_suffix_table) {
    #####:  537:        free(bm);
    #####:  538:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
      60*:  542:    bm->pattern_length = pattern_len;
        -:  543:    
      60*:  544:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
      60*:  545:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
        -:  546:    
      60*:  547:    return bm;
        -:  548:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 1 returned 100% blocks executed 75%
        1:  517:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
        1:  518:    if (!pattern) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  519:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  520:        return NULL;
        -:  521:    }
        -:  522:    
        1:  523:    size_t pattern_len = strlen(pattern);
        1:  524:    if (pattern_len == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  525:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  526:        return NULL;
        -:  527:    }
        -:  528:    
        1:  529:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
        1:  530:    if (!bm) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  531:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  532:        return NULL;
        -:  533:    }
        -:  534:    
        1:  535:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
        1:  536:    if (!bm->good_suffix_table) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  537:        free(bm);
    #####:  538:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
        1:  542:    bm->pattern_length = pattern_len;
        -:  543:    
        1:  544:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
        1:  545:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 returned 100%
        -:  546:    
        1:  547:    return bm;
        -:  548:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 15 returned 100% blocks executed 88%
       15:  517:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
       15:  518:    if (!pattern) {
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        1:  519:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
        1:  520:        return NULL;
        -:  521:    }
        -:  522:    
       14:  523:    size_t pattern_len = strlen(pattern);
       14:  524:    if (pattern_len == 0) {
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        1:  525:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
        1:  526:        return NULL;
        -:  527:    }
        -:  528:    
       13:  529:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
       13:  530:    if (!bm) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  531:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  532:        return NULL;
        -:  533:    }
        -:  534:    
       13:  535:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
       13:  536:    if (!bm->good_suffix_table) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  537:        free(bm);
    #####:  538:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
       13:  542:    bm->pattern_length = pattern_len;
        -:  543:    
       13:  544:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
       13:  545:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 returned 100%
        -:  546:    
       13:  547:    return bm;
        -:  548:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 5 returned 100% blocks executed 75%
        5:  517:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
        5:  518:    if (!pattern) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  519:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  520:        return NULL;
        -:  521:    }
        -:  522:    
        5:  523:    size_t pattern_len = strlen(pattern);
        5:  524:    if (pattern_len == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  525:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  526:        return NULL;
        -:  527:    }
        -:  528:    
        5:  529:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
        5:  530:    if (!bm) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  531:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  532:        return NULL;
        -:  533:    }
        -:  534:    
        5:  535:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
        5:  536:    if (!bm->good_suffix_table) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  537:        free(bm);
    #####:  538:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
        5:  542:    bm->pattern_length = pattern_len;
        -:  543:    
        5:  544:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
        5:  545:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 returned 100%
        -:  546:    
        5:  547:    return bm;
        -:  548:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 3 returned 100% blocks executed 75%
        3:  517:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
        3:  518:    if (!pattern) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  519:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  520:        return NULL;
        -:  521:    }
        -:  522:    
        3:  523:    size_t pattern_len = strlen(pattern);
        3:  524:    if (pattern_len == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  525:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  526:        return NULL;
        -:  527:    }
        -:  528:    
        3:  529:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
        3:  530:    if (!bm) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  531:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  532:        return NULL;
        -:  533:    }
        -:  534:    
        3:  535:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
        3:  536:    if (!bm->good_suffix_table) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  537:        free(bm);
    #####:  538:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
        3:  542:    bm->pattern_length = pattern_len;
        -:  543:    
        3:  544:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
        3:  545:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 returned 100%
        -:  546:    
        3:  547:    return bm;
        -:  548:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 0 returned 0% blocks executed 0%
    #####:  517:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
    #####:  518:    if (!pattern) {
branch  0 never executed
branch  1 never executed
    #####:  519:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  520:        return NULL;
        -:  521:    }
        -:  522:    
    #####:  523:    size_t pattern_len = strlen(pattern);
    #####:  524:    if (pattern_len == 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  526:        return NULL;
        -:  527:    }
        -:  528:    
    #####:  529:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
    #####:  530:    if (!bm) {
branch  0 never executed
branch  1 never executed
    #####:  531:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  532:        return NULL;
        -:  533:    }
        -:  534:    
    #####:  535:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
    #####:  536:    if (!bm->good_suffix_table) {
branch  0 never executed
branch  1 never executed
    #####:  537:        free(bm);
    #####:  538:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
    #####:  542:    bm->pattern_length = pattern_len;
        -:  543:    
    #####:  544:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
    #####:  545:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 never executed
        -:  546:    
    #####:  547:    return bm;
        -:  548:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 0 returned 0% blocks executed 0%
    #####:  517:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
    #####:  518:    if (!pattern) {
branch  0 never executed
branch  1 never executed
    #####:  519:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  520:        return NULL;
        -:  521:    }
        -:  522:    
    #####:  523:    size_t pattern_len = strlen(pattern);
    #####:  524:    if (pattern_len == 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  526:        return NULL;
        -:  527:    }
        -:  528:    
    #####:  529:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
    #####:  530:    if (!bm) {
branch  0 never executed
branch  1 never executed
    #####:  531:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  532:        return NULL;
        -:  533:    }
        -:  534:    
    #####:  535:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
    #####:  536:    if (!bm->good_suffix_table) {
branch  0 never executed
branch  1 never executed
    #####:  537:        free(bm);
    #####:  538:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
    #####:  542:    bm->pattern_length = pattern_len;
        -:  543:    
    #####:  544:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
    #####:  545:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 never executed
        -:  546:    
    #####:  547:    return bm;
        -:  548:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 0 returned 0% blocks executed 0%
    #####:  517:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
    #####:  518:    if (!pattern) {
branch  0 never executed
branch  1 never executed
    #####:  519:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  520:        return NULL;
        -:  521:    }
        -:  522:    
    #####:  523:    size_t pattern_len = strlen(pattern);
    #####:  524:    if (pattern_len == 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  526:        return NULL;
        -:  527:    }
        -:  528:    
    #####:  529:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
    #####:  530:    if (!bm) {
branch  0 never executed
branch  1 never executed
    #####:  531:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  532:        return NULL;
        -:  533:    }
        -:  534:    
    #####:  535:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
    #####:  536:    if (!bm->good_suffix_table) {
branch  0 never executed
branch  1 never executed
    #####:  537:        free(bm);
    #####:  538:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
    #####:  542:    bm->pattern_length = pattern_len;
        -:  543:    
    #####:  544:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
    #####:  545:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 never executed
        -:  546:    
    #####:  547:    return bm;
        -:  548:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 0 returned 0% blocks executed 0%
    #####:  517:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
    #####:  518:    if (!pattern) {
branch  0 never executed
branch  1 never executed
    #####:  519:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  520:        return NULL;
        -:  521:    }
        -:  522:    
    #####:  523:    size_t pattern_len = strlen(pattern);
    #####:  524:    if (pattern_len == 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  526:        return NULL;
        -:  527:    }
        -:  528:    
    #####:  529:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
    #####:  530:    if (!bm) {
branch  0 never executed
branch  1 never executed
    #####:  531:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  532:        return NULL;
        -:  533:    }
        -:  534:    
    #####:  535:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
    #####:  536:    if (!bm->good_suffix_table) {
branch  0 never executed
branch  1 never executed
    #####:  537:        free(bm);
    #####:  538:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
    #####:  542:    bm->pattern_length = pattern_len;
        -:  543:    
    #####:  544:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
    #####:  545:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 never executed
        -:  546:    
    #####:  547:    return bm;
        -:  548:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 0 returned 0% blocks executed 0%
    #####:  517:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
    #####:  518:    if (!pattern) {
branch  0 never executed
branch  1 never executed
    #####:  519:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  520:        return NULL;
        -:  521:    }
        -:  522:    
    #####:  523:    size_t pattern_len = strlen(pattern);
    #####:  524:    if (pattern_len == 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  526:        return NULL;
        -:  527:    }
        -:  528:    
    #####:  529:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
    #####:  530:    if (!bm) {
branch  0 never executed
branch  1 never executed
    #####:  531:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  532:        return NULL;
        -:  533:    }
        -:  534:    
    #####:  535:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
    #####:  536:    if (!bm->good_suffix_table) {
branch  0 never executed
branch  1 never executed
    #####:  537:        free(bm);
    #####:  538:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
    #####:  542:    bm->pattern_length = pattern_len;
        -:  543:    
    #####:  544:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
    #####:  545:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 never executed
        -:  546:    
    #####:  547:    return bm;
        -:  548:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 19 returned 100% blocks executed 75%
       19:  517:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
       19:  518:    if (!pattern) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  519:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  520:        return NULL;
        -:  521:    }
        -:  522:    
       19:  523:    size_t pattern_len = strlen(pattern);
       19:  524:    if (pattern_len == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  525:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  526:        return NULL;
        -:  527:    }
        -:  528:    
       19:  529:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
       19:  530:    if (!bm) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  531:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  532:        return NULL;
        -:  533:    }
        -:  534:    
       19:  535:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
       19:  536:    if (!bm->good_suffix_table) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  537:        free(bm);
    #####:  538:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
       19:  542:    bm->pattern_length = pattern_len;
        -:  543:    
       19:  544:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
       19:  545:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 returned 100%
        -:  546:    
       19:  547:    return bm;
        -:  548:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 19 returned 100% blocks executed 75%
       19:  517:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
       19:  518:    if (!pattern) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  519:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  520:        return NULL;
        -:  521:    }
        -:  522:    
       19:  523:    size_t pattern_len = strlen(pattern);
       19:  524:    if (pattern_len == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  525:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  526:        return NULL;
        -:  527:    }
        -:  528:    
       19:  529:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
       19:  530:    if (!bm) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  531:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  532:        return NULL;
        -:  533:    }
        -:  534:    
       19:  535:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
       19:  536:    if (!bm->good_suffix_table) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  537:        free(bm);
    #####:  538:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
       19:  542:    bm->pattern_length = pattern_len;
        -:  543:    
       19:  544:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
       19:  545:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 returned 100%
        -:  546:    
       19:  547:    return bm;
        -:  548:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 0 returned 0% blocks executed 0%
    #####:  517:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
    #####:  518:    if (!pattern) {
branch  0 never executed
branch  1 never executed
    #####:  519:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  520:        return NULL;
        -:  521:    }
        -:  522:    
    #####:  523:    size_t pattern_len = strlen(pattern);
    #####:  524:    if (pattern_len == 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  526:        return NULL;
        -:  527:    }
        -:  528:    
    #####:  529:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
    #####:  530:    if (!bm) {
branch  0 never executed
branch  1 never executed
    #####:  531:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  532:        return NULL;
        -:  533:    }
        -:  534:    
    #####:  535:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
    #####:  536:    if (!bm->good_suffix_table) {
branch  0 never executed
branch  1 never executed
    #####:  537:        free(bm);
    #####:  538:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
    #####:  542:    bm->pattern_length = pattern_len;
        -:  543:    
    #####:  544:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
    #####:  545:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 never executed
        -:  546:    
    #####:  547:    return bm;
        -:  548:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 0 returned 0% blocks executed 0%
    #####:  517:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
    #####:  518:    if (!pattern) {
branch  0 never executed
branch  1 never executed
    #####:  519:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  520:        return NULL;
        -:  521:    }
        -:  522:    
    #####:  523:    size_t pattern_len = strlen(pattern);
    #####:  524:    if (pattern_len == 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  526:        return NULL;
        -:  527:    }
        -:  528:    
    #####:  529:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
    #####:  530:    if (!bm) {
branch  0 never executed
branch  1 never executed
    #####:  531:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  532:        return NULL;
        -:  533:    }
        -:  534:    
    #####:  535:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
    #####:  536:    if (!bm->good_suffix_table) {
branch  0 never executed
branch  1 never executed
    #####:  537:        free(bm);
    #####:  538:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
    #####:  542:    bm->pattern_length = pattern_len;
        -:  543:    
    #####:  544:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
    #####:  545:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 never executed
        -:  546:    
    #####:  547:    return bm;
        -:  548:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 0 returned 0% blocks executed 0%
    #####:  517:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
    #####:  518:    if (!pattern) {
branch  0 never executed
branch  1 never executed
    #####:  519:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  520:        return NULL;
        -:  521:    }
        -:  522:    
    #####:  523:    size_t pattern_len = strlen(pattern);
    #####:  524:    if (pattern_len == 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  526:        return NULL;
        -:  527:    }
        -:  528:    
    #####:  529:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
    #####:  530:    if (!bm) {
branch  0 never executed
branch  1 never executed
    #####:  531:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  532:        return NULL;
        -:  533:    }
        -:  534:    
    #####:  535:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
    #####:  536:    if (!bm->good_suffix_table) {
branch  0 never executed
branch  1 never executed
    #####:  537:        free(bm);
    #####:  538:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  539:        return NULL;
        -:  540:    }
        -:  541:    
    #####:  542:    bm->pattern_length = pattern_len;
        -:  543:    
    #####:  544:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
    #####:  545:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 never executed
        -:  546:    
    #####:  547:    return bm;
        -:  548:}
------------------
        -:  549:
      60*:  550:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
      60*:  551:    if (!bm) return;
        -:  552:    
      60*:  553:    free(bm->good_suffix_table);
      60*:  554:    free(bm);
        -:  555:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 1 returned 100% blocks executed 100%
        1:  550:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
        1:  551:    if (!bm) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  552:    
        1:  553:    free(bm->good_suffix_table);
        1:  554:    free(bm);
        -:  555:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 13 returned 100% blocks executed 100%
       13:  550:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
       13:  551:    if (!bm) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  552:    
       13:  553:    free(bm->good_suffix_table);
       13:  554:    free(bm);
        -:  555:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 5 returned 100% blocks executed 100%
        5:  550:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
        5:  551:    if (!bm) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  552:    
        5:  553:    free(bm->good_suffix_table);
        5:  554:    free(bm);
        -:  555:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 3 returned 100% blocks executed 100%
        3:  550:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
        3:  551:    if (!bm) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  552:    
        3:  553:    free(bm->good_suffix_table);
        3:  554:    free(bm);
        -:  555:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 0 returned 0% blocks executed 0%
    #####:  550:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
    #####:  551:    if (!bm) return;
branch  0 never executed
branch  1 never executed
        -:  552:    
    #####:  553:    free(bm->good_suffix_table);
    #####:  554:    free(bm);
        -:  555:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 0 returned 0% blocks executed 0%
    #####:  550:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
    #####:  551:    if (!bm) return;
branch  0 never executed
branch  1 never executed
        -:  552:    
    #####:  553:    free(bm->good_suffix_table);
    #####:  554:    free(bm);
        -:  555:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 0 returned 0% blocks executed 0%
    #####:  550:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
    #####:  551:    if (!bm) return;
branch  0 never executed
branch  1 never executed
        -:  552:    
    #####:  553:    free(bm->good_suffix_table);
    #####:  554:    free(bm);
        -:  555:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 0 returned 0% blocks executed 0%
    #####:  550:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
    #####:  551:    if (!bm) return;
branch  0 never executed
branch  1 never executed
        -:  552:    
    #####:  553:    free(bm->good_suffix_table);
    #####:  554:    free(bm);
        -:  555:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 0 returned 0% blocks executed 0%
    #####:  550:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
    #####:  551:    if (!bm) return;
branch  0 never executed
branch  1 never executed
        -:  552:    
    #####:  553:    free(bm->good_suffix_table);
    #####:  554:    free(bm);
        -:  555:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 19 returned 100% blocks executed 100%
       19:  550:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
       19:  551:    if (!bm) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  552:    
       19:  553:    free(bm->good_suffix_table);
       19:  554:    free(bm);
        -:  555:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 19 returned 100% blocks executed 100%
       19:  550:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
       19:  551:    if (!bm) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  552:    
       19:  553:    free(bm->good_suffix_table);
       19:  554:    free(bm);
        -:  555:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 0 returned 0% blocks executed 0%
    #####:  550:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
    #####:  551:    if (!bm) return;
branch  0 never executed
branch  1 never executed
        -:  552:    
    #####:  553:    free(bm->good_suffix_table);
    #####:  554:    free(bm);
        -:  555:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 0 returned 0% blocks executed 0%
    #####:  550:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
    #####:  551:    if (!bm) return;
branch  0 never executed
branch  1 never executed
        -:  552:    
    #####:  553:    free(bm->good_suffix_table);
    #####:  554:    free(bm);
        -:  555:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 0 returned 0% blocks executed 0%
    #####:  550:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
    #####:  551:    if (!bm) return;
branch  0 never executed
branch  1 never executed
        -:  552:    
    #####:  553:    free(bm->good_suffix_table);
    #####:  554:    free(bm);
        -:  555:}
------------------
        -:  556:
     244*:  557:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  558:                              size_t text_length, const char* pattern) {
     244*:  559:    if (!bm || !text || !pattern) {
        -:  560:        return -1;
        -:  561:    }
        -:  562:    
     243*:  563:    size_t pattern_len = bm->pattern_length;
        -:  564:    
        -:  565:    // Defensive check to prevent integer underflow
     243*:  566:    if (text_length < pattern_len || pattern_len == 0) {
        -:  567:        return -1;
        -:  568:    }
        -:  569:    
        -:  570:    size_t shift = 0;
     241*:  571:    size_t max_shift = text_length - pattern_len;
        -:  572:    
    1445*:  573:    while (shift <= max_shift) {
        -:  574:        // Prefetch ahead for better cache performance
    1439*:  575:        if (shift + pattern_len + 64 <= text_length) {
    1352*:  576:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
        -:  577:        }
        -:  578:        
        -:  579:        // SIMD-accelerated pattern comparison for longer patterns
    1439*:  580:        if (pattern_len >= 16) {
        -:  581:            // For patterns >= 16 bytes, use SIMD for initial comparison
      48*:  582:            const char* text_pos = text + shift;
        -:  583:            
        -:  584:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
      48*:  585:            size_t chunks = pattern_len / 16;
      48*:  586:            size_t remainder = pattern_len % 16;
        -:  587:            bool match = true;
        -:  588:            
        -:  589:            // Check from right to left in 16-byte chunks
     100*:  590:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
      52*:  591:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  592:                
        -:  593:                #ifdef USE_SIMD
      52*:  594:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
      52*:  595:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
        -:  596:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  597:                
      52*:  598:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
        -:  599:                    match = false;
        -:  600:                }
        -:  601:                #else
        -:  602:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  603:                    match = false;
        -:  604:                }
        -:  605:                #endif
        -:  606:            }
        -:  607:            
        -:  608:            // Check remainder bytes
      48*:  609:            if (match && remainder > 0) {
       3*:  610:                if (memcmp(pattern, text_pos, remainder) != 0) {
        -:  611:                    match = false;
        -:  612:                }
        -:  613:            }
        -:  614:            
      48*:  615:            if (match) {
       3*:  616:                return (int)shift;  // Match found
        -:  617:            }
        -:  618:            
        -:  619:            // Calculate shift using bad character heuristic
        -:  620:            // Use the rightmost character that didn't match
      45*:  621:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
      45*:  622:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  623:            
        -:  624:            // Use good suffix table for better shift
      45*:  625:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  626:            
      45*:  627:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  628:            if (shift == 0) shift = 1;  // Ensure progress
        -:  629:            
        -:  630:        } else {
        -:  631:            // Original Boyer-Moore for shorter patterns
    1391*:  632:            int j = (int)pattern_len - 1;
        -:  633:            
        -:  634:            // Compare from right to left
    3235*:  635:            while (j >= 0 && pattern[j] == text[shift + j]) {
    1844*:  636:                j--;
        -:  637:            }
        -:  638:            
    1391*:  639:            if (j < 0) {
     232*:  640:                return (int)shift;  // Match found
        -:  641:            } else {
        -:  642:                // Calculate shift using bad character and good suffix heuristics
    1159*:  643:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    1159*:  644:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  645:                
    1159*:  646:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  647:                if (shift == 0) shift = 1;  // Ensure progress
        -:  648:            }
        -:  649:        }
        -:  650:    }
        -:  651:    
        -:  652:    return -1;  // No match found
        -:  653:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 223 returned 100% blocks executed 63%
      223:  557:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  558:                              size_t text_length, const char* pattern) {
      223:  559:    if (!bm || !text || !pattern) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  560:        return -1;
        -:  561:    }
        -:  562:    
      223:  563:    size_t pattern_len = bm->pattern_length;
        -:  564:    
        -:  565:    // Defensive check to prevent integer underflow
      223:  566:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  567:        return -1;
        -:  568:    }
        -:  569:    
        -:  570:    size_t shift = 0;
      223:  571:    size_t max_shift = text_length - pattern_len;
        -:  572:    
     1335:  573:    while (shift <= max_shift) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
        -:  574:        // Prefetch ahead for better cache performance
     1334:  575:        if (shift + pattern_len + 64 <= text_length) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
     1325:  576:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 returned 100%
        -:  577:        }
        -:  578:        
        -:  579:        // SIMD-accelerated pattern comparison for longer patterns
     1334:  580:        if (pattern_len >= 16) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  581:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  582:            const char* text_pos = text + shift;
        -:  583:            
        -:  584:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  585:            size_t chunks = pattern_len / 16;
    #####:  586:            size_t remainder = pattern_len % 16;
        -:  587:            bool match = true;
        -:  588:            
        -:  589:            // Check from right to left in 16-byte chunks
    #####:  590:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  591:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  592:                
        -:  593:                #ifdef USE_SIMD
    #####:  594:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  595:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  596:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  597:                
    #####:  598:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  599:                    match = false;
        -:  600:                }
        -:  601:                #else
        -:  602:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  603:                    match = false;
        -:  604:                }
        -:  605:                #endif
        -:  606:            }
        -:  607:            
        -:  608:            // Check remainder bytes
    #####:  609:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  610:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  611:                    match = false;
        -:  612:                }
        -:  613:            }
        -:  614:            
    #####:  615:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  616:                return (int)shift;  // Match found
        -:  617:            }
        -:  618:            
        -:  619:            // Calculate shift using bad character heuristic
        -:  620:            // Use the rightmost character that didn't match
    #####:  621:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  622:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  623:            
        -:  624:            // Use good suffix table for better shift
    #####:  625:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  626:            
    #####:  627:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  628:            if (shift == 0) shift = 1;  // Ensure progress
        -:  629:            
        -:  630:        } else {
        -:  631:            // Original Boyer-Moore for shorter patterns
     1334:  632:            int j = (int)pattern_len - 1;
        -:  633:            
        -:  634:            // Compare from right to left
     3110:  635:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
branch  2 taken 61%
branch  3 taken 39% (fallthrough)
     1776:  636:                j--;
        -:  637:            }
        -:  638:            
     1334:  639:            if (j < 0) {
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
      222:  640:                return (int)shift;  // Match found
        -:  641:            } else {
        -:  642:                // Calculate shift using bad character and good suffix heuristics
     1112:  643:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
     1112:  644:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  645:                
     1112:  646:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  647:                if (shift == 0) shift = 1;  // Ensure progress
        -:  648:            }
        -:  649:        }
        -:  650:    }
        -:  651:    
        -:  652:    return -1;  // No match found
        -:  653:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 13 returned 100% blocks executed 100%
       13:  557:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  558:                              size_t text_length, const char* pattern) {
       13:  559:    if (!bm || !text || !pattern) {
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  560:        return -1;
        -:  561:    }
        -:  562:    
       12:  563:    size_t pattern_len = bm->pattern_length;
        -:  564:    
        -:  565:    // Defensive check to prevent integer underflow
       12:  566:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
        -:  567:        return -1;
        -:  568:    }
        -:  569:    
        -:  570:    size_t shift = 0;
       10:  571:    size_t max_shift = text_length - pattern_len;
        -:  572:    
       69:  573:    while (shift <= max_shift) {
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  574:        // Prefetch ahead for better cache performance
       66:  575:        if (shift + pattern_len + 64 <= text_length) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        7:  576:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 returned 100%
        -:  577:        }
        -:  578:        
        -:  579:        // SIMD-accelerated pattern comparison for longer patterns
       66:  580:        if (pattern_len >= 16) {
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
        -:  581:            // For patterns >= 16 bytes, use SIMD for initial comparison
       18:  582:            const char* text_pos = text + shift;
        -:  583:            
        -:  584:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
       18:  585:            size_t chunks = pattern_len / 16;
       18:  586:            size_t remainder = pattern_len % 16;
        -:  587:            bool match = true;
        -:  588:            
        -:  589:            // Check from right to left in 16-byte chunks
       39:  590:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 taken 54%
branch  1 taken 46% (fallthrough)
       21:  591:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  592:                
        -:  593:                #ifdef USE_SIMD
       21:  594:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
       21:  595:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
        -:  596:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  597:                
       21:  598:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
        -:  599:                    match = false;
        -:  600:                }
        -:  601:                #else
        -:  602:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  603:                    match = false;
        -:  604:                }
        -:  605:                #endif
        -:  606:            }
        -:  607:            
        -:  608:            // Check remainder bytes
       18:  609:            if (match && remainder > 0) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        2:  610:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  611:                    match = false;
        -:  612:                }
        -:  613:            }
        -:  614:            
       18:  615:            if (match) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        2:  616:                return (int)shift;  // Match found
        -:  617:            }
        -:  618:            
        -:  619:            // Calculate shift using bad character heuristic
        -:  620:            // Use the rightmost character that didn't match
       16:  621:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
       16:  622:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  623:            
        -:  624:            // Use good suffix table for better shift
       16:  625:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  626:            
       16:  627:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  628:            if (shift == 0) shift = 1;  // Ensure progress
        -:  629:            
        -:  630:        } else {
        -:  631:            // Original Boyer-Moore for shorter patterns
       48:  632:            int j = (int)pattern_len - 1;
        -:  633:            
        -:  634:            // Compare from right to left
       66:  635:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
branch  2 taken 30%
branch  3 taken 70% (fallthrough)
       18:  636:                j--;
        -:  637:            }
        -:  638:            
       48:  639:            if (j < 0) {
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
        5:  640:                return (int)shift;  // Match found
        -:  641:            } else {
        -:  642:                // Calculate shift using bad character and good suffix heuristics
       43:  643:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
       43:  644:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  645:                
       43:  646:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  647:                if (shift == 0) shift = 1;  // Ensure progress
        -:  648:            }
        -:  649:        }
        -:  650:    }
        -:  651:    
        -:  652:    return -1;  // No match found
        -:  653:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 5 returned 100% blocks executed 59%
        5:  557:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  558:                              size_t text_length, const char* pattern) {
        5:  559:    if (!bm || !text || !pattern) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  560:        return -1;
        -:  561:    }
        -:  562:    
        5:  563:    size_t pattern_len = bm->pattern_length;
        -:  564:    
        -:  565:    // Defensive check to prevent integer underflow
        5:  566:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  567:        return -1;
        -:  568:    }
        -:  569:    
        -:  570:    size_t shift = 0;
        5:  571:    size_t max_shift = text_length - pattern_len;
        -:  572:    
        9:  573:    while (shift <= max_shift) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -:  574:        // Prefetch ahead for better cache performance
        9:  575:        if (shift + pattern_len + 64 <= text_length) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  576:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  577:        }
        -:  578:        
        -:  579:        // SIMD-accelerated pattern comparison for longer patterns
        9:  580:        if (pattern_len >= 16) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  581:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  582:            const char* text_pos = text + shift;
        -:  583:            
        -:  584:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  585:            size_t chunks = pattern_len / 16;
    #####:  586:            size_t remainder = pattern_len % 16;
        -:  587:            bool match = true;
        -:  588:            
        -:  589:            // Check from right to left in 16-byte chunks
    #####:  590:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  591:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  592:                
        -:  593:                #ifdef USE_SIMD
    #####:  594:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  595:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  596:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  597:                
    #####:  598:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  599:                    match = false;
        -:  600:                }
        -:  601:                #else
        -:  602:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  603:                    match = false;
        -:  604:                }
        -:  605:                #endif
        -:  606:            }
        -:  607:            
        -:  608:            // Check remainder bytes
    #####:  609:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  610:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  611:                    match = false;
        -:  612:                }
        -:  613:            }
        -:  614:            
    #####:  615:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  616:                return (int)shift;  // Match found
        -:  617:            }
        -:  618:            
        -:  619:            // Calculate shift using bad character heuristic
        -:  620:            // Use the rightmost character that didn't match
    #####:  621:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  622:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  623:            
        -:  624:            // Use good suffix table for better shift
    #####:  625:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  626:            
    #####:  627:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  628:            if (shift == 0) shift = 1;  // Ensure progress
        -:  629:            
        -:  630:        } else {
        -:  631:            // Original Boyer-Moore for shorter patterns
        9:  632:            int j = (int)pattern_len - 1;
        -:  633:            
        -:  634:            // Compare from right to left
       59:  635:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
branch  2 taken 93%
branch  3 taken 7% (fallthrough)
       50:  636:                j--;
        -:  637:            }
        -:  638:            
        9:  639:            if (j < 0) {
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
        5:  640:                return (int)shift;  // Match found
        -:  641:            } else {
        -:  642:                // Calculate shift using bad character and good suffix heuristics
        4:  643:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
        4:  644:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  645:                
        4:  646:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  647:                if (shift == 0) shift = 1;  // Ensure progress
        -:  648:            }
        -:  649:        }
        -:  650:    }
        -:  651:    
        -:  652:    return -1;  // No match found
        -:  653:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 3 returned 100% blocks executed 74%
        3:  557:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  558:                              size_t text_length, const char* pattern) {
        3:  559:    if (!bm || !text || !pattern) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  560:        return -1;
        -:  561:    }
        -:  562:    
        3:  563:    size_t pattern_len = bm->pattern_length;
        -:  564:    
        -:  565:    // Defensive check to prevent integer underflow
        3:  566:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  567:        return -1;
        -:  568:    }
        -:  569:    
        -:  570:    size_t shift = 0;
        3:  571:    size_t max_shift = text_length - pattern_len;
        -:  572:    
       32:  573:    while (shift <= max_shift) {
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  574:        // Prefetch ahead for better cache performance
       30:  575:        if (shift + pattern_len + 64 <= text_length) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
       20:  576:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 returned 100%
        -:  577:        }
        -:  578:        
        -:  579:        // SIMD-accelerated pattern comparison for longer patterns
       30:  580:        if (pattern_len >= 16) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  581:            // For patterns >= 16 bytes, use SIMD for initial comparison
       30:  582:            const char* text_pos = text + shift;
        -:  583:            
        -:  584:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
       30:  585:            size_t chunks = pattern_len / 16;
       30:  586:            size_t remainder = pattern_len % 16;
        -:  587:            bool match = true;
        -:  588:            
        -:  589:            // Check from right to left in 16-byte chunks
       61:  590:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 taken 51%
branch  1 taken 49% (fallthrough)
       31:  591:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  592:                
        -:  593:                #ifdef USE_SIMD
       31:  594:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       31:  595:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        -:  596:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  597:                
       31:  598:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        -:  599:                    match = false;
        -:  600:                }
        -:  601:                #else
        -:  602:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  603:                    match = false;
        -:  604:                }
        -:  605:                #endif
        -:  606:            }
        -:  607:            
        -:  608:            // Check remainder bytes
       30:  609:            if (match && remainder > 0) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        1:  610:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  611:                    match = false;
        -:  612:                }
        -:  613:            }
        -:  614:            
       30:  615:            if (match) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        1:  616:                return (int)shift;  // Match found
        -:  617:            }
        -:  618:            
        -:  619:            // Calculate shift using bad character heuristic
        -:  620:            // Use the rightmost character that didn't match
       29:  621:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
       29:  622:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  623:            
        -:  624:            // Use good suffix table for better shift
       29:  625:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  626:            
       29:  627:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  628:            if (shift == 0) shift = 1;  // Ensure progress
        -:  629:            
        -:  630:        } else {
        -:  631:            // Original Boyer-Moore for shorter patterns
    #####:  632:            int j = (int)pattern_len - 1;
        -:  633:            
        -:  634:            // Compare from right to left
    #####:  635:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  636:                j--;
        -:  637:            }
        -:  638:            
    #####:  639:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  640:                return (int)shift;  // Match found
        -:  641:            } else {
        -:  642:                // Calculate shift using bad character and good suffix heuristics
    #####:  643:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  644:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  645:                
    #####:  646:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  647:                if (shift == 0) shift = 1;  // Ensure progress
        -:  648:            }
        -:  649:        }
        -:  650:    }
        -:  651:    
        -:  652:    return -1;  // No match found
        -:  653:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  557:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  558:                              size_t text_length, const char* pattern) {
    #####:  559:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  560:        return -1;
        -:  561:    }
        -:  562:    
    #####:  563:    size_t pattern_len = bm->pattern_length;
        -:  564:    
        -:  565:    // Defensive check to prevent integer underflow
    #####:  566:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  567:        return -1;
        -:  568:    }
        -:  569:    
        -:  570:    size_t shift = 0;
    #####:  571:    size_t max_shift = text_length - pattern_len;
        -:  572:    
    #####:  573:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  574:        // Prefetch ahead for better cache performance
    #####:  575:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  576:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  577:        }
        -:  578:        
        -:  579:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  580:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  581:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  582:            const char* text_pos = text + shift;
        -:  583:            
        -:  584:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  585:            size_t chunks = pattern_len / 16;
    #####:  586:            size_t remainder = pattern_len % 16;
        -:  587:            bool match = true;
        -:  588:            
        -:  589:            // Check from right to left in 16-byte chunks
    #####:  590:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  591:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  592:                
        -:  593:                #ifdef USE_SIMD
    #####:  594:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  595:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  596:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  597:                
    #####:  598:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  599:                    match = false;
        -:  600:                }
        -:  601:                #else
        -:  602:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  603:                    match = false;
        -:  604:                }
        -:  605:                #endif
        -:  606:            }
        -:  607:            
        -:  608:            // Check remainder bytes
    #####:  609:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  610:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  611:                    match = false;
        -:  612:                }
        -:  613:            }
        -:  614:            
    #####:  615:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  616:                return (int)shift;  // Match found
        -:  617:            }
        -:  618:            
        -:  619:            // Calculate shift using bad character heuristic
        -:  620:            // Use the rightmost character that didn't match
    #####:  621:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  622:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  623:            
        -:  624:            // Use good suffix table for better shift
    #####:  625:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  626:            
    #####:  627:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  628:            if (shift == 0) shift = 1;  // Ensure progress
        -:  629:            
        -:  630:        } else {
        -:  631:            // Original Boyer-Moore for shorter patterns
    #####:  632:            int j = (int)pattern_len - 1;
        -:  633:            
        -:  634:            // Compare from right to left
    #####:  635:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  636:                j--;
        -:  637:            }
        -:  638:            
    #####:  639:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  640:                return (int)shift;  // Match found
        -:  641:            } else {
        -:  642:                // Calculate shift using bad character and good suffix heuristics
    #####:  643:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  644:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  645:                
    #####:  646:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  647:                if (shift == 0) shift = 1;  // Ensure progress
        -:  648:            }
        -:  649:        }
        -:  650:    }
        -:  651:    
        -:  652:    return -1;  // No match found
        -:  653:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  557:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  558:                              size_t text_length, const char* pattern) {
    #####:  559:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  560:        return -1;
        -:  561:    }
        -:  562:    
    #####:  563:    size_t pattern_len = bm->pattern_length;
        -:  564:    
        -:  565:    // Defensive check to prevent integer underflow
    #####:  566:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  567:        return -1;
        -:  568:    }
        -:  569:    
        -:  570:    size_t shift = 0;
    #####:  571:    size_t max_shift = text_length - pattern_len;
        -:  572:    
    #####:  573:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  574:        // Prefetch ahead for better cache performance
    #####:  575:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  576:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  577:        }
        -:  578:        
        -:  579:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  580:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  581:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  582:            const char* text_pos = text + shift;
        -:  583:            
        -:  584:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  585:            size_t chunks = pattern_len / 16;
    #####:  586:            size_t remainder = pattern_len % 16;
        -:  587:            bool match = true;
        -:  588:            
        -:  589:            // Check from right to left in 16-byte chunks
    #####:  590:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  591:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  592:                
        -:  593:                #ifdef USE_SIMD
    #####:  594:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  595:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  596:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  597:                
    #####:  598:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  599:                    match = false;
        -:  600:                }
        -:  601:                #else
        -:  602:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  603:                    match = false;
        -:  604:                }
        -:  605:                #endif
        -:  606:            }
        -:  607:            
        -:  608:            // Check remainder bytes
    #####:  609:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  610:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  611:                    match = false;
        -:  612:                }
        -:  613:            }
        -:  614:            
    #####:  615:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  616:                return (int)shift;  // Match found
        -:  617:            }
        -:  618:            
        -:  619:            // Calculate shift using bad character heuristic
        -:  620:            // Use the rightmost character that didn't match
    #####:  621:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  622:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  623:            
        -:  624:            // Use good suffix table for better shift
    #####:  625:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  626:            
    #####:  627:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  628:            if (shift == 0) shift = 1;  // Ensure progress
        -:  629:            
        -:  630:        } else {
        -:  631:            // Original Boyer-Moore for shorter patterns
    #####:  632:            int j = (int)pattern_len - 1;
        -:  633:            
        -:  634:            // Compare from right to left
    #####:  635:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  636:                j--;
        -:  637:            }
        -:  638:            
    #####:  639:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  640:                return (int)shift;  // Match found
        -:  641:            } else {
        -:  642:                // Calculate shift using bad character and good suffix heuristics
    #####:  643:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  644:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  645:                
    #####:  646:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  647:                if (shift == 0) shift = 1;  // Ensure progress
        -:  648:            }
        -:  649:        }
        -:  650:    }
        -:  651:    
        -:  652:    return -1;  // No match found
        -:  653:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  557:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  558:                              size_t text_length, const char* pattern) {
    #####:  559:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  560:        return -1;
        -:  561:    }
        -:  562:    
    #####:  563:    size_t pattern_len = bm->pattern_length;
        -:  564:    
        -:  565:    // Defensive check to prevent integer underflow
    #####:  566:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  567:        return -1;
        -:  568:    }
        -:  569:    
        -:  570:    size_t shift = 0;
    #####:  571:    size_t max_shift = text_length - pattern_len;
        -:  572:    
    #####:  573:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  574:        // Prefetch ahead for better cache performance
    #####:  575:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  576:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  577:        }
        -:  578:        
        -:  579:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  580:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  581:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  582:            const char* text_pos = text + shift;
        -:  583:            
        -:  584:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  585:            size_t chunks = pattern_len / 16;
    #####:  586:            size_t remainder = pattern_len % 16;
        -:  587:            bool match = true;
        -:  588:            
        -:  589:            // Check from right to left in 16-byte chunks
    #####:  590:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  591:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  592:                
        -:  593:                #ifdef USE_SIMD
    #####:  594:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  595:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  596:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  597:                
    #####:  598:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  599:                    match = false;
        -:  600:                }
        -:  601:                #else
        -:  602:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  603:                    match = false;
        -:  604:                }
        -:  605:                #endif
        -:  606:            }
        -:  607:            
        -:  608:            // Check remainder bytes
    #####:  609:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  610:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  611:                    match = false;
        -:  612:                }
        -:  613:            }
        -:  614:            
    #####:  615:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  616:                return (int)shift;  // Match found
        -:  617:            }
        -:  618:            
        -:  619:            // Calculate shift using bad character heuristic
        -:  620:            // Use the rightmost character that didn't match
    #####:  621:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  622:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  623:            
        -:  624:            // Use good suffix table for better shift
    #####:  625:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  626:            
    #####:  627:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  628:            if (shift == 0) shift = 1;  // Ensure progress
        -:  629:            
        -:  630:        } else {
        -:  631:            // Original Boyer-Moore for shorter patterns
    #####:  632:            int j = (int)pattern_len - 1;
        -:  633:            
        -:  634:            // Compare from right to left
    #####:  635:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  636:                j--;
        -:  637:            }
        -:  638:            
    #####:  639:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  640:                return (int)shift;  // Match found
        -:  641:            } else {
        -:  642:                // Calculate shift using bad character and good suffix heuristics
    #####:  643:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  644:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  645:                
    #####:  646:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  647:                if (shift == 0) shift = 1;  // Ensure progress
        -:  648:            }
        -:  649:        }
        -:  650:    }
        -:  651:    
        -:  652:    return -1;  // No match found
        -:  653:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  557:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  558:                              size_t text_length, const char* pattern) {
    #####:  559:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  560:        return -1;
        -:  561:    }
        -:  562:    
    #####:  563:    size_t pattern_len = bm->pattern_length;
        -:  564:    
        -:  565:    // Defensive check to prevent integer underflow
    #####:  566:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  567:        return -1;
        -:  568:    }
        -:  569:    
        -:  570:    size_t shift = 0;
    #####:  571:    size_t max_shift = text_length - pattern_len;
        -:  572:    
    #####:  573:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  574:        // Prefetch ahead for better cache performance
    #####:  575:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  576:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  577:        }
        -:  578:        
        -:  579:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  580:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  581:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  582:            const char* text_pos = text + shift;
        -:  583:            
        -:  584:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  585:            size_t chunks = pattern_len / 16;
    #####:  586:            size_t remainder = pattern_len % 16;
        -:  587:            bool match = true;
        -:  588:            
        -:  589:            // Check from right to left in 16-byte chunks
    #####:  590:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  591:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  592:                
        -:  593:                #ifdef USE_SIMD
    #####:  594:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  595:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  596:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  597:                
    #####:  598:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  599:                    match = false;
        -:  600:                }
        -:  601:                #else
        -:  602:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  603:                    match = false;
        -:  604:                }
        -:  605:                #endif
        -:  606:            }
        -:  607:            
        -:  608:            // Check remainder bytes
    #####:  609:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  610:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  611:                    match = false;
        -:  612:                }
        -:  613:            }
        -:  614:            
    #####:  615:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  616:                return (int)shift;  // Match found
        -:  617:            }
        -:  618:            
        -:  619:            // Calculate shift using bad character heuristic
        -:  620:            // Use the rightmost character that didn't match
    #####:  621:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  622:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  623:            
        -:  624:            // Use good suffix table for better shift
    #####:  625:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  626:            
    #####:  627:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  628:            if (shift == 0) shift = 1;  // Ensure progress
        -:  629:            
        -:  630:        } else {
        -:  631:            // Original Boyer-Moore for shorter patterns
    #####:  632:            int j = (int)pattern_len - 1;
        -:  633:            
        -:  634:            // Compare from right to left
    #####:  635:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  636:                j--;
        -:  637:            }
        -:  638:            
    #####:  639:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  640:                return (int)shift;  // Match found
        -:  641:            } else {
        -:  642:                // Calculate shift using bad character and good suffix heuristics
    #####:  643:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  644:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  645:                
    #####:  646:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  647:                if (shift == 0) shift = 1;  // Ensure progress
        -:  648:            }
        -:  649:        }
        -:  650:    }
        -:  651:    
        -:  652:    return -1;  // No match found
        -:  653:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  557:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  558:                              size_t text_length, const char* pattern) {
    #####:  559:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  560:        return -1;
        -:  561:    }
        -:  562:    
    #####:  563:    size_t pattern_len = bm->pattern_length;
        -:  564:    
        -:  565:    // Defensive check to prevent integer underflow
    #####:  566:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  567:        return -1;
        -:  568:    }
        -:  569:    
        -:  570:    size_t shift = 0;
    #####:  571:    size_t max_shift = text_length - pattern_len;
        -:  572:    
    #####:  573:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  574:        // Prefetch ahead for better cache performance
    #####:  575:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  576:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  577:        }
        -:  578:        
        -:  579:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  580:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  581:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  582:            const char* text_pos = text + shift;
        -:  583:            
        -:  584:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  585:            size_t chunks = pattern_len / 16;
    #####:  586:            size_t remainder = pattern_len % 16;
        -:  587:            bool match = true;
        -:  588:            
        -:  589:            // Check from right to left in 16-byte chunks
    #####:  590:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  591:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  592:                
        -:  593:                #ifdef USE_SIMD
    #####:  594:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  595:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  596:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  597:                
    #####:  598:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  599:                    match = false;
        -:  600:                }
        -:  601:                #else
        -:  602:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  603:                    match = false;
        -:  604:                }
        -:  605:                #endif
        -:  606:            }
        -:  607:            
        -:  608:            // Check remainder bytes
    #####:  609:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  610:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  611:                    match = false;
        -:  612:                }
        -:  613:            }
        -:  614:            
    #####:  615:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  616:                return (int)shift;  // Match found
        -:  617:            }
        -:  618:            
        -:  619:            // Calculate shift using bad character heuristic
        -:  620:            // Use the rightmost character that didn't match
    #####:  621:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  622:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  623:            
        -:  624:            // Use good suffix table for better shift
    #####:  625:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  626:            
    #####:  627:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  628:            if (shift == 0) shift = 1;  // Ensure progress
        -:  629:            
        -:  630:        } else {
        -:  631:            // Original Boyer-Moore for shorter patterns
    #####:  632:            int j = (int)pattern_len - 1;
        -:  633:            
        -:  634:            // Compare from right to left
    #####:  635:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  636:                j--;
        -:  637:            }
        -:  638:            
    #####:  639:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  640:                return (int)shift;  // Match found
        -:  641:            } else {
        -:  642:                // Calculate shift using bad character and good suffix heuristics
    #####:  643:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  644:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  645:                
    #####:  646:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  647:                if (shift == 0) shift = 1;  // Ensure progress
        -:  648:            }
        -:  649:        }
        -:  650:    }
        -:  651:    
        -:  652:    return -1;  // No match found
        -:  653:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  557:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  558:                              size_t text_length, const char* pattern) {
    #####:  559:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  560:        return -1;
        -:  561:    }
        -:  562:    
    #####:  563:    size_t pattern_len = bm->pattern_length;
        -:  564:    
        -:  565:    // Defensive check to prevent integer underflow
    #####:  566:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  567:        return -1;
        -:  568:    }
        -:  569:    
        -:  570:    size_t shift = 0;
    #####:  571:    size_t max_shift = text_length - pattern_len;
        -:  572:    
    #####:  573:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  574:        // Prefetch ahead for better cache performance
    #####:  575:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  576:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  577:        }
        -:  578:        
        -:  579:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  580:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  581:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  582:            const char* text_pos = text + shift;
        -:  583:            
        -:  584:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  585:            size_t chunks = pattern_len / 16;
    #####:  586:            size_t remainder = pattern_len % 16;
        -:  587:            bool match = true;
        -:  588:            
        -:  589:            // Check from right to left in 16-byte chunks
    #####:  590:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  591:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  592:                
        -:  593:                #ifdef USE_SIMD
    #####:  594:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  595:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  596:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  597:                
    #####:  598:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  599:                    match = false;
        -:  600:                }
        -:  601:                #else
        -:  602:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  603:                    match = false;
        -:  604:                }
        -:  605:                #endif
        -:  606:            }
        -:  607:            
        -:  608:            // Check remainder bytes
    #####:  609:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  610:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  611:                    match = false;
        -:  612:                }
        -:  613:            }
        -:  614:            
    #####:  615:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  616:                return (int)shift;  // Match found
        -:  617:            }
        -:  618:            
        -:  619:            // Calculate shift using bad character heuristic
        -:  620:            // Use the rightmost character that didn't match
    #####:  621:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  622:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  623:            
        -:  624:            // Use good suffix table for better shift
    #####:  625:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  626:            
    #####:  627:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  628:            if (shift == 0) shift = 1;  // Ensure progress
        -:  629:            
        -:  630:        } else {
        -:  631:            // Original Boyer-Moore for shorter patterns
    #####:  632:            int j = (int)pattern_len - 1;
        -:  633:            
        -:  634:            // Compare from right to left
    #####:  635:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  636:                j--;
        -:  637:            }
        -:  638:            
    #####:  639:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  640:                return (int)shift;  // Match found
        -:  641:            } else {
        -:  642:                // Calculate shift using bad character and good suffix heuristics
    #####:  643:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  644:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  645:                
    #####:  646:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  647:                if (shift == 0) shift = 1;  // Ensure progress
        -:  648:            }
        -:  649:        }
        -:  650:    }
        -:  651:    
        -:  652:    return -1;  // No match found
        -:  653:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  557:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  558:                              size_t text_length, const char* pattern) {
    #####:  559:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  560:        return -1;
        -:  561:    }
        -:  562:    
    #####:  563:    size_t pattern_len = bm->pattern_length;
        -:  564:    
        -:  565:    // Defensive check to prevent integer underflow
    #####:  566:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  567:        return -1;
        -:  568:    }
        -:  569:    
        -:  570:    size_t shift = 0;
    #####:  571:    size_t max_shift = text_length - pattern_len;
        -:  572:    
    #####:  573:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  574:        // Prefetch ahead for better cache performance
    #####:  575:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  576:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  577:        }
        -:  578:        
        -:  579:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  580:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  581:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  582:            const char* text_pos = text + shift;
        -:  583:            
        -:  584:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  585:            size_t chunks = pattern_len / 16;
    #####:  586:            size_t remainder = pattern_len % 16;
        -:  587:            bool match = true;
        -:  588:            
        -:  589:            // Check from right to left in 16-byte chunks
    #####:  590:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  591:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  592:                
        -:  593:                #ifdef USE_SIMD
    #####:  594:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  595:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  596:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  597:                
    #####:  598:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  599:                    match = false;
        -:  600:                }
        -:  601:                #else
        -:  602:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  603:                    match = false;
        -:  604:                }
        -:  605:                #endif
        -:  606:            }
        -:  607:            
        -:  608:            // Check remainder bytes
    #####:  609:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  610:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  611:                    match = false;
        -:  612:                }
        -:  613:            }
        -:  614:            
    #####:  615:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  616:                return (int)shift;  // Match found
        -:  617:            }
        -:  618:            
        -:  619:            // Calculate shift using bad character heuristic
        -:  620:            // Use the rightmost character that didn't match
    #####:  621:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  622:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  623:            
        -:  624:            // Use good suffix table for better shift
    #####:  625:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  626:            
    #####:  627:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  628:            if (shift == 0) shift = 1;  // Ensure progress
        -:  629:            
        -:  630:        } else {
        -:  631:            // Original Boyer-Moore for shorter patterns
    #####:  632:            int j = (int)pattern_len - 1;
        -:  633:            
        -:  634:            // Compare from right to left
    #####:  635:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  636:                j--;
        -:  637:            }
        -:  638:            
    #####:  639:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  640:                return (int)shift;  // Match found
        -:  641:            } else {
        -:  642:                // Calculate shift using bad character and good suffix heuristics
    #####:  643:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  644:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  645:                
    #####:  646:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  647:                if (shift == 0) shift = 1;  // Ensure progress
        -:  648:            }
        -:  649:        }
        -:  650:    }
        -:  651:    
        -:  652:    return -1;  // No match found
        -:  653:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  557:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  558:                              size_t text_length, const char* pattern) {
    #####:  559:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  560:        return -1;
        -:  561:    }
        -:  562:    
    #####:  563:    size_t pattern_len = bm->pattern_length;
        -:  564:    
        -:  565:    // Defensive check to prevent integer underflow
    #####:  566:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  567:        return -1;
        -:  568:    }
        -:  569:    
        -:  570:    size_t shift = 0;
    #####:  571:    size_t max_shift = text_length - pattern_len;
        -:  572:    
    #####:  573:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  574:        // Prefetch ahead for better cache performance
    #####:  575:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  576:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  577:        }
        -:  578:        
        -:  579:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  580:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  581:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  582:            const char* text_pos = text + shift;
        -:  583:            
        -:  584:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  585:            size_t chunks = pattern_len / 16;
    #####:  586:            size_t remainder = pattern_len % 16;
        -:  587:            bool match = true;
        -:  588:            
        -:  589:            // Check from right to left in 16-byte chunks
    #####:  590:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  591:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  592:                
        -:  593:                #ifdef USE_SIMD
    #####:  594:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  595:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  596:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  597:                
    #####:  598:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  599:                    match = false;
        -:  600:                }
        -:  601:                #else
        -:  602:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  603:                    match = false;
        -:  604:                }
        -:  605:                #endif
        -:  606:            }
        -:  607:            
        -:  608:            // Check remainder bytes
    #####:  609:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  610:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  611:                    match = false;
        -:  612:                }
        -:  613:            }
        -:  614:            
    #####:  615:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  616:                return (int)shift;  // Match found
        -:  617:            }
        -:  618:            
        -:  619:            // Calculate shift using bad character heuristic
        -:  620:            // Use the rightmost character that didn't match
    #####:  621:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  622:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  623:            
        -:  624:            // Use good suffix table for better shift
    #####:  625:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  626:            
    #####:  627:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  628:            if (shift == 0) shift = 1;  // Ensure progress
        -:  629:            
        -:  630:        } else {
        -:  631:            // Original Boyer-Moore for shorter patterns
    #####:  632:            int j = (int)pattern_len - 1;
        -:  633:            
        -:  634:            // Compare from right to left
    #####:  635:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  636:                j--;
        -:  637:            }
        -:  638:            
    #####:  639:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  640:                return (int)shift;  // Match found
        -:  641:            } else {
        -:  642:                // Calculate shift using bad character and good suffix heuristics
    #####:  643:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  644:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  645:                
    #####:  646:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  647:                if (shift == 0) shift = 1;  // Ensure progress
        -:  648:            }
        -:  649:        }
        -:  650:    }
        -:  651:    
        -:  652:    return -1;  // No match found
        -:  653:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  557:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  558:                              size_t text_length, const char* pattern) {
    #####:  559:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  560:        return -1;
        -:  561:    }
        -:  562:    
    #####:  563:    size_t pattern_len = bm->pattern_length;
        -:  564:    
        -:  565:    // Defensive check to prevent integer underflow
    #####:  566:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  567:        return -1;
        -:  568:    }
        -:  569:    
        -:  570:    size_t shift = 0;
    #####:  571:    size_t max_shift = text_length - pattern_len;
        -:  572:    
    #####:  573:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  574:        // Prefetch ahead for better cache performance
    #####:  575:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  576:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  577:        }
        -:  578:        
        -:  579:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  580:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  581:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  582:            const char* text_pos = text + shift;
        -:  583:            
        -:  584:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  585:            size_t chunks = pattern_len / 16;
    #####:  586:            size_t remainder = pattern_len % 16;
        -:  587:            bool match = true;
        -:  588:            
        -:  589:            // Check from right to left in 16-byte chunks
    #####:  590:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  591:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  592:                
        -:  593:                #ifdef USE_SIMD
    #####:  594:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  595:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  596:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  597:                
    #####:  598:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  599:                    match = false;
        -:  600:                }
        -:  601:                #else
        -:  602:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  603:                    match = false;
        -:  604:                }
        -:  605:                #endif
        -:  606:            }
        -:  607:            
        -:  608:            // Check remainder bytes
    #####:  609:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  610:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  611:                    match = false;
        -:  612:                }
        -:  613:            }
        -:  614:            
    #####:  615:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  616:                return (int)shift;  // Match found
        -:  617:            }
        -:  618:            
        -:  619:            // Calculate shift using bad character heuristic
        -:  620:            // Use the rightmost character that didn't match
    #####:  621:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  622:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  623:            
        -:  624:            // Use good suffix table for better shift
    #####:  625:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  626:            
    #####:  627:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  628:            if (shift == 0) shift = 1;  // Ensure progress
        -:  629:            
        -:  630:        } else {
        -:  631:            // Original Boyer-Moore for shorter patterns
    #####:  632:            int j = (int)pattern_len - 1;
        -:  633:            
        -:  634:            // Compare from right to left
    #####:  635:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  636:                j--;
        -:  637:            }
        -:  638:            
    #####:  639:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  640:                return (int)shift;  // Match found
        -:  641:            } else {
        -:  642:                // Calculate shift using bad character and good suffix heuristics
    #####:  643:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  644:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  645:                
    #####:  646:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  647:                if (shift == 0) shift = 1;  // Ensure progress
        -:  648:            }
        -:  649:        }
        -:  650:    }
        -:  651:    
        -:  652:    return -1;  // No match found
        -:  653:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  557:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  558:                              size_t text_length, const char* pattern) {
    #####:  559:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  560:        return -1;
        -:  561:    }
        -:  562:    
    #####:  563:    size_t pattern_len = bm->pattern_length;
        -:  564:    
        -:  565:    // Defensive check to prevent integer underflow
    #####:  566:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  567:        return -1;
        -:  568:    }
        -:  569:    
        -:  570:    size_t shift = 0;
    #####:  571:    size_t max_shift = text_length - pattern_len;
        -:  572:    
    #####:  573:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  574:        // Prefetch ahead for better cache performance
    #####:  575:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  576:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  577:        }
        -:  578:        
        -:  579:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  580:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  581:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  582:            const char* text_pos = text + shift;
        -:  583:            
        -:  584:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  585:            size_t chunks = pattern_len / 16;
    #####:  586:            size_t remainder = pattern_len % 16;
        -:  587:            bool match = true;
        -:  588:            
        -:  589:            // Check from right to left in 16-byte chunks
    #####:  590:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  591:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  592:                
        -:  593:                #ifdef USE_SIMD
    #####:  594:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  595:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  596:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  597:                
    #####:  598:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  599:                    match = false;
        -:  600:                }
        -:  601:                #else
        -:  602:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  603:                    match = false;
        -:  604:                }
        -:  605:                #endif
        -:  606:            }
        -:  607:            
        -:  608:            // Check remainder bytes
    #####:  609:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  610:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  611:                    match = false;
        -:  612:                }
        -:  613:            }
        -:  614:            
    #####:  615:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  616:                return (int)shift;  // Match found
        -:  617:            }
        -:  618:            
        -:  619:            // Calculate shift using bad character heuristic
        -:  620:            // Use the rightmost character that didn't match
    #####:  621:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  622:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  623:            
        -:  624:            // Use good suffix table for better shift
    #####:  625:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  626:            
    #####:  627:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  628:            if (shift == 0) shift = 1;  // Ensure progress
        -:  629:            
        -:  630:        } else {
        -:  631:            // Original Boyer-Moore for shorter patterns
    #####:  632:            int j = (int)pattern_len - 1;
        -:  633:            
        -:  634:            // Compare from right to left
    #####:  635:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  636:                j--;
        -:  637:            }
        -:  638:            
    #####:  639:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  640:                return (int)shift;  // Match found
        -:  641:            } else {
        -:  642:                // Calculate shift using bad character and good suffix heuristics
    #####:  643:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  644:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  645:                
    #####:  646:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  647:                if (shift == 0) shift = 1;  // Ensure progress
        -:  648:            }
        -:  649:        }
        -:  650:    }
        -:  651:    
        -:  652:    return -1;  // No match found
        -:  653:}
------------------
        -:  654:
        -:  655:// === SIMD UTILITIES ===
        -:  656:
        -:  657:#ifdef USE_SIMD
       3*:  658:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  659:                                  const double* thresholds, uint64_t* violations) {
        -:  660:    // SIMD implementation for x86_64
        -:  661:    #ifdef MERCURY_X86_64
        -:  662:        // Process 4 metrics at a time using AVX
       3*:  663:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  664:        
       4*:  665:        for (size_t i = 0; i < simd_count; i += 4) {
        -:  666:            // Load thresholds
       1*:  667:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  668:            
        -:  669:            // Compare with metrics (example for one field)
        -:  670:            // This would be expanded for all threshold types
       1*:  671:            __m256d response_times = _mm256_set_pd(
       1*:  672:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
       1*:  673:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
       1*:  674:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
       1*:  675:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  676:            );
        -:  677:            
        -:  678:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  679:            int mask = _mm256_movemask_pd(comparison);
        -:  680:            
        -:  681:            // Set violation flags based on comparison
       5*:  682:            for (int j = 0; j < 4; j++) {
       4*:  683:                if (mask & (1 << j)) {
       4*:  684:                    violations[i + j] |= 1;  // Response time violation
        -:  685:                }
        -:  686:            }
        -:  687:        }
        -:  688:        
        -:  689:        // Handle remaining metrics
      10*:  690:        for (size_t i = simd_count; i < count; i++) {
       7*:  691:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
       7*:  692:            if (response_time > thresholds[i]) {
       7*:  693:                violations[i] |= 1;
        -:  694:            }
        -:  695:        }
        -:  696:    #else
        -:  697:        // Fallback to scalar implementation
        -:  698:        for (size_t i = 0; i < count; i++) {
        -:  699:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  700:            if (response_time > thresholds[i]) {
        -:  701:                violations[i] |= 1;
        -:  702:            }
        -:  703:        }
        -:  704:    #endif
       3*:  705:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  658:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  659:                                  const double* thresholds, uint64_t* violations) {
        -:  660:    // SIMD implementation for x86_64
        -:  661:    #ifdef MERCURY_X86_64
        -:  662:        // Process 4 metrics at a time using AVX
    #####:  663:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  664:        
    #####:  665:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  666:            // Load thresholds
    #####:  667:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  668:            
        -:  669:            // Compare with metrics (example for one field)
        -:  670:            // This would be expanded for all threshold types
    #####:  671:            __m256d response_times = _mm256_set_pd(
    #####:  672:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  673:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  674:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  675:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  676:            );
        -:  677:            
        -:  678:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  679:            int mask = _mm256_movemask_pd(comparison);
        -:  680:            
        -:  681:            // Set violation flags based on comparison
    #####:  682:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  683:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  684:                    violations[i + j] |= 1;  // Response time violation
        -:  685:                }
        -:  686:            }
        -:  687:        }
        -:  688:        
        -:  689:        // Handle remaining metrics
    #####:  690:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  691:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  692:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  693:                violations[i] |= 1;
        -:  694:            }
        -:  695:        }
        -:  696:    #else
        -:  697:        // Fallback to scalar implementation
        -:  698:        for (size_t i = 0; i < count; i++) {
        -:  699:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  700:            if (response_time > thresholds[i]) {
        -:  701:                violations[i] |= 1;
        -:  702:            }
        -:  703:        }
        -:  704:    #endif
    #####:  705:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  658:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  659:                                  const double* thresholds, uint64_t* violations) {
        -:  660:    // SIMD implementation for x86_64
        -:  661:    #ifdef MERCURY_X86_64
        -:  662:        // Process 4 metrics at a time using AVX
    #####:  663:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  664:        
    #####:  665:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  666:            // Load thresholds
    #####:  667:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  668:            
        -:  669:            // Compare with metrics (example for one field)
        -:  670:            // This would be expanded for all threshold types
    #####:  671:            __m256d response_times = _mm256_set_pd(
    #####:  672:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  673:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  674:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  675:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  676:            );
        -:  677:            
        -:  678:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  679:            int mask = _mm256_movemask_pd(comparison);
        -:  680:            
        -:  681:            // Set violation flags based on comparison
    #####:  682:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  683:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  684:                    violations[i + j] |= 1;  // Response time violation
        -:  685:                }
        -:  686:            }
        -:  687:        }
        -:  688:        
        -:  689:        // Handle remaining metrics
    #####:  690:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  691:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  692:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  693:                violations[i] |= 1;
        -:  694:            }
        -:  695:        }
        -:  696:    #else
        -:  697:        // Fallback to scalar implementation
        -:  698:        for (size_t i = 0; i < count; i++) {
        -:  699:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  700:            if (response_time > thresholds[i]) {
        -:  701:                violations[i] |= 1;
        -:  702:            }
        -:  703:        }
        -:  704:    #endif
    #####:  705:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 3 returned 100% blocks executed 100%
        3:  658:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  659:                                  const double* thresholds, uint64_t* violations) {
        -:  660:    // SIMD implementation for x86_64
        -:  661:    #ifdef MERCURY_X86_64
        -:  662:        // Process 4 metrics at a time using AVX
        3:  663:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  664:        
        4:  665:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 taken 25%
branch  1 taken 75%
        -:  666:            // Load thresholds
        1:  667:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  668:            
        -:  669:            // Compare with metrics (example for one field)
        -:  670:            // This would be expanded for all threshold types
        1:  671:            __m256d response_times = _mm256_set_pd(
        1:  672:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
        1:  673:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
        1:  674:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
        1:  675:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  676:            );
        -:  677:            
        -:  678:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  679:            int mask = _mm256_movemask_pd(comparison);
        -:  680:            
        -:  681:            // Set violation flags based on comparison
        5:  682:            for (int j = 0; j < 4; j++) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        4:  683:                if (mask & (1 << j)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4:  684:                    violations[i + j] |= 1;  // Response time violation
        -:  685:                }
        -:  686:            }
        -:  687:        }
        -:  688:        
        -:  689:        // Handle remaining metrics
       10:  690:        for (size_t i = simd_count; i < count; i++) {
branch  0 taken 70%
branch  1 taken 30% (fallthrough)
        7:  691:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        7:  692:            if (response_time > thresholds[i]) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        7:  693:                violations[i] |= 1;
        -:  694:            }
        -:  695:        }
        -:  696:    #else
        -:  697:        // Fallback to scalar implementation
        -:  698:        for (size_t i = 0; i < count; i++) {
        -:  699:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  700:            if (response_time > thresholds[i]) {
        -:  701:                violations[i] |= 1;
        -:  702:            }
        -:  703:        }
        -:  704:    #endif
        3:  705:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  658:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  659:                                  const double* thresholds, uint64_t* violations) {
        -:  660:    // SIMD implementation for x86_64
        -:  661:    #ifdef MERCURY_X86_64
        -:  662:        // Process 4 metrics at a time using AVX
    #####:  663:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  664:        
    #####:  665:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  666:            // Load thresholds
    #####:  667:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  668:            
        -:  669:            // Compare with metrics (example for one field)
        -:  670:            // This would be expanded for all threshold types
    #####:  671:            __m256d response_times = _mm256_set_pd(
    #####:  672:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  673:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  674:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  675:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  676:            );
        -:  677:            
        -:  678:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  679:            int mask = _mm256_movemask_pd(comparison);
        -:  680:            
        -:  681:            // Set violation flags based on comparison
    #####:  682:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  683:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  684:                    violations[i + j] |= 1;  // Response time violation
        -:  685:                }
        -:  686:            }
        -:  687:        }
        -:  688:        
        -:  689:        // Handle remaining metrics
    #####:  690:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  691:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  692:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  693:                violations[i] |= 1;
        -:  694:            }
        -:  695:        }
        -:  696:    #else
        -:  697:        // Fallback to scalar implementation
        -:  698:        for (size_t i = 0; i < count; i++) {
        -:  699:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  700:            if (response_time > thresholds[i]) {
        -:  701:                violations[i] |= 1;
        -:  702:            }
        -:  703:        }
        -:  704:    #endif
    #####:  705:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  658:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  659:                                  const double* thresholds, uint64_t* violations) {
        -:  660:    // SIMD implementation for x86_64
        -:  661:    #ifdef MERCURY_X86_64
        -:  662:        // Process 4 metrics at a time using AVX
    #####:  663:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  664:        
    #####:  665:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  666:            // Load thresholds
    #####:  667:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  668:            
        -:  669:            // Compare with metrics (example for one field)
        -:  670:            // This would be expanded for all threshold types
    #####:  671:            __m256d response_times = _mm256_set_pd(
    #####:  672:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  673:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  674:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  675:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  676:            );
        -:  677:            
        -:  678:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  679:            int mask = _mm256_movemask_pd(comparison);
        -:  680:            
        -:  681:            // Set violation flags based on comparison
    #####:  682:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  683:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  684:                    violations[i + j] |= 1;  // Response time violation
        -:  685:                }
        -:  686:            }
        -:  687:        }
        -:  688:        
        -:  689:        // Handle remaining metrics
    #####:  690:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  691:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  692:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  693:                violations[i] |= 1;
        -:  694:            }
        -:  695:        }
        -:  696:    #else
        -:  697:        // Fallback to scalar implementation
        -:  698:        for (size_t i = 0; i < count; i++) {
        -:  699:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  700:            if (response_time > thresholds[i]) {
        -:  701:                violations[i] |= 1;
        -:  702:            }
        -:  703:        }
        -:  704:    #endif
    #####:  705:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  658:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  659:                                  const double* thresholds, uint64_t* violations) {
        -:  660:    // SIMD implementation for x86_64
        -:  661:    #ifdef MERCURY_X86_64
        -:  662:        // Process 4 metrics at a time using AVX
    #####:  663:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  664:        
    #####:  665:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  666:            // Load thresholds
    #####:  667:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  668:            
        -:  669:            // Compare with metrics (example for one field)
        -:  670:            // This would be expanded for all threshold types
    #####:  671:            __m256d response_times = _mm256_set_pd(
    #####:  672:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  673:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  674:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  675:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  676:            );
        -:  677:            
        -:  678:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  679:            int mask = _mm256_movemask_pd(comparison);
        -:  680:            
        -:  681:            // Set violation flags based on comparison
    #####:  682:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  683:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  684:                    violations[i + j] |= 1;  // Response time violation
        -:  685:                }
        -:  686:            }
        -:  687:        }
        -:  688:        
        -:  689:        // Handle remaining metrics
    #####:  690:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  691:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  692:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  693:                violations[i] |= 1;
        -:  694:            }
        -:  695:        }
        -:  696:    #else
        -:  697:        // Fallback to scalar implementation
        -:  698:        for (size_t i = 0; i < count; i++) {
        -:  699:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  700:            if (response_time > thresholds[i]) {
        -:  701:                violations[i] |= 1;
        -:  702:            }
        -:  703:        }
        -:  704:    #endif
    #####:  705:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  658:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  659:                                  const double* thresholds, uint64_t* violations) {
        -:  660:    // SIMD implementation for x86_64
        -:  661:    #ifdef MERCURY_X86_64
        -:  662:        // Process 4 metrics at a time using AVX
    #####:  663:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  664:        
    #####:  665:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  666:            // Load thresholds
    #####:  667:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  668:            
        -:  669:            // Compare with metrics (example for one field)
        -:  670:            // This would be expanded for all threshold types
    #####:  671:            __m256d response_times = _mm256_set_pd(
    #####:  672:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  673:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  674:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  675:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  676:            );
        -:  677:            
        -:  678:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  679:            int mask = _mm256_movemask_pd(comparison);
        -:  680:            
        -:  681:            // Set violation flags based on comparison
    #####:  682:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  683:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  684:                    violations[i + j] |= 1;  // Response time violation
        -:  685:                }
        -:  686:            }
        -:  687:        }
        -:  688:        
        -:  689:        // Handle remaining metrics
    #####:  690:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  691:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  692:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  693:                violations[i] |= 1;
        -:  694:            }
        -:  695:        }
        -:  696:    #else
        -:  697:        // Fallback to scalar implementation
        -:  698:        for (size_t i = 0; i < count; i++) {
        -:  699:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  700:            if (response_time > thresholds[i]) {
        -:  701:                violations[i] |= 1;
        -:  702:            }
        -:  703:        }
        -:  704:    #endif
    #####:  705:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  658:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  659:                                  const double* thresholds, uint64_t* violations) {
        -:  660:    // SIMD implementation for x86_64
        -:  661:    #ifdef MERCURY_X86_64
        -:  662:        // Process 4 metrics at a time using AVX
    #####:  663:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  664:        
    #####:  665:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  666:            // Load thresholds
    #####:  667:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  668:            
        -:  669:            // Compare with metrics (example for one field)
        -:  670:            // This would be expanded for all threshold types
    #####:  671:            __m256d response_times = _mm256_set_pd(
    #####:  672:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  673:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  674:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  675:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  676:            );
        -:  677:            
        -:  678:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  679:            int mask = _mm256_movemask_pd(comparison);
        -:  680:            
        -:  681:            // Set violation flags based on comparison
    #####:  682:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  683:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  684:                    violations[i + j] |= 1;  // Response time violation
        -:  685:                }
        -:  686:            }
        -:  687:        }
        -:  688:        
        -:  689:        // Handle remaining metrics
    #####:  690:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  691:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  692:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  693:                violations[i] |= 1;
        -:  694:            }
        -:  695:        }
        -:  696:    #else
        -:  697:        // Fallback to scalar implementation
        -:  698:        for (size_t i = 0; i < count; i++) {
        -:  699:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  700:            if (response_time > thresholds[i]) {
        -:  701:                violations[i] |= 1;
        -:  702:            }
        -:  703:        }
        -:  704:    #endif
    #####:  705:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  658:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  659:                                  const double* thresholds, uint64_t* violations) {
        -:  660:    // SIMD implementation for x86_64
        -:  661:    #ifdef MERCURY_X86_64
        -:  662:        // Process 4 metrics at a time using AVX
    #####:  663:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  664:        
    #####:  665:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  666:            // Load thresholds
    #####:  667:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  668:            
        -:  669:            // Compare with metrics (example for one field)
        -:  670:            // This would be expanded for all threshold types
    #####:  671:            __m256d response_times = _mm256_set_pd(
    #####:  672:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  673:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  674:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  675:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  676:            );
        -:  677:            
        -:  678:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  679:            int mask = _mm256_movemask_pd(comparison);
        -:  680:            
        -:  681:            // Set violation flags based on comparison
    #####:  682:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  683:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  684:                    violations[i + j] |= 1;  // Response time violation
        -:  685:                }
        -:  686:            }
        -:  687:        }
        -:  688:        
        -:  689:        // Handle remaining metrics
    #####:  690:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  691:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  692:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  693:                violations[i] |= 1;
        -:  694:            }
        -:  695:        }
        -:  696:    #else
        -:  697:        // Fallback to scalar implementation
        -:  698:        for (size_t i = 0; i < count; i++) {
        -:  699:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  700:            if (response_time > thresholds[i]) {
        -:  701:                violations[i] |= 1;
        -:  702:            }
        -:  703:        }
        -:  704:    #endif
    #####:  705:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  658:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  659:                                  const double* thresholds, uint64_t* violations) {
        -:  660:    // SIMD implementation for x86_64
        -:  661:    #ifdef MERCURY_X86_64
        -:  662:        // Process 4 metrics at a time using AVX
    #####:  663:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  664:        
    #####:  665:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  666:            // Load thresholds
    #####:  667:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  668:            
        -:  669:            // Compare with metrics (example for one field)
        -:  670:            // This would be expanded for all threshold types
    #####:  671:            __m256d response_times = _mm256_set_pd(
    #####:  672:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  673:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  674:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  675:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  676:            );
        -:  677:            
        -:  678:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  679:            int mask = _mm256_movemask_pd(comparison);
        -:  680:            
        -:  681:            // Set violation flags based on comparison
    #####:  682:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  683:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  684:                    violations[i + j] |= 1;  // Response time violation
        -:  685:                }
        -:  686:            }
        -:  687:        }
        -:  688:        
        -:  689:        // Handle remaining metrics
    #####:  690:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  691:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  692:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  693:                violations[i] |= 1;
        -:  694:            }
        -:  695:        }
        -:  696:    #else
        -:  697:        // Fallback to scalar implementation
        -:  698:        for (size_t i = 0; i < count; i++) {
        -:  699:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  700:            if (response_time > thresholds[i]) {
        -:  701:                violations[i] |= 1;
        -:  702:            }
        -:  703:        }
        -:  704:    #endif
    #####:  705:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  658:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  659:                                  const double* thresholds, uint64_t* violations) {
        -:  660:    // SIMD implementation for x86_64
        -:  661:    #ifdef MERCURY_X86_64
        -:  662:        // Process 4 metrics at a time using AVX
    #####:  663:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  664:        
    #####:  665:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  666:            // Load thresholds
    #####:  667:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  668:            
        -:  669:            // Compare with metrics (example for one field)
        -:  670:            // This would be expanded for all threshold types
    #####:  671:            __m256d response_times = _mm256_set_pd(
    #####:  672:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  673:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  674:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  675:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  676:            );
        -:  677:            
        -:  678:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  679:            int mask = _mm256_movemask_pd(comparison);
        -:  680:            
        -:  681:            // Set violation flags based on comparison
    #####:  682:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  683:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  684:                    violations[i + j] |= 1;  // Response time violation
        -:  685:                }
        -:  686:            }
        -:  687:        }
        -:  688:        
        -:  689:        // Handle remaining metrics
    #####:  690:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  691:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  692:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  693:                violations[i] |= 1;
        -:  694:            }
        -:  695:        }
        -:  696:    #else
        -:  697:        // Fallback to scalar implementation
        -:  698:        for (size_t i = 0; i < count; i++) {
        -:  699:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  700:            if (response_time > thresholds[i]) {
        -:  701:                violations[i] |= 1;
        -:  702:            }
        -:  703:        }
        -:  704:    #endif
    #####:  705:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  658:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  659:                                  const double* thresholds, uint64_t* violations) {
        -:  660:    // SIMD implementation for x86_64
        -:  661:    #ifdef MERCURY_X86_64
        -:  662:        // Process 4 metrics at a time using AVX
    #####:  663:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  664:        
    #####:  665:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  666:            // Load thresholds
    #####:  667:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  668:            
        -:  669:            // Compare with metrics (example for one field)
        -:  670:            // This would be expanded for all threshold types
    #####:  671:            __m256d response_times = _mm256_set_pd(
    #####:  672:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  673:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  674:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  675:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  676:            );
        -:  677:            
        -:  678:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  679:            int mask = _mm256_movemask_pd(comparison);
        -:  680:            
        -:  681:            // Set violation flags based on comparison
    #####:  682:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  683:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  684:                    violations[i + j] |= 1;  // Response time violation
        -:  685:                }
        -:  686:            }
        -:  687:        }
        -:  688:        
        -:  689:        // Handle remaining metrics
    #####:  690:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  691:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  692:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  693:                violations[i] |= 1;
        -:  694:            }
        -:  695:        }
        -:  696:    #else
        -:  697:        // Fallback to scalar implementation
        -:  698:        for (size_t i = 0; i < count; i++) {
        -:  699:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  700:            if (response_time > thresholds[i]) {
        -:  701:                violations[i] |= 1;
        -:  702:            }
        -:  703:        }
        -:  704:    #endif
    #####:  705:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  658:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  659:                                  const double* thresholds, uint64_t* violations) {
        -:  660:    // SIMD implementation for x86_64
        -:  661:    #ifdef MERCURY_X86_64
        -:  662:        // Process 4 metrics at a time using AVX
    #####:  663:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  664:        
    #####:  665:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  666:            // Load thresholds
    #####:  667:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  668:            
        -:  669:            // Compare with metrics (example for one field)
        -:  670:            // This would be expanded for all threshold types
    #####:  671:            __m256d response_times = _mm256_set_pd(
    #####:  672:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  673:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  674:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  675:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  676:            );
        -:  677:            
        -:  678:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  679:            int mask = _mm256_movemask_pd(comparison);
        -:  680:            
        -:  681:            // Set violation flags based on comparison
    #####:  682:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  683:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  684:                    violations[i + j] |= 1;  // Response time violation
        -:  685:                }
        -:  686:            }
        -:  687:        }
        -:  688:        
        -:  689:        // Handle remaining metrics
    #####:  690:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  691:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  692:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  693:                violations[i] |= 1;
        -:  694:            }
        -:  695:        }
        -:  696:    #else
        -:  697:        // Fallback to scalar implementation
        -:  698:        for (size_t i = 0; i < count; i++) {
        -:  699:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  700:            if (response_time > thresholds[i]) {
        -:  701:                violations[i] |= 1;
        -:  702:            }
        -:  703:        }
        -:  704:    #endif
    #####:  705:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  658:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  659:                                  const double* thresholds, uint64_t* violations) {
        -:  660:    // SIMD implementation for x86_64
        -:  661:    #ifdef MERCURY_X86_64
        -:  662:        // Process 4 metrics at a time using AVX
    #####:  663:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  664:        
    #####:  665:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  666:            // Load thresholds
    #####:  667:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  668:            
        -:  669:            // Compare with metrics (example for one field)
        -:  670:            // This would be expanded for all threshold types
    #####:  671:            __m256d response_times = _mm256_set_pd(
    #####:  672:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  673:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  674:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  675:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  676:            );
        -:  677:            
        -:  678:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  679:            int mask = _mm256_movemask_pd(comparison);
        -:  680:            
        -:  681:            // Set violation flags based on comparison
    #####:  682:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  683:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  684:                    violations[i + j] |= 1;  // Response time violation
        -:  685:                }
        -:  686:            }
        -:  687:        }
        -:  688:        
        -:  689:        // Handle remaining metrics
    #####:  690:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  691:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  692:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  693:                violations[i] |= 1;
        -:  694:            }
        -:  695:        }
        -:  696:    #else
        -:  697:        // Fallback to scalar implementation
        -:  698:        for (size_t i = 0; i < count; i++) {
        -:  699:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  700:            if (response_time > thresholds[i]) {
        -:  701:                violations[i] |= 1;
        -:  702:            }
        -:  703:        }
        -:  704:    #endif
    #####:  705:}
------------------
        -:  706:#endif
        -:  707:
        -:  708:// === ERROR HANDLING ===
        -:  709:
      12*:  710:const MercuryErrorContext* mercury_get_last_error(void) {
      12*:  711:    return &mercury_last_error;
        -:  712:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  710:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  711:    return &mercury_last_error;
        -:  712:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 7 returned 100% blocks executed 100%
        7:  710:const MercuryErrorContext* mercury_get_last_error(void) {
        7:  711:    return &mercury_last_error;
        -:  712:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  710:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  711:    return &mercury_last_error;
        -:  712:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 5 returned 100% blocks executed 100%
        5:  710:const MercuryErrorContext* mercury_get_last_error(void) {
        5:  711:    return &mercury_last_error;
        -:  712:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  710:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  711:    return &mercury_last_error;
        -:  712:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  710:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  711:    return &mercury_last_error;
        -:  712:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  710:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  711:    return &mercury_last_error;
        -:  712:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  710:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  711:    return &mercury_last_error;
        -:  712:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  710:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  711:    return &mercury_last_error;
        -:  712:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  710:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  711:    return &mercury_last_error;
        -:  712:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  710:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  711:    return &mercury_last_error;
        -:  712:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  710:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  711:    return &mercury_last_error;
        -:  712:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  710:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  711:    return &mercury_last_error;
        -:  712:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  710:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  711:    return &mercury_last_error;
        -:  712:}
------------------
        -:  713:
       9*:  714:void mercury_clear_error(void) {
       9*:  715:    mercury_last_error.code = MERCURY_SUCCESS;
       9*:  716:    mercury_last_error.message[0] = '\0';
       9*:  717:    mercury_last_error.function = NULL;
       9*:  718:    mercury_last_error.file = NULL;
       9*:  719:    mercury_last_error.line = 0;
       9*:  720:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  714:void mercury_clear_error(void) {
    #####:  715:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  716:    mercury_last_error.message[0] = '\0';
    #####:  717:    mercury_last_error.function = NULL;
    #####:  718:    mercury_last_error.file = NULL;
    #####:  719:    mercury_last_error.line = 0;
    #####:  720:}
------------------
mercury_clear_error:
function mercury_clear_error called 7 returned 100% blocks executed 100%
        7:  714:void mercury_clear_error(void) {
        7:  715:    mercury_last_error.code = MERCURY_SUCCESS;
        7:  716:    mercury_last_error.message[0] = '\0';
        7:  717:    mercury_last_error.function = NULL;
        7:  718:    mercury_last_error.file = NULL;
        7:  719:    mercury_last_error.line = 0;
        7:  720:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  714:void mercury_clear_error(void) {
    #####:  715:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  716:    mercury_last_error.message[0] = '\0';
    #####:  717:    mercury_last_error.function = NULL;
    #####:  718:    mercury_last_error.file = NULL;
    #####:  719:    mercury_last_error.line = 0;
    #####:  720:}
------------------
mercury_clear_error:
function mercury_clear_error called 2 returned 100% blocks executed 100%
        2:  714:void mercury_clear_error(void) {
        2:  715:    mercury_last_error.code = MERCURY_SUCCESS;
        2:  716:    mercury_last_error.message[0] = '\0';
        2:  717:    mercury_last_error.function = NULL;
        2:  718:    mercury_last_error.file = NULL;
        2:  719:    mercury_last_error.line = 0;
        2:  720:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  714:void mercury_clear_error(void) {
    #####:  715:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  716:    mercury_last_error.message[0] = '\0';
    #####:  717:    mercury_last_error.function = NULL;
    #####:  718:    mercury_last_error.file = NULL;
    #####:  719:    mercury_last_error.line = 0;
    #####:  720:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  714:void mercury_clear_error(void) {
    #####:  715:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  716:    mercury_last_error.message[0] = '\0';
    #####:  717:    mercury_last_error.function = NULL;
    #####:  718:    mercury_last_error.file = NULL;
    #####:  719:    mercury_last_error.line = 0;
    #####:  720:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  714:void mercury_clear_error(void) {
    #####:  715:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  716:    mercury_last_error.message[0] = '\0';
    #####:  717:    mercury_last_error.function = NULL;
    #####:  718:    mercury_last_error.file = NULL;
    #####:  719:    mercury_last_error.line = 0;
    #####:  720:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  714:void mercury_clear_error(void) {
    #####:  715:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  716:    mercury_last_error.message[0] = '\0';
    #####:  717:    mercury_last_error.function = NULL;
    #####:  718:    mercury_last_error.file = NULL;
    #####:  719:    mercury_last_error.line = 0;
    #####:  720:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  714:void mercury_clear_error(void) {
    #####:  715:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  716:    mercury_last_error.message[0] = '\0';
    #####:  717:    mercury_last_error.function = NULL;
    #####:  718:    mercury_last_error.file = NULL;
    #####:  719:    mercury_last_error.line = 0;
    #####:  720:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  714:void mercury_clear_error(void) {
    #####:  715:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  716:    mercury_last_error.message[0] = '\0';
    #####:  717:    mercury_last_error.function = NULL;
    #####:  718:    mercury_last_error.file = NULL;
    #####:  719:    mercury_last_error.line = 0;
    #####:  720:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  714:void mercury_clear_error(void) {
    #####:  715:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  716:    mercury_last_error.message[0] = '\0';
    #####:  717:    mercury_last_error.function = NULL;
    #####:  718:    mercury_last_error.file = NULL;
    #####:  719:    mercury_last_error.line = 0;
    #####:  720:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  714:void mercury_clear_error(void) {
    #####:  715:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  716:    mercury_last_error.message[0] = '\0';
    #####:  717:    mercury_last_error.function = NULL;
    #####:  718:    mercury_last_error.file = NULL;
    #####:  719:    mercury_last_error.line = 0;
    #####:  720:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  714:void mercury_clear_error(void) {
    #####:  715:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  716:    mercury_last_error.message[0] = '\0';
    #####:  717:    mercury_last_error.function = NULL;
    #####:  718:    mercury_last_error.file = NULL;
    #####:  719:    mercury_last_error.line = 0;
    #####:  720:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  714:void mercury_clear_error(void) {
    #####:  715:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  716:    mercury_last_error.message[0] = '\0';
    #####:  717:    mercury_last_error.function = NULL;
    #####:  718:    mercury_last_error.file = NULL;
    #####:  719:    mercury_last_error.line = 0;
    #####:  720:}
------------------
        -:  721:
        -:  722:// === LOGGING ===
        -:  723:
    1729*:  724:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
    1729*:  725:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  726:    
    1729*:  727:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
        -:  728:    
    1729*:  729:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
        -:  730:    
        -:  731:    va_list args;
    1729*:  732:    va_start(args, format);
        -:  733:    vfprintf(output, format, args);
    1729*:  734:    va_end(args);
        -:  735:    
        -:  736:    fprintf(output, "\n");
    1729*:  737:    fflush(output);
    1729*:  738:}
------------------
mercury_default_logger:
function mercury_default_logger called 0 returned 0% blocks executed 0%
    #####:  724:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
    #####:  725:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  726:    
    #####:  727:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 never executed
branch  1 never executed
        -:  728:    
    #####:  729:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 never executed
        -:  730:    
        -:  731:    va_list args;
    #####:  732:    va_start(args, format);
call    0 never executed
        -:  733:    vfprintf(output, format, args);
    #####:  734:    va_end(args);
call    0 never executed
        -:  735:    
        -:  736:    fprintf(output, "\n");
    #####:  737:    fflush(output);
call    0 never executed
    #####:  738:}
------------------
mercury_default_logger:
function mercury_default_logger called 13 returned 100% blocks executed 100%
       13:  724:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
       13:  725:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  726:    
       13:  727:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
        -:  728:    
       13:  729:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 returned 100%
        -:  730:    
        -:  731:    va_list args;
       13:  732:    va_start(args, format);
call    0 returned 100%
        -:  733:    vfprintf(output, format, args);
       13:  734:    va_end(args);
call    0 returned 100%
        -:  735:    
        -:  736:    fprintf(output, "\n");
       13:  737:    fflush(output);
call    0 returned 100%
       13:  738:}
------------------
mercury_default_logger:
function mercury_default_logger called 22 returned 100% blocks executed 88%
       22:  724:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
       22:  725:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  726:    
      22*:  727:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  728:    
       22:  729:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 returned 100%
        -:  730:    
        -:  731:    va_list args;
       22:  732:    va_start(args, format);
call    0 returned 100%
        -:  733:    vfprintf(output, format, args);
       22:  734:    va_end(args);
call    0 returned 100%
        -:  735:    
        -:  736:    fprintf(output, "\n");
       22:  737:    fflush(output);
call    0 returned 100%
       22:  738:}
------------------
mercury_default_logger:
function mercury_default_logger called 0 returned 0% blocks executed 0%
    #####:  724:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
    #####:  725:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  726:    
    #####:  727:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 never executed
branch  1 never executed
        -:  728:    
    #####:  729:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 never executed
        -:  730:    
        -:  731:    va_list args;
    #####:  732:    va_start(args, format);
call    0 never executed
        -:  733:    vfprintf(output, format, args);
    #####:  734:    va_end(args);
call    0 never executed
        -:  735:    
        -:  736:    fprintf(output, "\n");
    #####:  737:    fflush(output);
call    0 never executed
    #####:  738:}
------------------
mercury_default_logger:
function mercury_default_logger called 0 returned 0% blocks executed 0%
    #####:  724:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
    #####:  725:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  726:    
    #####:  727:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 never executed
branch  1 never executed
        -:  728:    
    #####:  729:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 never executed
        -:  730:    
        -:  731:    va_list args;
    #####:  732:    va_start(args, format);
call    0 never executed
        -:  733:    vfprintf(output, format, args);
    #####:  734:    va_end(args);
call    0 never executed
        -:  735:    
        -:  736:    fprintf(output, "\n");
    #####:  737:    fflush(output);
call    0 never executed
    #####:  738:}
------------------
mercury_default_logger:
function mercury_default_logger called 3 returned 100% blocks executed 88%
        3:  724:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
        3:  725:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  726:    
       3*:  727:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  728:    
        3:  729:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 returned 100%
        -:  730:    
        -:  731:    va_list args;
        3:  732:    va_start(args, format);
call    0 returned 100%
        -:  733:    vfprintf(output, format, args);
        3:  734:    va_end(args);
call    0 returned 100%
        -:  735:    
        -:  736:    fprintf(output, "\n");
        3:  737:    fflush(output);
call    0 returned 100%
        3:  738:}
------------------
mercury_default_logger:
function mercury_default_logger called 0 returned 0% blocks executed 0%
    #####:  724:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
    #####:  725:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  726:    
    #####:  727:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 never executed
branch  1 never executed
        -:  728:    
    #####:  729:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 never executed
        -:  730:    
        -:  731:    va_list args;
    #####:  732:    va_start(args, format);
call    0 never executed
        -:  733:    vfprintf(output, format, args);
    #####:  734:    va_end(args);
call    0 never executed
        -:  735:    
        -:  736:    fprintf(output, "\n");
    #####:  737:    fflush(output);
call    0 never executed
    #####:  738:}
------------------
mercury_default_logger:
function mercury_default_logger called 0 returned 0% blocks executed 0%
    #####:  724:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
    #####:  725:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  726:    
    #####:  727:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 never executed
branch  1 never executed
        -:  728:    
    #####:  729:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 never executed
        -:  730:    
        -:  731:    va_list args;
    #####:  732:    va_start(args, format);
call    0 never executed
        -:  733:    vfprintf(output, format, args);
    #####:  734:    va_end(args);
call    0 never executed
        -:  735:    
        -:  736:    fprintf(output, "\n");
    #####:  737:    fflush(output);
call    0 never executed
    #####:  738:}
------------------
mercury_default_logger:
function mercury_default_logger called 0 returned 0% blocks executed 0%
    #####:  724:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
    #####:  725:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  726:    
    #####:  727:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 never executed
branch  1 never executed
        -:  728:    
    #####:  729:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 never executed
        -:  730:    
        -:  731:    va_list args;
    #####:  732:    va_start(args, format);
call    0 never executed
        -:  733:    vfprintf(output, format, args);
    #####:  734:    va_end(args);
call    0 never executed
        -:  735:    
        -:  736:    fprintf(output, "\n");
    #####:  737:    fflush(output);
call    0 never executed
    #####:  738:}
------------------
mercury_default_logger:
function mercury_default_logger called 0 returned 0% blocks executed 0%
    #####:  724:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
    #####:  725:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  726:    
    #####:  727:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 never executed
branch  1 never executed
        -:  728:    
    #####:  729:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 never executed
        -:  730:    
        -:  731:    va_list args;
    #####:  732:    va_start(args, format);
call    0 never executed
        -:  733:    vfprintf(output, format, args);
    #####:  734:    va_end(args);
call    0 never executed
        -:  735:    
        -:  736:    fprintf(output, "\n");
    #####:  737:    fflush(output);
call    0 never executed
    #####:  738:}
------------------
mercury_default_logger:
function mercury_default_logger called 2 returned 100% blocks executed 88%
        2:  724:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
        2:  725:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  726:    
       2*:  727:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  728:    
        2:  729:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 returned 100%
        -:  730:    
        -:  731:    va_list args;
        2:  732:    va_start(args, format);
call    0 returned 100%
        -:  733:    vfprintf(output, format, args);
        2:  734:    va_end(args);
call    0 returned 100%
        -:  735:    
        -:  736:    fprintf(output, "\n");
        2:  737:    fflush(output);
call    0 returned 100%
        2:  738:}
------------------
mercury_default_logger:
function mercury_default_logger called 19 returned 100% blocks executed 100%
       19:  724:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
       19:  725:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  726:    
       19:  727:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 taken 74% (fallthrough)
branch  1 taken 26%
        -:  728:    
       19:  729:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 returned 100%
        -:  730:    
        -:  731:    va_list args;
       19:  732:    va_start(args, format);
call    0 returned 100%
        -:  733:    vfprintf(output, format, args);
       19:  734:    va_end(args);
call    0 returned 100%
        -:  735:    
        -:  736:    fprintf(output, "\n");
       19:  737:    fflush(output);
call    0 returned 100%
       19:  738:}
------------------
mercury_default_logger:
function mercury_default_logger called 694 returned 100% blocks executed 100%
      694:  724:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
      694:  725:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  726:    
      694:  727:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
        -:  728:    
      694:  729:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 returned 100%
        -:  730:    
        -:  731:    va_list args;
      694:  732:    va_start(args, format);
call    0 returned 100%
        -:  733:    vfprintf(output, format, args);
      694:  734:    va_end(args);
call    0 returned 100%
        -:  735:    
        -:  736:    fprintf(output, "\n");
      694:  737:    fflush(output);
call    0 returned 100%
      694:  738:}
------------------
mercury_default_logger:
function mercury_default_logger called 976 returned 100% blocks executed 100%
      976:  724:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
      976:  725:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  726:    
      976:  727:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
        -:  728:    
      976:  729:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 returned 100%
        -:  730:    
        -:  731:    va_list args;
      976:  732:    va_start(args, format);
call    0 returned 100%
        -:  733:    vfprintf(output, format, args);
      976:  734:    va_end(args);
call    0 returned 100%
        -:  735:    
        -:  736:    fprintf(output, "\n");
      976:  737:    fflush(output);
call    0 returned 100%
      976:  738:}
------------------
        -:  739:
        -:  740:// === INITIALIZATION ===
        -:  741:
       3*:  742:MercuryError mercury_init(void) {
       3*:  743:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
        -:  744:    
        -:  745:    // Initialize RDTSC calibration
        -:  746:    #ifdef MERCURY_X86_64
       3*:  747:    mercury_calibrate_rdtsc();
        -:  748:    #endif
        -:  749:    
        -:  750:    // Clear error state
       3*:  751:    mercury_clear_error();
        -:  752:    
       3*:  753:    MERCURY_INFO("Mercury initialization complete");
       3*:  754:    return MERCURY_SUCCESS;
        -:  755:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  742:MercuryError mercury_init(void) {
    #####:  743:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  744:    
        -:  745:    // Initialize RDTSC calibration
        -:  746:    #ifdef MERCURY_X86_64
    #####:  747:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  748:    #endif
        -:  749:    
        -:  750:    // Clear error state
    #####:  751:    mercury_clear_error();
call    0 never executed
        -:  752:    
    #####:  753:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  754:    return MERCURY_SUCCESS;
        -:  755:}
------------------
mercury_init:
function mercury_init called 3 returned 100% blocks executed 100%
        3:  742:MercuryError mercury_init(void) {
        3:  743:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  744:    
        -:  745:    // Initialize RDTSC calibration
        -:  746:    #ifdef MERCURY_X86_64
        3:  747:    mercury_calibrate_rdtsc();
call    0 returned 100%
        -:  748:    #endif
        -:  749:    
        -:  750:    // Clear error state
        3:  751:    mercury_clear_error();
call    0 returned 100%
        -:  752:    
        3:  753:    MERCURY_INFO("Mercury initialization complete");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        3:  754:    return MERCURY_SUCCESS;
        -:  755:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  742:MercuryError mercury_init(void) {
    #####:  743:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  744:    
        -:  745:    // Initialize RDTSC calibration
        -:  746:    #ifdef MERCURY_X86_64
    #####:  747:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  748:    #endif
        -:  749:    
        -:  750:    // Clear error state
    #####:  751:    mercury_clear_error();
call    0 never executed
        -:  752:    
    #####:  753:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  754:    return MERCURY_SUCCESS;
        -:  755:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  742:MercuryError mercury_init(void) {
    #####:  743:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  744:    
        -:  745:    // Initialize RDTSC calibration
        -:  746:    #ifdef MERCURY_X86_64
    #####:  747:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  748:    #endif
        -:  749:    
        -:  750:    // Clear error state
    #####:  751:    mercury_clear_error();
call    0 never executed
        -:  752:    
    #####:  753:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  754:    return MERCURY_SUCCESS;
        -:  755:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  742:MercuryError mercury_init(void) {
    #####:  743:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  744:    
        -:  745:    // Initialize RDTSC calibration
        -:  746:    #ifdef MERCURY_X86_64
    #####:  747:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  748:    #endif
        -:  749:    
        -:  750:    // Clear error state
    #####:  751:    mercury_clear_error();
call    0 never executed
        -:  752:    
    #####:  753:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  754:    return MERCURY_SUCCESS;
        -:  755:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  742:MercuryError mercury_init(void) {
    #####:  743:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  744:    
        -:  745:    // Initialize RDTSC calibration
        -:  746:    #ifdef MERCURY_X86_64
    #####:  747:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  748:    #endif
        -:  749:    
        -:  750:    // Clear error state
    #####:  751:    mercury_clear_error();
call    0 never executed
        -:  752:    
    #####:  753:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  754:    return MERCURY_SUCCESS;
        -:  755:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  742:MercuryError mercury_init(void) {
    #####:  743:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  744:    
        -:  745:    // Initialize RDTSC calibration
        -:  746:    #ifdef MERCURY_X86_64
    #####:  747:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  748:    #endif
        -:  749:    
        -:  750:    // Clear error state
    #####:  751:    mercury_clear_error();
call    0 never executed
        -:  752:    
    #####:  753:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  754:    return MERCURY_SUCCESS;
        -:  755:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  742:MercuryError mercury_init(void) {
    #####:  743:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  744:    
        -:  745:    // Initialize RDTSC calibration
        -:  746:    #ifdef MERCURY_X86_64
    #####:  747:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  748:    #endif
        -:  749:    
        -:  750:    // Clear error state
    #####:  751:    mercury_clear_error();
call    0 never executed
        -:  752:    
    #####:  753:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  754:    return MERCURY_SUCCESS;
        -:  755:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  742:MercuryError mercury_init(void) {
    #####:  743:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  744:    
        -:  745:    // Initialize RDTSC calibration
        -:  746:    #ifdef MERCURY_X86_64
    #####:  747:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  748:    #endif
        -:  749:    
        -:  750:    // Clear error state
    #####:  751:    mercury_clear_error();
call    0 never executed
        -:  752:    
    #####:  753:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  754:    return MERCURY_SUCCESS;
        -:  755:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  742:MercuryError mercury_init(void) {
    #####:  743:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  744:    
        -:  745:    // Initialize RDTSC calibration
        -:  746:    #ifdef MERCURY_X86_64
    #####:  747:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  748:    #endif
        -:  749:    
        -:  750:    // Clear error state
    #####:  751:    mercury_clear_error();
call    0 never executed
        -:  752:    
    #####:  753:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  754:    return MERCURY_SUCCESS;
        -:  755:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  742:MercuryError mercury_init(void) {
    #####:  743:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  744:    
        -:  745:    // Initialize RDTSC calibration
        -:  746:    #ifdef MERCURY_X86_64
    #####:  747:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  748:    #endif
        -:  749:    
        -:  750:    // Clear error state
    #####:  751:    mercury_clear_error();
call    0 never executed
        -:  752:    
    #####:  753:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  754:    return MERCURY_SUCCESS;
        -:  755:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  742:MercuryError mercury_init(void) {
    #####:  743:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  744:    
        -:  745:    // Initialize RDTSC calibration
        -:  746:    #ifdef MERCURY_X86_64
    #####:  747:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  748:    #endif
        -:  749:    
        -:  750:    // Clear error state
    #####:  751:    mercury_clear_error();
call    0 never executed
        -:  752:    
    #####:  753:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  754:    return MERCURY_SUCCESS;
        -:  755:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  742:MercuryError mercury_init(void) {
    #####:  743:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  744:    
        -:  745:    // Initialize RDTSC calibration
        -:  746:    #ifdef MERCURY_X86_64
    #####:  747:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  748:    #endif
        -:  749:    
        -:  750:    // Clear error state
    #####:  751:    mercury_clear_error();
call    0 never executed
        -:  752:    
    #####:  753:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  754:    return MERCURY_SUCCESS;
        -:  755:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  742:MercuryError mercury_init(void) {
    #####:  743:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  744:    
        -:  745:    // Initialize RDTSC calibration
        -:  746:    #ifdef MERCURY_X86_64
    #####:  747:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  748:    #endif
        -:  749:    
        -:  750:    // Clear error state
    #####:  751:    mercury_clear_error();
call    0 never executed
        -:  752:    
    #####:  753:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  754:    return MERCURY_SUCCESS;
        -:  755:}
------------------
        -:  756:
       2*:  757:void mercury_cleanup(void) {
       2*:  758:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
       2*:  759:    mercury_clear_error();
       2*:  760:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  757:void mercury_cleanup(void) {
    #####:  758:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  759:    mercury_clear_error();
call    0 never executed
    #####:  760:}
------------------
mercury_cleanup:
function mercury_cleanup called 2 returned 100% blocks executed 100%
        2:  757:void mercury_cleanup(void) {
        2:  758:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        2:  759:    mercury_clear_error();
call    0 returned 100%
        2:  760:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  757:void mercury_cleanup(void) {
    #####:  758:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  759:    mercury_clear_error();
call    0 never executed
    #####:  760:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  757:void mercury_cleanup(void) {
    #####:  758:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  759:    mercury_clear_error();
call    0 never executed
    #####:  760:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  757:void mercury_cleanup(void) {
    #####:  758:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  759:    mercury_clear_error();
call    0 never executed
    #####:  760:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  757:void mercury_cleanup(void) {
    #####:  758:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  759:    mercury_clear_error();
call    0 never executed
    #####:  760:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  757:void mercury_cleanup(void) {
    #####:  758:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  759:    mercury_clear_error();
call    0 never executed
    #####:  760:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  757:void mercury_cleanup(void) {
    #####:  758:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  759:    mercury_clear_error();
call    0 never executed
    #####:  760:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  757:void mercury_cleanup(void) {
    #####:  758:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  759:    mercury_clear_error();
call    0 never executed
    #####:  760:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  757:void mercury_cleanup(void) {
    #####:  758:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  759:    mercury_clear_error();
call    0 never executed
    #####:  760:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  757:void mercury_cleanup(void) {
    #####:  758:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  759:    mercury_clear_error();
call    0 never executed
    #####:  760:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  757:void mercury_cleanup(void) {
    #####:  758:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  759:    mercury_clear_error();
call    0 never executed
    #####:  760:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  757:void mercury_cleanup(void) {
    #####:  758:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  759:    mercury_clear_error();
call    0 never executed
    #####:  760:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  757:void mercury_cleanup(void) {
    #####:  758:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  759:    mercury_clear_error();
call    0 never executed
    #####:  760:}
------------------
        -:  761:
        -:  762:// === MEMORY POOL IMPLEMENTATION ===
        -:  763:
        -:  764:// Memory pool types now in common.h
        -:  765:
       8*:  766:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
       8*:  767:    if (MERCURY_UNLIKELY(!pool)) return;
        -:  768:    
       8*:  769:    pool->block_size = block_size;
       8*:  770:    pool->num_blocks = num_blocks;
        -:  771:    
        -:  772:    // Initialize atomic variables
       8*:  773:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
       8*:  774:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  775:    
        -:  776:    // Pre-allocate all blocks in a contiguous array for better cache locality
       8*:  777:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
       8*:  778:    if (!pool->all_blocks) {
    #####:  779:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  780:        return;
        -:  781:    }
        -:  782:    
        -:  783:    // Initialize all blocks and build the lock-free stack
        -:  784:    memory_block_t* stack_head = NULL;
    5145*:  785:    for (size_t i = 0; i < num_blocks; i++) {
    5137*:  786:        memory_block_t* block = &pool->all_blocks[i];
        -:  787:        
    5137*:  788:        block->size = block_size;
    5137*:  789:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
    5137*:  790:        if (!block->data) {
        -:  791:            // Skip this block on allocation failure
    #####:  792:            continue;
        -:  793:        }
        -:  794:        
    5137*:  795:        block->in_use = false;
        -:  796:        // Build stack in reverse order for better locality
    5137*:  797:        block->next = stack_head;
        -:  798:        stack_head = block;
        -:  799:    }
        -:  800:    
        -:  801:    // Set the initial stack head atomically
       8*:  802:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  803:    
        -:  804:    // Count actual allocated blocks
        -:  805:    size_t count = 0;
        -:  806:    memory_block_t* current = stack_head;
    5145*:  807:    while (current) {
    5137*:  808:        count++;
    5137*:  809:        current = current->next;
        -:  810:    }
       8*:  811:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  812:}
------------------
memory_pool_init:
function memory_pool_init called 0 returned 0% blocks executed 0%
    #####:  766:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
    #####:  767:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 never executed
branch  1 never executed
        -:  768:    
    #####:  769:    pool->block_size = block_size;
    #####:  770:    pool->num_blocks = num_blocks;
        -:  771:    
        -:  772:    // Initialize atomic variables
    #####:  773:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  774:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  775:    
        -:  776:    // Pre-allocate all blocks in a contiguous array for better cache locality
    #####:  777:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 never executed
    #####:  778:    if (!pool->all_blocks) {
branch  0 never executed
branch  1 never executed
    #####:  779:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  780:        return;
        -:  781:    }
        -:  782:    
        -:  783:    // Initialize all blocks and build the lock-free stack
        -:  784:    memory_block_t* stack_head = NULL;
    #####:  785:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  786:        memory_block_t* block = &pool->all_blocks[i];
        -:  787:        
    #####:  788:        block->size = block_size;
    #####:  789:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 never executed
    #####:  790:        if (!block->data) {
branch  0 never executed
branch  1 never executed
        -:  791:            // Skip this block on allocation failure
    #####:  792:            continue;
        -:  793:        }
        -:  794:        
    #####:  795:        block->in_use = false;
        -:  796:        // Build stack in reverse order for better locality
    #####:  797:        block->next = stack_head;
        -:  798:        stack_head = block;
        -:  799:    }
        -:  800:    
        -:  801:    // Set the initial stack head atomically
    #####:  802:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  803:    
        -:  804:    // Count actual allocated blocks
        -:  805:    size_t count = 0;
        -:  806:    memory_block_t* current = stack_head;
    #####:  807:    while (current) {
branch  0 never executed
branch  1 never executed
    #####:  808:        count++;
    #####:  809:        current = current->next;
        -:  810:    }
    #####:  811:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  812:}
------------------
memory_pool_init:
function memory_pool_init called 2 returned 100% blocks executed 87%
        2:  766:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
        2:  767:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  768:    
        2:  769:    pool->block_size = block_size;
        2:  770:    pool->num_blocks = num_blocks;
        -:  771:    
        -:  772:    // Initialize atomic variables
        2:  773:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        2:  774:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  775:    
        -:  776:    // Pre-allocate all blocks in a contiguous array for better cache locality
        2:  777:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 returned 100%
        2:  778:    if (!pool->all_blocks) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  779:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  780:        return;
        -:  781:    }
        -:  782:    
        -:  783:    // Initialize all blocks and build the lock-free stack
        -:  784:    memory_block_t* stack_head = NULL;
      118:  785:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
      116:  786:        memory_block_t* block = &pool->all_blocks[i];
        -:  787:        
      116:  788:        block->size = block_size;
      116:  789:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 returned 100%
     116*:  790:        if (!block->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  791:            // Skip this block on allocation failure
    #####:  792:            continue;
        -:  793:        }
        -:  794:        
      116:  795:        block->in_use = false;
        -:  796:        // Build stack in reverse order for better locality
      116:  797:        block->next = stack_head;
        -:  798:        stack_head = block;
        -:  799:    }
        -:  800:    
        -:  801:    // Set the initial stack head atomically
        2:  802:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  803:    
        -:  804:    // Count actual allocated blocks
        -:  805:    size_t count = 0;
        -:  806:    memory_block_t* current = stack_head;
      118:  807:    while (current) {
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
      116:  808:        count++;
      116:  809:        current = current->next;
        -:  810:    }
        2:  811:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  812:}
------------------
memory_pool_init:
function memory_pool_init called 2 returned 100% blocks executed 87%
        2:  766:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
        2:  767:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  768:    
        2:  769:    pool->block_size = block_size;
        2:  770:    pool->num_blocks = num_blocks;
        -:  771:    
        -:  772:    // Initialize atomic variables
        2:  773:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        2:  774:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  775:    
        -:  776:    // Pre-allocate all blocks in a contiguous array for better cache locality
        2:  777:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 returned 100%
        2:  778:    if (!pool->all_blocks) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  779:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  780:        return;
        -:  781:    }
        -:  782:    
        -:  783:    // Initialize all blocks and build the lock-free stack
        -:  784:    memory_block_t* stack_head = NULL;
        8:  785:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        6:  786:        memory_block_t* block = &pool->all_blocks[i];
        -:  787:        
        6:  788:        block->size = block_size;
        6:  789:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 returned 100%
       6*:  790:        if (!block->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  791:            // Skip this block on allocation failure
    #####:  792:            continue;
        -:  793:        }
        -:  794:        
        6:  795:        block->in_use = false;
        -:  796:        // Build stack in reverse order for better locality
        6:  797:        block->next = stack_head;
        -:  798:        stack_head = block;
        -:  799:    }
        -:  800:    
        -:  801:    // Set the initial stack head atomically
        2:  802:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  803:    
        -:  804:    // Count actual allocated blocks
        -:  805:    size_t count = 0;
        -:  806:    memory_block_t* current = stack_head;
        8:  807:    while (current) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        6:  808:        count++;
        6:  809:        current = current->next;
        -:  810:    }
        2:  811:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  812:}
------------------
memory_pool_init:
function memory_pool_init called 2 returned 100% blocks executed 87%
        2:  766:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
        2:  767:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  768:    
        2:  769:    pool->block_size = block_size;
        2:  770:    pool->num_blocks = num_blocks;
        -:  771:    
        -:  772:    // Initialize atomic variables
        2:  773:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        2:  774:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  775:    
        -:  776:    // Pre-allocate all blocks in a contiguous array for better cache locality
        2:  777:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 returned 100%
        2:  778:    if (!pool->all_blocks) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  779:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  780:        return;
        -:  781:    }
        -:  782:    
        -:  783:    // Initialize all blocks and build the lock-free stack
        -:  784:    memory_block_t* stack_head = NULL;
       17:  785:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
       15:  786:        memory_block_t* block = &pool->all_blocks[i];
        -:  787:        
       15:  788:        block->size = block_size;
       15:  789:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 returned 100%
      15*:  790:        if (!block->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  791:            // Skip this block on allocation failure
    #####:  792:            continue;
        -:  793:        }
        -:  794:        
       15:  795:        block->in_use = false;
        -:  796:        // Build stack in reverse order for better locality
       15:  797:        block->next = stack_head;
        -:  798:        stack_head = block;
        -:  799:    }
        -:  800:    
        -:  801:    // Set the initial stack head atomically
        2:  802:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  803:    
        -:  804:    // Count actual allocated blocks
        -:  805:    size_t count = 0;
        -:  806:    memory_block_t* current = stack_head;
       17:  807:    while (current) {
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
       15:  808:        count++;
       15:  809:        current = current->next;
        -:  810:    }
        2:  811:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  812:}
------------------
memory_pool_init:
function memory_pool_init called 0 returned 0% blocks executed 0%
    #####:  766:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
    #####:  767:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 never executed
branch  1 never executed
        -:  768:    
    #####:  769:    pool->block_size = block_size;
    #####:  770:    pool->num_blocks = num_blocks;
        -:  771:    
        -:  772:    // Initialize atomic variables
    #####:  773:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  774:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  775:    
        -:  776:    // Pre-allocate all blocks in a contiguous array for better cache locality
    #####:  777:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 never executed
    #####:  778:    if (!pool->all_blocks) {
branch  0 never executed
branch  1 never executed
    #####:  779:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  780:        return;
        -:  781:    }
        -:  782:    
        -:  783:    // Initialize all blocks and build the lock-free stack
        -:  784:    memory_block_t* stack_head = NULL;
    #####:  785:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  786:        memory_block_t* block = &pool->all_blocks[i];
        -:  787:        
    #####:  788:        block->size = block_size;
    #####:  789:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 never executed
    #####:  790:        if (!block->data) {
branch  0 never executed
branch  1 never executed
        -:  791:            // Skip this block on allocation failure
    #####:  792:            continue;
        -:  793:        }
        -:  794:        
    #####:  795:        block->in_use = false;
        -:  796:        // Build stack in reverse order for better locality
    #####:  797:        block->next = stack_head;
        -:  798:        stack_head = block;
        -:  799:    }
        -:  800:    
        -:  801:    // Set the initial stack head atomically
    #####:  802:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  803:    
        -:  804:    // Count actual allocated blocks
        -:  805:    size_t count = 0;
        -:  806:    memory_block_t* current = stack_head;
    #####:  807:    while (current) {
branch  0 never executed
branch  1 never executed
    #####:  808:        count++;
    #####:  809:        current = current->next;
        -:  810:    }
    #####:  811:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  812:}
------------------
memory_pool_init:
function memory_pool_init called 0 returned 0% blocks executed 0%
    #####:  766:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
    #####:  767:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 never executed
branch  1 never executed
        -:  768:    
    #####:  769:    pool->block_size = block_size;
    #####:  770:    pool->num_blocks = num_blocks;
        -:  771:    
        -:  772:    // Initialize atomic variables
    #####:  773:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  774:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  775:    
        -:  776:    // Pre-allocate all blocks in a contiguous array for better cache locality
    #####:  777:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 never executed
    #####:  778:    if (!pool->all_blocks) {
branch  0 never executed
branch  1 never executed
    #####:  779:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  780:        return;
        -:  781:    }
        -:  782:    
        -:  783:    // Initialize all blocks and build the lock-free stack
        -:  784:    memory_block_t* stack_head = NULL;
    #####:  785:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  786:        memory_block_t* block = &pool->all_blocks[i];
        -:  787:        
    #####:  788:        block->size = block_size;
    #####:  789:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 never executed
    #####:  790:        if (!block->data) {
branch  0 never executed
branch  1 never executed
        -:  791:            // Skip this block on allocation failure
    #####:  792:            continue;
        -:  793:        }
        -:  794:        
    #####:  795:        block->in_use = false;
        -:  796:        // Build stack in reverse order for better locality
    #####:  797:        block->next = stack_head;
        -:  798:        stack_head = block;
        -:  799:    }
        -:  800:    
        -:  801:    // Set the initial stack head atomically
    #####:  802:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  803:    
        -:  804:    // Count actual allocated blocks
        -:  805:    size_t count = 0;
        -:  806:    memory_block_t* current = stack_head;
    #####:  807:    while (current) {
branch  0 never executed
branch  1 never executed
    #####:  808:        count++;
    #####:  809:        current = current->next;
        -:  810:    }
    #####:  811:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  812:}
------------------
memory_pool_init:
function memory_pool_init called 0 returned 0% blocks executed 0%
    #####:  766:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
    #####:  767:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 never executed
branch  1 never executed
        -:  768:    
    #####:  769:    pool->block_size = block_size;
    #####:  770:    pool->num_blocks = num_blocks;
        -:  771:    
        -:  772:    // Initialize atomic variables
    #####:  773:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  774:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  775:    
        -:  776:    // Pre-allocate all blocks in a contiguous array for better cache locality
    #####:  777:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 never executed
    #####:  778:    if (!pool->all_blocks) {
branch  0 never executed
branch  1 never executed
    #####:  779:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  780:        return;
        -:  781:    }
        -:  782:    
        -:  783:    // Initialize all blocks and build the lock-free stack
        -:  784:    memory_block_t* stack_head = NULL;
    #####:  785:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  786:        memory_block_t* block = &pool->all_blocks[i];
        -:  787:        
    #####:  788:        block->size = block_size;
    #####:  789:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 never executed
    #####:  790:        if (!block->data) {
branch  0 never executed
branch  1 never executed
        -:  791:            // Skip this block on allocation failure
    #####:  792:            continue;
        -:  793:        }
        -:  794:        
    #####:  795:        block->in_use = false;
        -:  796:        // Build stack in reverse order for better locality
    #####:  797:        block->next = stack_head;
        -:  798:        stack_head = block;
        -:  799:    }
        -:  800:    
        -:  801:    // Set the initial stack head atomically
    #####:  802:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  803:    
        -:  804:    // Count actual allocated blocks
        -:  805:    size_t count = 0;
        -:  806:    memory_block_t* current = stack_head;
    #####:  807:    while (current) {
branch  0 never executed
branch  1 never executed
    #####:  808:        count++;
    #####:  809:        current = current->next;
        -:  810:    }
    #####:  811:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  812:}
------------------
memory_pool_init:
function memory_pool_init called 0 returned 0% blocks executed 0%
    #####:  766:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
    #####:  767:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 never executed
branch  1 never executed
        -:  768:    
    #####:  769:    pool->block_size = block_size;
    #####:  770:    pool->num_blocks = num_blocks;
        -:  771:    
        -:  772:    // Initialize atomic variables
    #####:  773:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  774:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  775:    
        -:  776:    // Pre-allocate all blocks in a contiguous array for better cache locality
    #####:  777:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 never executed
    #####:  778:    if (!pool->all_blocks) {
branch  0 never executed
branch  1 never executed
    #####:  779:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  780:        return;
        -:  781:    }
        -:  782:    
        -:  783:    // Initialize all blocks and build the lock-free stack
        -:  784:    memory_block_t* stack_head = NULL;
    #####:  785:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  786:        memory_block_t* block = &pool->all_blocks[i];
        -:  787:        
    #####:  788:        block->size = block_size;
    #####:  789:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 never executed
    #####:  790:        if (!block->data) {
branch  0 never executed
branch  1 never executed
        -:  791:            // Skip this block on allocation failure
    #####:  792:            continue;
        -:  793:        }
        -:  794:        
    #####:  795:        block->in_use = false;
        -:  796:        // Build stack in reverse order for better locality
    #####:  797:        block->next = stack_head;
        -:  798:        stack_head = block;
        -:  799:    }
        -:  800:    
        -:  801:    // Set the initial stack head atomically
    #####:  802:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  803:    
        -:  804:    // Count actual allocated blocks
        -:  805:    size_t count = 0;
        -:  806:    memory_block_t* current = stack_head;
    #####:  807:    while (current) {
branch  0 never executed
branch  1 never executed
    #####:  808:        count++;
    #####:  809:        current = current->next;
        -:  810:    }
    #####:  811:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  812:}
------------------
memory_pool_init:
function memory_pool_init called 0 returned 0% blocks executed 0%
    #####:  766:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
    #####:  767:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 never executed
branch  1 never executed
        -:  768:    
    #####:  769:    pool->block_size = block_size;
    #####:  770:    pool->num_blocks = num_blocks;
        -:  771:    
        -:  772:    // Initialize atomic variables
    #####:  773:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  774:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  775:    
        -:  776:    // Pre-allocate all blocks in a contiguous array for better cache locality
    #####:  777:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 never executed
    #####:  778:    if (!pool->all_blocks) {
branch  0 never executed
branch  1 never executed
    #####:  779:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  780:        return;
        -:  781:    }
        -:  782:    
        -:  783:    // Initialize all blocks and build the lock-free stack
        -:  784:    memory_block_t* stack_head = NULL;
    #####:  785:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  786:        memory_block_t* block = &pool->all_blocks[i];
        -:  787:        
    #####:  788:        block->size = block_size;
    #####:  789:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 never executed
    #####:  790:        if (!block->data) {
branch  0 never executed
branch  1 never executed
        -:  791:            // Skip this block on allocation failure
    #####:  792:            continue;
        -:  793:        }
        -:  794:        
    #####:  795:        block->in_use = false;
        -:  796:        // Build stack in reverse order for better locality
    #####:  797:        block->next = stack_head;
        -:  798:        stack_head = block;
        -:  799:    }
        -:  800:    
        -:  801:    // Set the initial stack head atomically
    #####:  802:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  803:    
        -:  804:    // Count actual allocated blocks
        -:  805:    size_t count = 0;
        -:  806:    memory_block_t* current = stack_head;
    #####:  807:    while (current) {
branch  0 never executed
branch  1 never executed
    #####:  808:        count++;
    #####:  809:        current = current->next;
        -:  810:    }
    #####:  811:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  812:}
------------------
memory_pool_init:
function memory_pool_init called 1 returned 100% blocks executed 87%
        1:  766:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
        1:  767:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  768:    
        1:  769:    pool->block_size = block_size;
        1:  770:    pool->num_blocks = num_blocks;
        -:  771:    
        -:  772:    // Initialize atomic variables
        1:  773:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        1:  774:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  775:    
        -:  776:    // Pre-allocate all blocks in a contiguous array for better cache locality
        1:  777:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 returned 100%
        1:  778:    if (!pool->all_blocks) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  779:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  780:        return;
        -:  781:    }
        -:  782:    
        -:  783:    // Initialize all blocks and build the lock-free stack
        -:  784:    memory_block_t* stack_head = NULL;
     2501:  785:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     2500:  786:        memory_block_t* block = &pool->all_blocks[i];
        -:  787:        
     2500:  788:        block->size = block_size;
     2500:  789:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 returned 100%
    2500*:  790:        if (!block->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  791:            // Skip this block on allocation failure
    #####:  792:            continue;
        -:  793:        }
        -:  794:        
     2500:  795:        block->in_use = false;
        -:  796:        // Build stack in reverse order for better locality
     2500:  797:        block->next = stack_head;
        -:  798:        stack_head = block;
        -:  799:    }
        -:  800:    
        -:  801:    // Set the initial stack head atomically
        1:  802:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  803:    
        -:  804:    // Count actual allocated blocks
        -:  805:    size_t count = 0;
        -:  806:    memory_block_t* current = stack_head;
     2501:  807:    while (current) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     2500:  808:        count++;
     2500:  809:        current = current->next;
        -:  810:    }
        1:  811:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  812:}
------------------
memory_pool_init:
function memory_pool_init called 1 returned 100% blocks executed 87%
        1:  766:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
        1:  767:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  768:    
        1:  769:    pool->block_size = block_size;
        1:  770:    pool->num_blocks = num_blocks;
        -:  771:    
        -:  772:    // Initialize atomic variables
        1:  773:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        1:  774:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  775:    
        -:  776:    // Pre-allocate all blocks in a contiguous array for better cache locality
        1:  777:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 returned 100%
        1:  778:    if (!pool->all_blocks) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  779:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  780:        return;
        -:  781:    }
        -:  782:    
        -:  783:    // Initialize all blocks and build the lock-free stack
        -:  784:    memory_block_t* stack_head = NULL;
     2501:  785:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     2500:  786:        memory_block_t* block = &pool->all_blocks[i];
        -:  787:        
     2500:  788:        block->size = block_size;
     2500:  789:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 returned 100%
    2500*:  790:        if (!block->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  791:            // Skip this block on allocation failure
    #####:  792:            continue;
        -:  793:        }
        -:  794:        
     2500:  795:        block->in_use = false;
        -:  796:        // Build stack in reverse order for better locality
     2500:  797:        block->next = stack_head;
        -:  798:        stack_head = block;
        -:  799:    }
        -:  800:    
        -:  801:    // Set the initial stack head atomically
        1:  802:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  803:    
        -:  804:    // Count actual allocated blocks
        -:  805:    size_t count = 0;
        -:  806:    memory_block_t* current = stack_head;
     2501:  807:    while (current) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     2500:  808:        count++;
     2500:  809:        current = current->next;
        -:  810:    }
        1:  811:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  812:}
------------------
memory_pool_init:
function memory_pool_init called 0 returned 0% blocks executed 0%
    #####:  766:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
    #####:  767:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 never executed
branch  1 never executed
        -:  768:    
    #####:  769:    pool->block_size = block_size;
    #####:  770:    pool->num_blocks = num_blocks;
        -:  771:    
        -:  772:    // Initialize atomic variables
    #####:  773:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  774:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  775:    
        -:  776:    // Pre-allocate all blocks in a contiguous array for better cache locality
    #####:  777:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 never executed
    #####:  778:    if (!pool->all_blocks) {
branch  0 never executed
branch  1 never executed
    #####:  779:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  780:        return;
        -:  781:    }
        -:  782:    
        -:  783:    // Initialize all blocks and build the lock-free stack
        -:  784:    memory_block_t* stack_head = NULL;
    #####:  785:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  786:        memory_block_t* block = &pool->all_blocks[i];
        -:  787:        
    #####:  788:        block->size = block_size;
    #####:  789:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 never executed
    #####:  790:        if (!block->data) {
branch  0 never executed
branch  1 never executed
        -:  791:            // Skip this block on allocation failure
    #####:  792:            continue;
        -:  793:        }
        -:  794:        
    #####:  795:        block->in_use = false;
        -:  796:        // Build stack in reverse order for better locality
    #####:  797:        block->next = stack_head;
        -:  798:        stack_head = block;
        -:  799:    }
        -:  800:    
        -:  801:    // Set the initial stack head atomically
    #####:  802:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  803:    
        -:  804:    // Count actual allocated blocks
        -:  805:    size_t count = 0;
        -:  806:    memory_block_t* current = stack_head;
    #####:  807:    while (current) {
branch  0 never executed
branch  1 never executed
    #####:  808:        count++;
    #####:  809:        current = current->next;
        -:  810:    }
    #####:  811:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  812:}
------------------
memory_pool_init:
function memory_pool_init called 0 returned 0% blocks executed 0%
    #####:  766:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
    #####:  767:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 never executed
branch  1 never executed
        -:  768:    
    #####:  769:    pool->block_size = block_size;
    #####:  770:    pool->num_blocks = num_blocks;
        -:  771:    
        -:  772:    // Initialize atomic variables
    #####:  773:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  774:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  775:    
        -:  776:    // Pre-allocate all blocks in a contiguous array for better cache locality
    #####:  777:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 never executed
    #####:  778:    if (!pool->all_blocks) {
branch  0 never executed
branch  1 never executed
    #####:  779:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  780:        return;
        -:  781:    }
        -:  782:    
        -:  783:    // Initialize all blocks and build the lock-free stack
        -:  784:    memory_block_t* stack_head = NULL;
    #####:  785:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  786:        memory_block_t* block = &pool->all_blocks[i];
        -:  787:        
    #####:  788:        block->size = block_size;
    #####:  789:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 never executed
    #####:  790:        if (!block->data) {
branch  0 never executed
branch  1 never executed
        -:  791:            // Skip this block on allocation failure
    #####:  792:            continue;
        -:  793:        }
        -:  794:        
    #####:  795:        block->in_use = false;
        -:  796:        // Build stack in reverse order for better locality
    #####:  797:        block->next = stack_head;
        -:  798:        stack_head = block;
        -:  799:    }
        -:  800:    
        -:  801:    // Set the initial stack head atomically
    #####:  802:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  803:    
        -:  804:    // Count actual allocated blocks
        -:  805:    size_t count = 0;
        -:  806:    memory_block_t* current = stack_head;
    #####:  807:    while (current) {
branch  0 never executed
branch  1 never executed
    #####:  808:        count++;
    #####:  809:        current = current->next;
        -:  810:    }
    #####:  811:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  812:}
------------------
memory_pool_init:
function memory_pool_init called 0 returned 0% blocks executed 0%
    #####:  766:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
    #####:  767:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 never executed
branch  1 never executed
        -:  768:    
    #####:  769:    pool->block_size = block_size;
    #####:  770:    pool->num_blocks = num_blocks;
        -:  771:    
        -:  772:    // Initialize atomic variables
    #####:  773:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  774:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  775:    
        -:  776:    // Pre-allocate all blocks in a contiguous array for better cache locality
    #####:  777:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 never executed
    #####:  778:    if (!pool->all_blocks) {
branch  0 never executed
branch  1 never executed
    #####:  779:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  780:        return;
        -:  781:    }
        -:  782:    
        -:  783:    // Initialize all blocks and build the lock-free stack
        -:  784:    memory_block_t* stack_head = NULL;
    #####:  785:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  786:        memory_block_t* block = &pool->all_blocks[i];
        -:  787:        
    #####:  788:        block->size = block_size;
    #####:  789:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 never executed
    #####:  790:        if (!block->data) {
branch  0 never executed
branch  1 never executed
        -:  791:            // Skip this block on allocation failure
    #####:  792:            continue;
        -:  793:        }
        -:  794:        
    #####:  795:        block->in_use = false;
        -:  796:        // Build stack in reverse order for better locality
    #####:  797:        block->next = stack_head;
        -:  798:        stack_head = block;
        -:  799:    }
        -:  800:    
        -:  801:    // Set the initial stack head atomically
    #####:  802:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  803:    
        -:  804:    // Count actual allocated blocks
        -:  805:    size_t count = 0;
        -:  806:    memory_block_t* current = stack_head;
    #####:  807:    while (current) {
branch  0 never executed
branch  1 never executed
    #####:  808:        count++;
    #####:  809:        current = current->next;
        -:  810:    }
    #####:  811:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  812:}
------------------
        -:  813:
    3209*:  814:void* memory_pool_alloc(memory_pool_t* pool) {
    3209*:  815:    if (MERCURY_UNLIKELY(!pool)) return NULL;
        -:  816:    
        -:  817:    // Lock-free atomic stack pop operation
        -:  818:    memory_block_t* head;
        -:  819:    memory_block_t* next;
        -:  820:    
        -:  821:    do {
        -:  822:        // Load current head with acquire ordering
    3215*:  823:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  824:        
        -:  825:        // Check if stack is empty
    3215*:  826:        if (MERCURY_UNLIKELY(head == NULL)) {
        -:  827:            return NULL;  // Pool exhausted
        -:  828:        }
        -:  829:        
        -:  830:        // Prefetch the head block for reading its fields
    3213*:  831:        MERCURY_PREFETCH_READ(head);
        -:  832:        
        -:  833:        // Get the next block in the stack  
    3213*:  834:        next = head->next;
        -:  835:        
        -:  836:        // Prefetch the next block in case CAS fails and we need to retry
    3213*:  837:        if (MERCURY_LIKELY(next != NULL)) {
    3209*:  838:            MERCURY_PREFETCH_READ_LOW(next);
        -:  839:        }
        -:  840:        
        -:  841:        // Try to update the head atomically (CAS operation)
        -:  842:        // This will fail if another thread modified the head
    3213*:  843:    } while (!atomic_compare_exchange_weak_explicit(
        -:  844:        &pool->free_stack, &head, next,
        -:  845:        memory_order_acq_rel, memory_order_acquire));
        -:  846:    
        -:  847:    // Successfully popped a block from the stack
    3207*:  848:    head->in_use = true;
    3207*:  849:    head->next = NULL;  // Clear the next pointer for safety
        -:  850:    
        -:  851:    // Prefetch the actual data block for the caller
    3207*:  852:    MERCURY_PREFETCH_WRITE(head->data);
        -:  853:    
        -:  854:    // Update statistics (relaxed ordering for performance)
    3207*:  855:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  856:    
    3207*:  857:    return head->data;
        -:  858:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 0 returned 0% blocks executed 0%
    #####:  814:void* memory_pool_alloc(memory_pool_t* pool) {
    #####:  815:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 never executed
branch  1 never executed
        -:  816:    
        -:  817:    // Lock-free atomic stack pop operation
        -:  818:    memory_block_t* head;
        -:  819:    memory_block_t* next;
        -:  820:    
        -:  821:    do {
        -:  822:        // Load current head with acquire ordering
    #####:  823:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  824:        
        -:  825:        // Check if stack is empty
    #####:  826:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 never executed
branch  1 never executed
        -:  827:            return NULL;  // Pool exhausted
        -:  828:        }
        -:  829:        
        -:  830:        // Prefetch the head block for reading its fields
    #####:  831:        MERCURY_PREFETCH_READ(head);
call    0 never executed
        -:  832:        
        -:  833:        // Get the next block in the stack  
    #####:  834:        next = head->next;
        -:  835:        
        -:  836:        // Prefetch the next block in case CAS fails and we need to retry
    #####:  837:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 never executed
branch  1 never executed
    #####:  838:            MERCURY_PREFETCH_READ_LOW(next);
call    0 never executed
        -:  839:        }
        -:  840:        
        -:  841:        // Try to update the head atomically (CAS operation)
        -:  842:        // This will fail if another thread modified the head
    #####:  843:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  844:        &pool->free_stack, &head, next,
        -:  845:        memory_order_acq_rel, memory_order_acquire));
        -:  846:    
        -:  847:    // Successfully popped a block from the stack
    #####:  848:    head->in_use = true;
    #####:  849:    head->next = NULL;  // Clear the next pointer for safety
        -:  850:    
        -:  851:    // Prefetch the actual data block for the caller
    #####:  852:    MERCURY_PREFETCH_WRITE(head->data);
call    0 never executed
        -:  853:    
        -:  854:    // Update statistics (relaxed ordering for performance)
    #####:  855:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  856:    
    #####:  857:    return head->data;
        -:  858:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 13 returned 100% blocks executed 100%
       13:  814:void* memory_pool_alloc(memory_pool_t* pool) {
       13:  815:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  816:    
        -:  817:    // Lock-free atomic stack pop operation
        -:  818:    memory_block_t* head;
        -:  819:    memory_block_t* next;
        -:  820:    
        -:  821:    do {
        -:  822:        // Load current head with acquire ordering
       13:  823:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  824:        
        -:  825:        // Check if stack is empty
       13:  826:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  827:            return NULL;  // Pool exhausted
        -:  828:        }
        -:  829:        
        -:  830:        // Prefetch the head block for reading its fields
       13:  831:        MERCURY_PREFETCH_READ(head);
call    0 returned 100%
        -:  832:        
        -:  833:        // Get the next block in the stack  
       13:  834:        next = head->next;
        -:  835:        
        -:  836:        // Prefetch the next block in case CAS fails and we need to retry
       13:  837:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       13:  838:            MERCURY_PREFETCH_READ_LOW(next);
call    0 returned 100%
        -:  839:        }
        -:  840:        
        -:  841:        // Try to update the head atomically (CAS operation)
        -:  842:        // This will fail if another thread modified the head
       13:  843:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  844:        &pool->free_stack, &head, next,
        -:  845:        memory_order_acq_rel, memory_order_acquire));
        -:  846:    
        -:  847:    // Successfully popped a block from the stack
       13:  848:    head->in_use = true;
       13:  849:    head->next = NULL;  // Clear the next pointer for safety
        -:  850:    
        -:  851:    // Prefetch the actual data block for the caller
       13:  852:    MERCURY_PREFETCH_WRITE(head->data);
call    0 returned 100%
        -:  853:    
        -:  854:    // Update statistics (relaxed ordering for performance)
       13:  855:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  856:    
       13:  857:    return head->data;
        -:  858:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 5 returned 100% blocks executed 100%
        5:  814:void* memory_pool_alloc(memory_pool_t* pool) {
        5:  815:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  816:    
        -:  817:    // Lock-free atomic stack pop operation
        -:  818:    memory_block_t* head;
        -:  819:    memory_block_t* next;
        -:  820:    
        -:  821:    do {
        -:  822:        // Load current head with acquire ordering
        5:  823:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  824:        
        -:  825:        // Check if stack is empty
        5:  826:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -:  827:            return NULL;  // Pool exhausted
        -:  828:        }
        -:  829:        
        -:  830:        // Prefetch the head block for reading its fields
        4:  831:        MERCURY_PREFETCH_READ(head);
call    0 returned 100%
        -:  832:        
        -:  833:        // Get the next block in the stack  
        4:  834:        next = head->next;
        -:  835:        
        -:  836:        // Prefetch the next block in case CAS fails and we need to retry
        4:  837:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        2:  838:            MERCURY_PREFETCH_READ_LOW(next);
call    0 returned 100%
        -:  839:        }
        -:  840:        
        -:  841:        // Try to update the head atomically (CAS operation)
        -:  842:        // This will fail if another thread modified the head
        4:  843:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  844:        &pool->free_stack, &head, next,
        -:  845:        memory_order_acq_rel, memory_order_acquire));
        -:  846:    
        -:  847:    // Successfully popped a block from the stack
        4:  848:    head->in_use = true;
        4:  849:    head->next = NULL;  // Clear the next pointer for safety
        -:  850:    
        -:  851:    // Prefetch the actual data block for the caller
        4:  852:    MERCURY_PREFETCH_WRITE(head->data);
call    0 returned 100%
        -:  853:    
        -:  854:    // Update statistics (relaxed ordering for performance)
        4:  855:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  856:    
        4:  857:    return head->data;
        -:  858:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 13 returned 100% blocks executed 100%
       13:  814:void* memory_pool_alloc(memory_pool_t* pool) {
       13:  815:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  816:    
        -:  817:    // Lock-free atomic stack pop operation
        -:  818:    memory_block_t* head;
        -:  819:    memory_block_t* next;
        -:  820:    
        -:  821:    do {
        -:  822:        // Load current head with acquire ordering
       13:  823:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  824:        
        -:  825:        // Check if stack is empty
       13:  826:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
        -:  827:            return NULL;  // Pool exhausted
        -:  828:        }
        -:  829:        
        -:  830:        // Prefetch the head block for reading its fields
       12:  831:        MERCURY_PREFETCH_READ(head);
call    0 returned 100%
        -:  832:        
        -:  833:        // Get the next block in the stack  
       12:  834:        next = head->next;
        -:  835:        
        -:  836:        // Prefetch the next block in case CAS fails and we need to retry
       12:  837:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
       10:  838:            MERCURY_PREFETCH_READ_LOW(next);
call    0 returned 100%
        -:  839:        }
        -:  840:        
        -:  841:        // Try to update the head atomically (CAS operation)
        -:  842:        // This will fail if another thread modified the head
       12:  843:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  844:        &pool->free_stack, &head, next,
        -:  845:        memory_order_acq_rel, memory_order_acquire));
        -:  846:    
        -:  847:    // Successfully popped a block from the stack
       12:  848:    head->in_use = true;
       12:  849:    head->next = NULL;  // Clear the next pointer for safety
        -:  850:    
        -:  851:    // Prefetch the actual data block for the caller
       12:  852:    MERCURY_PREFETCH_WRITE(head->data);
call    0 returned 100%
        -:  853:    
        -:  854:    // Update statistics (relaxed ordering for performance)
       12:  855:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  856:    
       12:  857:    return head->data;
        -:  858:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 0 returned 0% blocks executed 0%
    #####:  814:void* memory_pool_alloc(memory_pool_t* pool) {
    #####:  815:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 never executed
branch  1 never executed
        -:  816:    
        -:  817:    // Lock-free atomic stack pop operation
        -:  818:    memory_block_t* head;
        -:  819:    memory_block_t* next;
        -:  820:    
        -:  821:    do {
        -:  822:        // Load current head with acquire ordering
    #####:  823:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  824:        
        -:  825:        // Check if stack is empty
    #####:  826:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 never executed
branch  1 never executed
        -:  827:            return NULL;  // Pool exhausted
        -:  828:        }
        -:  829:        
        -:  830:        // Prefetch the head block for reading its fields
    #####:  831:        MERCURY_PREFETCH_READ(head);
call    0 never executed
        -:  832:        
        -:  833:        // Get the next block in the stack  
    #####:  834:        next = head->next;
        -:  835:        
        -:  836:        // Prefetch the next block in case CAS fails and we need to retry
    #####:  837:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 never executed
branch  1 never executed
    #####:  838:            MERCURY_PREFETCH_READ_LOW(next);
call    0 never executed
        -:  839:        }
        -:  840:        
        -:  841:        // Try to update the head atomically (CAS operation)
        -:  842:        // This will fail if another thread modified the head
    #####:  843:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  844:        &pool->free_stack, &head, next,
        -:  845:        memory_order_acq_rel, memory_order_acquire));
        -:  846:    
        -:  847:    // Successfully popped a block from the stack
    #####:  848:    head->in_use = true;
    #####:  849:    head->next = NULL;  // Clear the next pointer for safety
        -:  850:    
        -:  851:    // Prefetch the actual data block for the caller
    #####:  852:    MERCURY_PREFETCH_WRITE(head->data);
call    0 never executed
        -:  853:    
        -:  854:    // Update statistics (relaxed ordering for performance)
    #####:  855:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  856:    
    #####:  857:    return head->data;
        -:  858:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 0 returned 0% blocks executed 0%
    #####:  814:void* memory_pool_alloc(memory_pool_t* pool) {
    #####:  815:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 never executed
branch  1 never executed
        -:  816:    
        -:  817:    // Lock-free atomic stack pop operation
        -:  818:    memory_block_t* head;
        -:  819:    memory_block_t* next;
        -:  820:    
        -:  821:    do {
        -:  822:        // Load current head with acquire ordering
    #####:  823:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  824:        
        -:  825:        // Check if stack is empty
    #####:  826:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 never executed
branch  1 never executed
        -:  827:            return NULL;  // Pool exhausted
        -:  828:        }
        -:  829:        
        -:  830:        // Prefetch the head block for reading its fields
    #####:  831:        MERCURY_PREFETCH_READ(head);
call    0 never executed
        -:  832:        
        -:  833:        // Get the next block in the stack  
    #####:  834:        next = head->next;
        -:  835:        
        -:  836:        // Prefetch the next block in case CAS fails and we need to retry
    #####:  837:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 never executed
branch  1 never executed
    #####:  838:            MERCURY_PREFETCH_READ_LOW(next);
call    0 never executed
        -:  839:        }
        -:  840:        
        -:  841:        // Try to update the head atomically (CAS operation)
        -:  842:        // This will fail if another thread modified the head
    #####:  843:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  844:        &pool->free_stack, &head, next,
        -:  845:        memory_order_acq_rel, memory_order_acquire));
        -:  846:    
        -:  847:    // Successfully popped a block from the stack
    #####:  848:    head->in_use = true;
    #####:  849:    head->next = NULL;  // Clear the next pointer for safety
        -:  850:    
        -:  851:    // Prefetch the actual data block for the caller
    #####:  852:    MERCURY_PREFETCH_WRITE(head->data);
call    0 never executed
        -:  853:    
        -:  854:    // Update statistics (relaxed ordering for performance)
    #####:  855:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  856:    
    #####:  857:    return head->data;
        -:  858:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 0 returned 0% blocks executed 0%
    #####:  814:void* memory_pool_alloc(memory_pool_t* pool) {
    #####:  815:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 never executed
branch  1 never executed
        -:  816:    
        -:  817:    // Lock-free atomic stack pop operation
        -:  818:    memory_block_t* head;
        -:  819:    memory_block_t* next;
        -:  820:    
        -:  821:    do {
        -:  822:        // Load current head with acquire ordering
    #####:  823:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  824:        
        -:  825:        // Check if stack is empty
    #####:  826:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 never executed
branch  1 never executed
        -:  827:            return NULL;  // Pool exhausted
        -:  828:        }
        -:  829:        
        -:  830:        // Prefetch the head block for reading its fields
    #####:  831:        MERCURY_PREFETCH_READ(head);
call    0 never executed
        -:  832:        
        -:  833:        // Get the next block in the stack  
    #####:  834:        next = head->next;
        -:  835:        
        -:  836:        // Prefetch the next block in case CAS fails and we need to retry
    #####:  837:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 never executed
branch  1 never executed
    #####:  838:            MERCURY_PREFETCH_READ_LOW(next);
call    0 never executed
        -:  839:        }
        -:  840:        
        -:  841:        // Try to update the head atomically (CAS operation)
        -:  842:        // This will fail if another thread modified the head
    #####:  843:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  844:        &pool->free_stack, &head, next,
        -:  845:        memory_order_acq_rel, memory_order_acquire));
        -:  846:    
        -:  847:    // Successfully popped a block from the stack
    #####:  848:    head->in_use = true;
    #####:  849:    head->next = NULL;  // Clear the next pointer for safety
        -:  850:    
        -:  851:    // Prefetch the actual data block for the caller
    #####:  852:    MERCURY_PREFETCH_WRITE(head->data);
call    0 never executed
        -:  853:    
        -:  854:    // Update statistics (relaxed ordering for performance)
    #####:  855:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  856:    
    #####:  857:    return head->data;
        -:  858:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 0 returned 0% blocks executed 0%
    #####:  814:void* memory_pool_alloc(memory_pool_t* pool) {
    #####:  815:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 never executed
branch  1 never executed
        -:  816:    
        -:  817:    // Lock-free atomic stack pop operation
        -:  818:    memory_block_t* head;
        -:  819:    memory_block_t* next;
        -:  820:    
        -:  821:    do {
        -:  822:        // Load current head with acquire ordering
    #####:  823:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  824:        
        -:  825:        // Check if stack is empty
    #####:  826:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 never executed
branch  1 never executed
        -:  827:            return NULL;  // Pool exhausted
        -:  828:        }
        -:  829:        
        -:  830:        // Prefetch the head block for reading its fields
    #####:  831:        MERCURY_PREFETCH_READ(head);
call    0 never executed
        -:  832:        
        -:  833:        // Get the next block in the stack  
    #####:  834:        next = head->next;
        -:  835:        
        -:  836:        // Prefetch the next block in case CAS fails and we need to retry
    #####:  837:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 never executed
branch  1 never executed
    #####:  838:            MERCURY_PREFETCH_READ_LOW(next);
call    0 never executed
        -:  839:        }
        -:  840:        
        -:  841:        // Try to update the head atomically (CAS operation)
        -:  842:        // This will fail if another thread modified the head
    #####:  843:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  844:        &pool->free_stack, &head, next,
        -:  845:        memory_order_acq_rel, memory_order_acquire));
        -:  846:    
        -:  847:    // Successfully popped a block from the stack
    #####:  848:    head->in_use = true;
    #####:  849:    head->next = NULL;  // Clear the next pointer for safety
        -:  850:    
        -:  851:    // Prefetch the actual data block for the caller
    #####:  852:    MERCURY_PREFETCH_WRITE(head->data);
call    0 never executed
        -:  853:    
        -:  854:    // Update statistics (relaxed ordering for performance)
    #####:  855:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  856:    
    #####:  857:    return head->data;
        -:  858:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 0 returned 0% blocks executed 0%
    #####:  814:void* memory_pool_alloc(memory_pool_t* pool) {
    #####:  815:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 never executed
branch  1 never executed
        -:  816:    
        -:  817:    // Lock-free atomic stack pop operation
        -:  818:    memory_block_t* head;
        -:  819:    memory_block_t* next;
        -:  820:    
        -:  821:    do {
        -:  822:        // Load current head with acquire ordering
    #####:  823:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  824:        
        -:  825:        // Check if stack is empty
    #####:  826:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 never executed
branch  1 never executed
        -:  827:            return NULL;  // Pool exhausted
        -:  828:        }
        -:  829:        
        -:  830:        // Prefetch the head block for reading its fields
    #####:  831:        MERCURY_PREFETCH_READ(head);
call    0 never executed
        -:  832:        
        -:  833:        // Get the next block in the stack  
    #####:  834:        next = head->next;
        -:  835:        
        -:  836:        // Prefetch the next block in case CAS fails and we need to retry
    #####:  837:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 never executed
branch  1 never executed
    #####:  838:            MERCURY_PREFETCH_READ_LOW(next);
call    0 never executed
        -:  839:        }
        -:  840:        
        -:  841:        // Try to update the head atomically (CAS operation)
        -:  842:        // This will fail if another thread modified the head
    #####:  843:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  844:        &pool->free_stack, &head, next,
        -:  845:        memory_order_acq_rel, memory_order_acquire));
        -:  846:    
        -:  847:    // Successfully popped a block from the stack
    #####:  848:    head->in_use = true;
    #####:  849:    head->next = NULL;  // Clear the next pointer for safety
        -:  850:    
        -:  851:    // Prefetch the actual data block for the caller
    #####:  852:    MERCURY_PREFETCH_WRITE(head->data);
call    0 never executed
        -:  853:    
        -:  854:    // Update statistics (relaxed ordering for performance)
    #####:  855:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  856:    
    #####:  857:    return head->data;
        -:  858:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 73 returned 100% blocks executed 100%
       73:  814:void* memory_pool_alloc(memory_pool_t* pool) {
       73:  815:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  816:    
        -:  817:    // Lock-free atomic stack pop operation
        -:  818:    memory_block_t* head;
        -:  819:    memory_block_t* next;
        -:  820:    
        -:  821:    do {
        -:  822:        // Load current head with acquire ordering
       73:  823:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  824:        
        -:  825:        // Check if stack is empty
       73:  826:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  827:            return NULL;  // Pool exhausted
        -:  828:        }
        -:  829:        
        -:  830:        // Prefetch the head block for reading its fields
       73:  831:        MERCURY_PREFETCH_READ(head);
call    0 returned 100%
        -:  832:        
        -:  833:        // Get the next block in the stack  
       73:  834:        next = head->next;
        -:  835:        
        -:  836:        // Prefetch the next block in case CAS fails and we need to retry
       73:  837:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       73:  838:            MERCURY_PREFETCH_READ_LOW(next);
call    0 returned 100%
        -:  839:        }
        -:  840:        
        -:  841:        // Try to update the head atomically (CAS operation)
        -:  842:        // This will fail if another thread modified the head
       73:  843:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  844:        &pool->free_stack, &head, next,
        -:  845:        memory_order_acq_rel, memory_order_acquire));
        -:  846:    
        -:  847:    // Successfully popped a block from the stack
       73:  848:    head->in_use = true;
       73:  849:    head->next = NULL;  // Clear the next pointer for safety
        -:  850:    
        -:  851:    // Prefetch the actual data block for the caller
       73:  852:    MERCURY_PREFETCH_WRITE(head->data);
call    0 returned 100%
        -:  853:    
        -:  854:    // Update statistics (relaxed ordering for performance)
       73:  855:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  856:    
       73:  857:    return head->data;
        -:  858:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 3105 returned 100% blocks executed 100%
     3105:  814:void* memory_pool_alloc(memory_pool_t* pool) {
     3105:  815:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  816:    
        -:  817:    // Lock-free atomic stack pop operation
        -:  818:    memory_block_t* head;
        -:  819:    memory_block_t* next;
        -:  820:    
        -:  821:    do {
        -:  822:        // Load current head with acquire ordering
     3111:  823:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  824:        
        -:  825:        // Check if stack is empty
     3111:  826:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  827:            return NULL;  // Pool exhausted
        -:  828:        }
        -:  829:        
        -:  830:        // Prefetch the head block for reading its fields
     3111:  831:        MERCURY_PREFETCH_READ(head);
call    0 returned 100%
        -:  832:        
        -:  833:        // Get the next block in the stack  
     3111:  834:        next = head->next;
        -:  835:        
        -:  836:        // Prefetch the next block in case CAS fails and we need to retry
     3111:  837:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     3111:  838:            MERCURY_PREFETCH_READ_LOW(next);
call    0 returned 100%
        -:  839:        }
        -:  840:        
        -:  841:        // Try to update the head atomically (CAS operation)
        -:  842:        // This will fail if another thread modified the head
     3111:  843:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 1%
branch  2 taken 100% (fallthrough)
        -:  844:        &pool->free_stack, &head, next,
        -:  845:        memory_order_acq_rel, memory_order_acquire));
        -:  846:    
        -:  847:    // Successfully popped a block from the stack
     3105:  848:    head->in_use = true;
     3105:  849:    head->next = NULL;  // Clear the next pointer for safety
        -:  850:    
        -:  851:    // Prefetch the actual data block for the caller
     3105:  852:    MERCURY_PREFETCH_WRITE(head->data);
call    0 returned 100%
        -:  853:    
        -:  854:    // Update statistics (relaxed ordering for performance)
     3105:  855:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  856:    
     3105:  857:    return head->data;
        -:  858:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 0 returned 0% blocks executed 0%
    #####:  814:void* memory_pool_alloc(memory_pool_t* pool) {
    #####:  815:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 never executed
branch  1 never executed
        -:  816:    
        -:  817:    // Lock-free atomic stack pop operation
        -:  818:    memory_block_t* head;
        -:  819:    memory_block_t* next;
        -:  820:    
        -:  821:    do {
        -:  822:        // Load current head with acquire ordering
    #####:  823:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  824:        
        -:  825:        // Check if stack is empty
    #####:  826:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 never executed
branch  1 never executed
        -:  827:            return NULL;  // Pool exhausted
        -:  828:        }
        -:  829:        
        -:  830:        // Prefetch the head block for reading its fields
    #####:  831:        MERCURY_PREFETCH_READ(head);
call    0 never executed
        -:  832:        
        -:  833:        // Get the next block in the stack  
    #####:  834:        next = head->next;
        -:  835:        
        -:  836:        // Prefetch the next block in case CAS fails and we need to retry
    #####:  837:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 never executed
branch  1 never executed
    #####:  838:            MERCURY_PREFETCH_READ_LOW(next);
call    0 never executed
        -:  839:        }
        -:  840:        
        -:  841:        // Try to update the head atomically (CAS operation)
        -:  842:        // This will fail if another thread modified the head
    #####:  843:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  844:        &pool->free_stack, &head, next,
        -:  845:        memory_order_acq_rel, memory_order_acquire));
        -:  846:    
        -:  847:    // Successfully popped a block from the stack
    #####:  848:    head->in_use = true;
    #####:  849:    head->next = NULL;  // Clear the next pointer for safety
        -:  850:    
        -:  851:    // Prefetch the actual data block for the caller
    #####:  852:    MERCURY_PREFETCH_WRITE(head->data);
call    0 never executed
        -:  853:    
        -:  854:    // Update statistics (relaxed ordering for performance)
    #####:  855:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  856:    
    #####:  857:    return head->data;
        -:  858:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 0 returned 0% blocks executed 0%
    #####:  814:void* memory_pool_alloc(memory_pool_t* pool) {
    #####:  815:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 never executed
branch  1 never executed
        -:  816:    
        -:  817:    // Lock-free atomic stack pop operation
        -:  818:    memory_block_t* head;
        -:  819:    memory_block_t* next;
        -:  820:    
        -:  821:    do {
        -:  822:        // Load current head with acquire ordering
    #####:  823:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  824:        
        -:  825:        // Check if stack is empty
    #####:  826:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 never executed
branch  1 never executed
        -:  827:            return NULL;  // Pool exhausted
        -:  828:        }
        -:  829:        
        -:  830:        // Prefetch the head block for reading its fields
    #####:  831:        MERCURY_PREFETCH_READ(head);
call    0 never executed
        -:  832:        
        -:  833:        // Get the next block in the stack  
    #####:  834:        next = head->next;
        -:  835:        
        -:  836:        // Prefetch the next block in case CAS fails and we need to retry
    #####:  837:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 never executed
branch  1 never executed
    #####:  838:            MERCURY_PREFETCH_READ_LOW(next);
call    0 never executed
        -:  839:        }
        -:  840:        
        -:  841:        // Try to update the head atomically (CAS operation)
        -:  842:        // This will fail if another thread modified the head
    #####:  843:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  844:        &pool->free_stack, &head, next,
        -:  845:        memory_order_acq_rel, memory_order_acquire));
        -:  846:    
        -:  847:    // Successfully popped a block from the stack
    #####:  848:    head->in_use = true;
    #####:  849:    head->next = NULL;  // Clear the next pointer for safety
        -:  850:    
        -:  851:    // Prefetch the actual data block for the caller
    #####:  852:    MERCURY_PREFETCH_WRITE(head->data);
call    0 never executed
        -:  853:    
        -:  854:    // Update statistics (relaxed ordering for performance)
    #####:  855:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  856:    
    #####:  857:    return head->data;
        -:  858:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 0 returned 0% blocks executed 0%
    #####:  814:void* memory_pool_alloc(memory_pool_t* pool) {
    #####:  815:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 never executed
branch  1 never executed
        -:  816:    
        -:  817:    // Lock-free atomic stack pop operation
        -:  818:    memory_block_t* head;
        -:  819:    memory_block_t* next;
        -:  820:    
        -:  821:    do {
        -:  822:        // Load current head with acquire ordering
    #####:  823:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  824:        
        -:  825:        // Check if stack is empty
    #####:  826:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 never executed
branch  1 never executed
        -:  827:            return NULL;  // Pool exhausted
        -:  828:        }
        -:  829:        
        -:  830:        // Prefetch the head block for reading its fields
    #####:  831:        MERCURY_PREFETCH_READ(head);
call    0 never executed
        -:  832:        
        -:  833:        // Get the next block in the stack  
    #####:  834:        next = head->next;
        -:  835:        
        -:  836:        // Prefetch the next block in case CAS fails and we need to retry
    #####:  837:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 never executed
branch  1 never executed
    #####:  838:            MERCURY_PREFETCH_READ_LOW(next);
call    0 never executed
        -:  839:        }
        -:  840:        
        -:  841:        // Try to update the head atomically (CAS operation)
        -:  842:        // This will fail if another thread modified the head
    #####:  843:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  844:        &pool->free_stack, &head, next,
        -:  845:        memory_order_acq_rel, memory_order_acquire));
        -:  846:    
        -:  847:    // Successfully popped a block from the stack
    #####:  848:    head->in_use = true;
    #####:  849:    head->next = NULL;  // Clear the next pointer for safety
        -:  850:    
        -:  851:    // Prefetch the actual data block for the caller
    #####:  852:    MERCURY_PREFETCH_WRITE(head->data);
call    0 never executed
        -:  853:    
        -:  854:    // Update statistics (relaxed ordering for performance)
    #####:  855:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  856:    
    #####:  857:    return head->data;
        -:  858:}
------------------
        -:  859:
    3168*:  860:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    3168*:  861:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
        -:  862:    
        -:  863:    // Find the block that contains this pointer
        -:  864:    // Since we allocated all blocks contiguously, we can search through them
        -:  865:    memory_block_t* target_block = NULL;
 6344898*:  866:    for (size_t i = 0; i < pool->num_blocks; i++) {
 6344897*:  867:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
        -:  868:            target_block = &pool->all_blocks[i];
        -:  869:            break;
        -:  870:        }
        -:  871:    }
        -:  872:    
    3168*:  873:    if (MERCURY_UNLIKELY(!target_block)) {
        -:  874:        // Invalid pointer or already freed
        -:  875:        return;
        -:  876:    }
        -:  877:    
        -:  878:    // Mark as not in use
    3167*:  879:    target_block->in_use = false;
        -:  880:    
        -:  881:    // Lock-free atomic stack push operation
        -:  882:    memory_block_t* current_head;
        -:  883:    do {
        -:  884:        // Load current head with acquire ordering
    3167*:  885:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  886:        
        -:  887:        // Set this block's next to point to current head
    3167*:  888:        target_block->next = current_head;
        -:  889:        
        -:  890:        // Try to update the head atomically (CAS operation)
        -:  891:        // This will fail if another thread modified the head
    3167*:  892:    } while (!atomic_compare_exchange_weak_explicit(
        -:  893:        &pool->free_stack, &current_head, target_block,
        -:  894:        memory_order_acq_rel, memory_order_acquire));
        -:  895:    
        -:  896:    // Successfully pushed the block back onto the free stack
        -:  897:    // Update statistics (relaxed ordering for performance)
    3167*:  898:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  899:}
------------------
memory_pool_free:
function memory_pool_free called 0 returned 0% blocks executed 0%
    #####:  860:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    #####:  861:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 never executed
branch  1 never executed
        -:  862:    
        -:  863:    // Find the block that contains this pointer
        -:  864:    // Since we allocated all blocks contiguously, we can search through them
        -:  865:    memory_block_t* target_block = NULL;
    #####:  866:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  867:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  868:            target_block = &pool->all_blocks[i];
        -:  869:            break;
        -:  870:        }
        -:  871:    }
        -:  872:    
    #####:  873:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 never executed
branch  1 never executed
        -:  874:        // Invalid pointer or already freed
        -:  875:        return;
        -:  876:    }
        -:  877:    
        -:  878:    // Mark as not in use
    #####:  879:    target_block->in_use = false;
        -:  880:    
        -:  881:    // Lock-free atomic stack push operation
        -:  882:    memory_block_t* current_head;
        -:  883:    do {
        -:  884:        // Load current head with acquire ordering
    #####:  885:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  886:        
        -:  887:        // Set this block's next to point to current head
    #####:  888:        target_block->next = current_head;
        -:  889:        
        -:  890:        // Try to update the head atomically (CAS operation)
        -:  891:        // This will fail if another thread modified the head
    #####:  892:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  893:        &pool->free_stack, &current_head, target_block,
        -:  894:        memory_order_acq_rel, memory_order_acquire));
        -:  895:    
        -:  896:    // Successfully pushed the block back onto the free stack
        -:  897:    // Update statistics (relaxed ordering for performance)
    #####:  898:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  899:}
------------------
memory_pool_free:
function memory_pool_free called 13 returned 100% blocks executed 100%
       13:  860:void memory_pool_free(memory_pool_t* pool, void* ptr) {
       13:  861:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 taken 100%
branch  1 taken 0%
        -:  862:    
        -:  863:    // Find the block that contains this pointer
        -:  864:    // Since we allocated all blocks contiguously, we can search through them
        -:  865:    memory_block_t* target_block = NULL;
     1001:  866:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
     1001:  867:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  868:            target_block = &pool->all_blocks[i];
        -:  869:            break;
        -:  870:        }
        -:  871:    }
        -:  872:    
       13:  873:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  874:        // Invalid pointer or already freed
        -:  875:        return;
        -:  876:    }
        -:  877:    
        -:  878:    // Mark as not in use
       13:  879:    target_block->in_use = false;
        -:  880:    
        -:  881:    // Lock-free atomic stack push operation
        -:  882:    memory_block_t* current_head;
        -:  883:    do {
        -:  884:        // Load current head with acquire ordering
       13:  885:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  886:        
        -:  887:        // Set this block's next to point to current head
       13:  888:        target_block->next = current_head;
        -:  889:        
        -:  890:        // Try to update the head atomically (CAS operation)
        -:  891:        // This will fail if another thread modified the head
       13:  892:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  893:        &pool->free_stack, &current_head, target_block,
        -:  894:        memory_order_acq_rel, memory_order_acquire));
        -:  895:    
        -:  896:    // Successfully pushed the block back onto the free stack
        -:  897:    // Update statistics (relaxed ordering for performance)
       13:  898:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  899:}
------------------
memory_pool_free:
function memory_pool_free called 5 returned 100% blocks executed 100%
        5:  860:void memory_pool_free(memory_pool_t* pool, void* ptr) {
        5:  861:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 taken 100%
branch  1 taken 0%
        -:  862:    
        -:  863:    // Find the block that contains this pointer
        -:  864:    // Since we allocated all blocks contiguously, we can search through them
        -:  865:    memory_block_t* target_block = NULL;
       14:  866:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 93%
branch  1 taken 7% (fallthrough)
       13:  867:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
branch  2 taken 20% (fallthrough)
branch  3 taken 80%
        -:  868:            target_block = &pool->all_blocks[i];
        -:  869:            break;
        -:  870:        }
        -:  871:    }
        -:  872:    
        5:  873:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -:  874:        // Invalid pointer or already freed
        -:  875:        return;
        -:  876:    }
        -:  877:    
        -:  878:    // Mark as not in use
        4:  879:    target_block->in_use = false;
        -:  880:    
        -:  881:    // Lock-free atomic stack push operation
        -:  882:    memory_block_t* current_head;
        -:  883:    do {
        -:  884:        // Load current head with acquire ordering
        4:  885:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  886:        
        -:  887:        // Set this block's next to point to current head
        4:  888:        target_block->next = current_head;
        -:  889:        
        -:  890:        // Try to update the head atomically (CAS operation)
        -:  891:        // This will fail if another thread modified the head
        4:  892:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  893:        &pool->free_stack, &current_head, target_block,
        -:  894:        memory_order_acq_rel, memory_order_acquire));
        -:  895:    
        -:  896:    // Successfully pushed the block back onto the free stack
        -:  897:    // Update statistics (relaxed ordering for performance)
        4:  898:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  899:}
------------------
memory_pool_free:
function memory_pool_free called 12 returned 100% blocks executed 100%
       12:  860:void memory_pool_free(memory_pool_t* pool, void* ptr) {
       12:  861:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 taken 100%
branch  1 taken 0%
        -:  862:    
        -:  863:    // Find the block that contains this pointer
        -:  864:    // Since we allocated all blocks contiguously, we can search through them
        -:  865:    memory_block_t* target_block = NULL;
       65:  866:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
       65:  867:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  868:            target_block = &pool->all_blocks[i];
        -:  869:            break;
        -:  870:        }
        -:  871:    }
        -:  872:    
       12:  873:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  874:        // Invalid pointer or already freed
        -:  875:        return;
        -:  876:    }
        -:  877:    
        -:  878:    // Mark as not in use
       12:  879:    target_block->in_use = false;
        -:  880:    
        -:  881:    // Lock-free atomic stack push operation
        -:  882:    memory_block_t* current_head;
        -:  883:    do {
        -:  884:        // Load current head with acquire ordering
       12:  885:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  886:        
        -:  887:        // Set this block's next to point to current head
       12:  888:        target_block->next = current_head;
        -:  889:        
        -:  890:        // Try to update the head atomically (CAS operation)
        -:  891:        // This will fail if another thread modified the head
       12:  892:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  893:        &pool->free_stack, &current_head, target_block,
        -:  894:        memory_order_acq_rel, memory_order_acquire));
        -:  895:    
        -:  896:    // Successfully pushed the block back onto the free stack
        -:  897:    // Update statistics (relaxed ordering for performance)
       12:  898:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  899:}
------------------
memory_pool_free:
function memory_pool_free called 0 returned 0% blocks executed 0%
    #####:  860:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    #####:  861:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 never executed
branch  1 never executed
        -:  862:    
        -:  863:    // Find the block that contains this pointer
        -:  864:    // Since we allocated all blocks contiguously, we can search through them
        -:  865:    memory_block_t* target_block = NULL;
    #####:  866:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  867:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  868:            target_block = &pool->all_blocks[i];
        -:  869:            break;
        -:  870:        }
        -:  871:    }
        -:  872:    
    #####:  873:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 never executed
branch  1 never executed
        -:  874:        // Invalid pointer or already freed
        -:  875:        return;
        -:  876:    }
        -:  877:    
        -:  878:    // Mark as not in use
    #####:  879:    target_block->in_use = false;
        -:  880:    
        -:  881:    // Lock-free atomic stack push operation
        -:  882:    memory_block_t* current_head;
        -:  883:    do {
        -:  884:        // Load current head with acquire ordering
    #####:  885:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  886:        
        -:  887:        // Set this block's next to point to current head
    #####:  888:        target_block->next = current_head;
        -:  889:        
        -:  890:        // Try to update the head atomically (CAS operation)
        -:  891:        // This will fail if another thread modified the head
    #####:  892:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  893:        &pool->free_stack, &current_head, target_block,
        -:  894:        memory_order_acq_rel, memory_order_acquire));
        -:  895:    
        -:  896:    // Successfully pushed the block back onto the free stack
        -:  897:    // Update statistics (relaxed ordering for performance)
    #####:  898:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  899:}
------------------
memory_pool_free:
function memory_pool_free called 0 returned 0% blocks executed 0%
    #####:  860:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    #####:  861:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 never executed
branch  1 never executed
        -:  862:    
        -:  863:    // Find the block that contains this pointer
        -:  864:    // Since we allocated all blocks contiguously, we can search through them
        -:  865:    memory_block_t* target_block = NULL;
    #####:  866:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  867:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  868:            target_block = &pool->all_blocks[i];
        -:  869:            break;
        -:  870:        }
        -:  871:    }
        -:  872:    
    #####:  873:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 never executed
branch  1 never executed
        -:  874:        // Invalid pointer or already freed
        -:  875:        return;
        -:  876:    }
        -:  877:    
        -:  878:    // Mark as not in use
    #####:  879:    target_block->in_use = false;
        -:  880:    
        -:  881:    // Lock-free atomic stack push operation
        -:  882:    memory_block_t* current_head;
        -:  883:    do {
        -:  884:        // Load current head with acquire ordering
    #####:  885:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  886:        
        -:  887:        // Set this block's next to point to current head
    #####:  888:        target_block->next = current_head;
        -:  889:        
        -:  890:        // Try to update the head atomically (CAS operation)
        -:  891:        // This will fail if another thread modified the head
    #####:  892:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  893:        &pool->free_stack, &current_head, target_block,
        -:  894:        memory_order_acq_rel, memory_order_acquire));
        -:  895:    
        -:  896:    // Successfully pushed the block back onto the free stack
        -:  897:    // Update statistics (relaxed ordering for performance)
    #####:  898:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  899:}
------------------
memory_pool_free:
function memory_pool_free called 0 returned 0% blocks executed 0%
    #####:  860:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    #####:  861:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 never executed
branch  1 never executed
        -:  862:    
        -:  863:    // Find the block that contains this pointer
        -:  864:    // Since we allocated all blocks contiguously, we can search through them
        -:  865:    memory_block_t* target_block = NULL;
    #####:  866:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  867:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  868:            target_block = &pool->all_blocks[i];
        -:  869:            break;
        -:  870:        }
        -:  871:    }
        -:  872:    
    #####:  873:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 never executed
branch  1 never executed
        -:  874:        // Invalid pointer or already freed
        -:  875:        return;
        -:  876:    }
        -:  877:    
        -:  878:    // Mark as not in use
    #####:  879:    target_block->in_use = false;
        -:  880:    
        -:  881:    // Lock-free atomic stack push operation
        -:  882:    memory_block_t* current_head;
        -:  883:    do {
        -:  884:        // Load current head with acquire ordering
    #####:  885:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  886:        
        -:  887:        // Set this block's next to point to current head
    #####:  888:        target_block->next = current_head;
        -:  889:        
        -:  890:        // Try to update the head atomically (CAS operation)
        -:  891:        // This will fail if another thread modified the head
    #####:  892:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  893:        &pool->free_stack, &current_head, target_block,
        -:  894:        memory_order_acq_rel, memory_order_acquire));
        -:  895:    
        -:  896:    // Successfully pushed the block back onto the free stack
        -:  897:    // Update statistics (relaxed ordering for performance)
    #####:  898:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  899:}
------------------
memory_pool_free:
function memory_pool_free called 0 returned 0% blocks executed 0%
    #####:  860:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    #####:  861:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 never executed
branch  1 never executed
        -:  862:    
        -:  863:    // Find the block that contains this pointer
        -:  864:    // Since we allocated all blocks contiguously, we can search through them
        -:  865:    memory_block_t* target_block = NULL;
    #####:  866:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  867:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  868:            target_block = &pool->all_blocks[i];
        -:  869:            break;
        -:  870:        }
        -:  871:    }
        -:  872:    
    #####:  873:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 never executed
branch  1 never executed
        -:  874:        // Invalid pointer or already freed
        -:  875:        return;
        -:  876:    }
        -:  877:    
        -:  878:    // Mark as not in use
    #####:  879:    target_block->in_use = false;
        -:  880:    
        -:  881:    // Lock-free atomic stack push operation
        -:  882:    memory_block_t* current_head;
        -:  883:    do {
        -:  884:        // Load current head with acquire ordering
    #####:  885:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  886:        
        -:  887:        // Set this block's next to point to current head
    #####:  888:        target_block->next = current_head;
        -:  889:        
        -:  890:        // Try to update the head atomically (CAS operation)
        -:  891:        // This will fail if another thread modified the head
    #####:  892:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  893:        &pool->free_stack, &current_head, target_block,
        -:  894:        memory_order_acq_rel, memory_order_acquire));
        -:  895:    
        -:  896:    // Successfully pushed the block back onto the free stack
        -:  897:    // Update statistics (relaxed ordering for performance)
    #####:  898:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  899:}
------------------
memory_pool_free:
function memory_pool_free called 0 returned 0% blocks executed 0%
    #####:  860:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    #####:  861:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 never executed
branch  1 never executed
        -:  862:    
        -:  863:    // Find the block that contains this pointer
        -:  864:    // Since we allocated all blocks contiguously, we can search through them
        -:  865:    memory_block_t* target_block = NULL;
    #####:  866:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  867:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  868:            target_block = &pool->all_blocks[i];
        -:  869:            break;
        -:  870:        }
        -:  871:    }
        -:  872:    
    #####:  873:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 never executed
branch  1 never executed
        -:  874:        // Invalid pointer or already freed
        -:  875:        return;
        -:  876:    }
        -:  877:    
        -:  878:    // Mark as not in use
    #####:  879:    target_block->in_use = false;
        -:  880:    
        -:  881:    // Lock-free atomic stack push operation
        -:  882:    memory_block_t* current_head;
        -:  883:    do {
        -:  884:        // Load current head with acquire ordering
    #####:  885:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  886:        
        -:  887:        // Set this block's next to point to current head
    #####:  888:        target_block->next = current_head;
        -:  889:        
        -:  890:        // Try to update the head atomically (CAS operation)
        -:  891:        // This will fail if another thread modified the head
    #####:  892:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  893:        &pool->free_stack, &current_head, target_block,
        -:  894:        memory_order_acq_rel, memory_order_acquire));
        -:  895:    
        -:  896:    // Successfully pushed the block back onto the free stack
        -:  897:    // Update statistics (relaxed ordering for performance)
    #####:  898:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  899:}
------------------
memory_pool_free:
function memory_pool_free called 33 returned 100% blocks executed 100%
       33:  860:void memory_pool_free(memory_pool_t* pool, void* ptr) {
       33:  861:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 taken 100%
branch  1 taken 0%
        -:  862:    
        -:  863:    // Find the block that contains this pointer
        -:  864:    // Since we allocated all blocks contiguously, we can search through them
        -:  865:    memory_block_t* target_block = NULL;
    82217:  866:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
    82217:  867:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  868:            target_block = &pool->all_blocks[i];
        -:  869:            break;
        -:  870:        }
        -:  871:    }
        -:  872:    
       33:  873:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  874:        // Invalid pointer or already freed
        -:  875:        return;
        -:  876:    }
        -:  877:    
        -:  878:    // Mark as not in use
       33:  879:    target_block->in_use = false;
        -:  880:    
        -:  881:    // Lock-free atomic stack push operation
        -:  882:    memory_block_t* current_head;
        -:  883:    do {
        -:  884:        // Load current head with acquire ordering
       33:  885:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  886:        
        -:  887:        // Set this block's next to point to current head
       33:  888:        target_block->next = current_head;
        -:  889:        
        -:  890:        // Try to update the head atomically (CAS operation)
        -:  891:        // This will fail if another thread modified the head
       33:  892:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  893:        &pool->free_stack, &current_head, target_block,
        -:  894:        memory_order_acq_rel, memory_order_acquire));
        -:  895:    
        -:  896:    // Successfully pushed the block back onto the free stack
        -:  897:    // Update statistics (relaxed ordering for performance)
       33:  898:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  899:}
------------------
memory_pool_free:
function memory_pool_free called 3105 returned 100% blocks executed 100%
     3105:  860:void memory_pool_free(memory_pool_t* pool, void* ptr) {
     3105:  861:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 taken 100%
branch  1 taken 0%
        -:  862:    
        -:  863:    // Find the block that contains this pointer
        -:  864:    // Since we allocated all blocks contiguously, we can search through them
        -:  865:    memory_block_t* target_block = NULL;
  6261601:  866:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
  6261601:  867:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  868:            target_block = &pool->all_blocks[i];
        -:  869:            break;
        -:  870:        }
        -:  871:    }
        -:  872:    
     3105:  873:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  874:        // Invalid pointer or already freed
        -:  875:        return;
        -:  876:    }
        -:  877:    
        -:  878:    // Mark as not in use
     3105:  879:    target_block->in_use = false;
        -:  880:    
        -:  881:    // Lock-free atomic stack push operation
        -:  882:    memory_block_t* current_head;
        -:  883:    do {
        -:  884:        // Load current head with acquire ordering
     3105:  885:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  886:        
        -:  887:        // Set this block's next to point to current head
     3105:  888:        target_block->next = current_head;
        -:  889:        
        -:  890:        // Try to update the head atomically (CAS operation)
        -:  891:        // This will fail if another thread modified the head
     3105:  892:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  893:        &pool->free_stack, &current_head, target_block,
        -:  894:        memory_order_acq_rel, memory_order_acquire));
        -:  895:    
        -:  896:    // Successfully pushed the block back onto the free stack
        -:  897:    // Update statistics (relaxed ordering for performance)
     3105:  898:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  899:}
------------------
memory_pool_free:
function memory_pool_free called 0 returned 0% blocks executed 0%
    #####:  860:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    #####:  861:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 never executed
branch  1 never executed
        -:  862:    
        -:  863:    // Find the block that contains this pointer
        -:  864:    // Since we allocated all blocks contiguously, we can search through them
        -:  865:    memory_block_t* target_block = NULL;
    #####:  866:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  867:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  868:            target_block = &pool->all_blocks[i];
        -:  869:            break;
        -:  870:        }
        -:  871:    }
        -:  872:    
    #####:  873:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 never executed
branch  1 never executed
        -:  874:        // Invalid pointer or already freed
        -:  875:        return;
        -:  876:    }
        -:  877:    
        -:  878:    // Mark as not in use
    #####:  879:    target_block->in_use = false;
        -:  880:    
        -:  881:    // Lock-free atomic stack push operation
        -:  882:    memory_block_t* current_head;
        -:  883:    do {
        -:  884:        // Load current head with acquire ordering
    #####:  885:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  886:        
        -:  887:        // Set this block's next to point to current head
    #####:  888:        target_block->next = current_head;
        -:  889:        
        -:  890:        // Try to update the head atomically (CAS operation)
        -:  891:        // This will fail if another thread modified the head
    #####:  892:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  893:        &pool->free_stack, &current_head, target_block,
        -:  894:        memory_order_acq_rel, memory_order_acquire));
        -:  895:    
        -:  896:    // Successfully pushed the block back onto the free stack
        -:  897:    // Update statistics (relaxed ordering for performance)
    #####:  898:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  899:}
------------------
memory_pool_free:
function memory_pool_free called 0 returned 0% blocks executed 0%
    #####:  860:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    #####:  861:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 never executed
branch  1 never executed
        -:  862:    
        -:  863:    // Find the block that contains this pointer
        -:  864:    // Since we allocated all blocks contiguously, we can search through them
        -:  865:    memory_block_t* target_block = NULL;
    #####:  866:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  867:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  868:            target_block = &pool->all_blocks[i];
        -:  869:            break;
        -:  870:        }
        -:  871:    }
        -:  872:    
    #####:  873:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 never executed
branch  1 never executed
        -:  874:        // Invalid pointer or already freed
        -:  875:        return;
        -:  876:    }
        -:  877:    
        -:  878:    // Mark as not in use
    #####:  879:    target_block->in_use = false;
        -:  880:    
        -:  881:    // Lock-free atomic stack push operation
        -:  882:    memory_block_t* current_head;
        -:  883:    do {
        -:  884:        // Load current head with acquire ordering
    #####:  885:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  886:        
        -:  887:        // Set this block's next to point to current head
    #####:  888:        target_block->next = current_head;
        -:  889:        
        -:  890:        // Try to update the head atomically (CAS operation)
        -:  891:        // This will fail if another thread modified the head
    #####:  892:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  893:        &pool->free_stack, &current_head, target_block,
        -:  894:        memory_order_acq_rel, memory_order_acquire));
        -:  895:    
        -:  896:    // Successfully pushed the block back onto the free stack
        -:  897:    // Update statistics (relaxed ordering for performance)
    #####:  898:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  899:}
------------------
memory_pool_free:
function memory_pool_free called 0 returned 0% blocks executed 0%
    #####:  860:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    #####:  861:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 never executed
branch  1 never executed
        -:  862:    
        -:  863:    // Find the block that contains this pointer
        -:  864:    // Since we allocated all blocks contiguously, we can search through them
        -:  865:    memory_block_t* target_block = NULL;
    #####:  866:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  867:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  868:            target_block = &pool->all_blocks[i];
        -:  869:            break;
        -:  870:        }
        -:  871:    }
        -:  872:    
    #####:  873:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 never executed
branch  1 never executed
        -:  874:        // Invalid pointer or already freed
        -:  875:        return;
        -:  876:    }
        -:  877:    
        -:  878:    // Mark as not in use
    #####:  879:    target_block->in_use = false;
        -:  880:    
        -:  881:    // Lock-free atomic stack push operation
        -:  882:    memory_block_t* current_head;
        -:  883:    do {
        -:  884:        // Load current head with acquire ordering
    #####:  885:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -:  886:        
        -:  887:        // Set this block's next to point to current head
    #####:  888:        target_block->next = current_head;
        -:  889:        
        -:  890:        // Try to update the head atomically (CAS operation)
        -:  891:        // This will fail if another thread modified the head
    #####:  892:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  893:        &pool->free_stack, &current_head, target_block,
        -:  894:        memory_order_acq_rel, memory_order_acquire));
        -:  895:    
        -:  896:    // Successfully pushed the block back onto the free stack
        -:  897:    // Update statistics (relaxed ordering for performance)
    #####:  898:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -:  899:}
------------------
        -:  900:
       8*:  901:void memory_pool_destroy(memory_pool_t* pool) {
       8*:  902:    if (!pool || !pool->all_blocks) return;
        -:  903:    
        -:  904:    // Free all allocated block data
    5145*:  905:    for (size_t i = 0; i < pool->num_blocks; i++) {
    5137*:  906:        if (pool->all_blocks[i].data) {
    5137*:  907:            mercury_aligned_free(pool->all_blocks[i].data);
    5137*:  908:            pool->all_blocks[i].data = NULL;
        -:  909:        }
        -:  910:    }
        -:  911:    
        -:  912:    // Free the block array
       8*:  913:    mercury_aligned_free(pool->all_blocks);
       8*:  914:    pool->all_blocks = NULL;
        -:  915:    
        -:  916:    // Reset atomic variables
       8*:  917:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
       8*:  918:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  919:    
       8*:  920:    pool->block_size = 0;
       8*:  921:    pool->num_blocks = 0;
        -:  922:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 0 returned 0% blocks executed 0%
    #####:  901:void memory_pool_destroy(memory_pool_t* pool) {
    #####:  902:    if (!pool || !pool->all_blocks) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  903:    
        -:  904:    // Free all allocated block data
    #####:  905:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  906:        if (pool->all_blocks[i].data) {
branch  0 never executed
branch  1 never executed
    #####:  907:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 never executed
    #####:  908:            pool->all_blocks[i].data = NULL;
        -:  909:        }
        -:  910:    }
        -:  911:    
        -:  912:    // Free the block array
    #####:  913:    mercury_aligned_free(pool->all_blocks);
call    0 never executed
    #####:  914:    pool->all_blocks = NULL;
        -:  915:    
        -:  916:    // Reset atomic variables
    #####:  917:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  918:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  919:    
    #####:  920:    pool->block_size = 0;
    #####:  921:    pool->num_blocks = 0;
        -:  922:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 2 returned 100% blocks executed 100%
        2:  901:void memory_pool_destroy(memory_pool_t* pool) {
        2:  902:    if (!pool || !pool->all_blocks) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -:  903:    
        -:  904:    // Free all allocated block data
      118:  905:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
      116:  906:        if (pool->all_blocks[i].data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      116:  907:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 returned 100%
      116:  908:            pool->all_blocks[i].data = NULL;
        -:  909:        }
        -:  910:    }
        -:  911:    
        -:  912:    // Free the block array
        2:  913:    mercury_aligned_free(pool->all_blocks);
call    0 returned 100%
        2:  914:    pool->all_blocks = NULL;
        -:  915:    
        -:  916:    // Reset atomic variables
        2:  917:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        2:  918:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  919:    
        2:  920:    pool->block_size = 0;
        2:  921:    pool->num_blocks = 0;
        -:  922:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 2 returned 100% blocks executed 100%
        2:  901:void memory_pool_destroy(memory_pool_t* pool) {
        2:  902:    if (!pool || !pool->all_blocks) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -:  903:    
        -:  904:    // Free all allocated block data
        8:  905:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        6:  906:        if (pool->all_blocks[i].data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6:  907:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 returned 100%
        6:  908:            pool->all_blocks[i].data = NULL;
        -:  909:        }
        -:  910:    }
        -:  911:    
        -:  912:    // Free the block array
        2:  913:    mercury_aligned_free(pool->all_blocks);
call    0 returned 100%
        2:  914:    pool->all_blocks = NULL;
        -:  915:    
        -:  916:    // Reset atomic variables
        2:  917:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        2:  918:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  919:    
        2:  920:    pool->block_size = 0;
        2:  921:    pool->num_blocks = 0;
        -:  922:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 2 returned 100% blocks executed 100%
        2:  901:void memory_pool_destroy(memory_pool_t* pool) {
        2:  902:    if (!pool || !pool->all_blocks) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -:  903:    
        -:  904:    // Free all allocated block data
       17:  905:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
       15:  906:        if (pool->all_blocks[i].data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       15:  907:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 returned 100%
       15:  908:            pool->all_blocks[i].data = NULL;
        -:  909:        }
        -:  910:    }
        -:  911:    
        -:  912:    // Free the block array
        2:  913:    mercury_aligned_free(pool->all_blocks);
call    0 returned 100%
        2:  914:    pool->all_blocks = NULL;
        -:  915:    
        -:  916:    // Reset atomic variables
        2:  917:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        2:  918:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  919:    
        2:  920:    pool->block_size = 0;
        2:  921:    pool->num_blocks = 0;
        -:  922:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 0 returned 0% blocks executed 0%
    #####:  901:void memory_pool_destroy(memory_pool_t* pool) {
    #####:  902:    if (!pool || !pool->all_blocks) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  903:    
        -:  904:    // Free all allocated block data
    #####:  905:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  906:        if (pool->all_blocks[i].data) {
branch  0 never executed
branch  1 never executed
    #####:  907:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 never executed
    #####:  908:            pool->all_blocks[i].data = NULL;
        -:  909:        }
        -:  910:    }
        -:  911:    
        -:  912:    // Free the block array
    #####:  913:    mercury_aligned_free(pool->all_blocks);
call    0 never executed
    #####:  914:    pool->all_blocks = NULL;
        -:  915:    
        -:  916:    // Reset atomic variables
    #####:  917:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  918:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  919:    
    #####:  920:    pool->block_size = 0;
    #####:  921:    pool->num_blocks = 0;
        -:  922:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 0 returned 0% blocks executed 0%
    #####:  901:void memory_pool_destroy(memory_pool_t* pool) {
    #####:  902:    if (!pool || !pool->all_blocks) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  903:    
        -:  904:    // Free all allocated block data
    #####:  905:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  906:        if (pool->all_blocks[i].data) {
branch  0 never executed
branch  1 never executed
    #####:  907:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 never executed
    #####:  908:            pool->all_blocks[i].data = NULL;
        -:  909:        }
        -:  910:    }
        -:  911:    
        -:  912:    // Free the block array
    #####:  913:    mercury_aligned_free(pool->all_blocks);
call    0 never executed
    #####:  914:    pool->all_blocks = NULL;
        -:  915:    
        -:  916:    // Reset atomic variables
    #####:  917:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  918:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  919:    
    #####:  920:    pool->block_size = 0;
    #####:  921:    pool->num_blocks = 0;
        -:  922:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 0 returned 0% blocks executed 0%
    #####:  901:void memory_pool_destroy(memory_pool_t* pool) {
    #####:  902:    if (!pool || !pool->all_blocks) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  903:    
        -:  904:    // Free all allocated block data
    #####:  905:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  906:        if (pool->all_blocks[i].data) {
branch  0 never executed
branch  1 never executed
    #####:  907:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 never executed
    #####:  908:            pool->all_blocks[i].data = NULL;
        -:  909:        }
        -:  910:    }
        -:  911:    
        -:  912:    // Free the block array
    #####:  913:    mercury_aligned_free(pool->all_blocks);
call    0 never executed
    #####:  914:    pool->all_blocks = NULL;
        -:  915:    
        -:  916:    // Reset atomic variables
    #####:  917:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  918:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  919:    
    #####:  920:    pool->block_size = 0;
    #####:  921:    pool->num_blocks = 0;
        -:  922:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 0 returned 0% blocks executed 0%
    #####:  901:void memory_pool_destroy(memory_pool_t* pool) {
    #####:  902:    if (!pool || !pool->all_blocks) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  903:    
        -:  904:    // Free all allocated block data
    #####:  905:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  906:        if (pool->all_blocks[i].data) {
branch  0 never executed
branch  1 never executed
    #####:  907:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 never executed
    #####:  908:            pool->all_blocks[i].data = NULL;
        -:  909:        }
        -:  910:    }
        -:  911:    
        -:  912:    // Free the block array
    #####:  913:    mercury_aligned_free(pool->all_blocks);
call    0 never executed
    #####:  914:    pool->all_blocks = NULL;
        -:  915:    
        -:  916:    // Reset atomic variables
    #####:  917:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  918:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  919:    
    #####:  920:    pool->block_size = 0;
    #####:  921:    pool->num_blocks = 0;
        -:  922:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 0 returned 0% blocks executed 0%
    #####:  901:void memory_pool_destroy(memory_pool_t* pool) {
    #####:  902:    if (!pool || !pool->all_blocks) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  903:    
        -:  904:    // Free all allocated block data
    #####:  905:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  906:        if (pool->all_blocks[i].data) {
branch  0 never executed
branch  1 never executed
    #####:  907:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 never executed
    #####:  908:            pool->all_blocks[i].data = NULL;
        -:  909:        }
        -:  910:    }
        -:  911:    
        -:  912:    // Free the block array
    #####:  913:    mercury_aligned_free(pool->all_blocks);
call    0 never executed
    #####:  914:    pool->all_blocks = NULL;
        -:  915:    
        -:  916:    // Reset atomic variables
    #####:  917:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  918:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  919:    
    #####:  920:    pool->block_size = 0;
    #####:  921:    pool->num_blocks = 0;
        -:  922:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 1 returned 100% blocks executed 100%
        1:  901:void memory_pool_destroy(memory_pool_t* pool) {
        1:  902:    if (!pool || !pool->all_blocks) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -:  903:    
        -:  904:    // Free all allocated block data
     2501:  905:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     2500:  906:        if (pool->all_blocks[i].data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2500:  907:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 returned 100%
     2500:  908:            pool->all_blocks[i].data = NULL;
        -:  909:        }
        -:  910:    }
        -:  911:    
        -:  912:    // Free the block array
        1:  913:    mercury_aligned_free(pool->all_blocks);
call    0 returned 100%
        1:  914:    pool->all_blocks = NULL;
        -:  915:    
        -:  916:    // Reset atomic variables
        1:  917:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        1:  918:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  919:    
        1:  920:    pool->block_size = 0;
        1:  921:    pool->num_blocks = 0;
        -:  922:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 1 returned 100% blocks executed 100%
        1:  901:void memory_pool_destroy(memory_pool_t* pool) {
        1:  902:    if (!pool || !pool->all_blocks) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -:  903:    
        -:  904:    // Free all allocated block data
     2501:  905:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     2500:  906:        if (pool->all_blocks[i].data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2500:  907:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 returned 100%
     2500:  908:            pool->all_blocks[i].data = NULL;
        -:  909:        }
        -:  910:    }
        -:  911:    
        -:  912:    // Free the block array
        1:  913:    mercury_aligned_free(pool->all_blocks);
call    0 returned 100%
        1:  914:    pool->all_blocks = NULL;
        -:  915:    
        -:  916:    // Reset atomic variables
        1:  917:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        1:  918:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  919:    
        1:  920:    pool->block_size = 0;
        1:  921:    pool->num_blocks = 0;
        -:  922:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 0 returned 0% blocks executed 0%
    #####:  901:void memory_pool_destroy(memory_pool_t* pool) {
    #####:  902:    if (!pool || !pool->all_blocks) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  903:    
        -:  904:    // Free all allocated block data
    #####:  905:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  906:        if (pool->all_blocks[i].data) {
branch  0 never executed
branch  1 never executed
    #####:  907:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 never executed
    #####:  908:            pool->all_blocks[i].data = NULL;
        -:  909:        }
        -:  910:    }
        -:  911:    
        -:  912:    // Free the block array
    #####:  913:    mercury_aligned_free(pool->all_blocks);
call    0 never executed
    #####:  914:    pool->all_blocks = NULL;
        -:  915:    
        -:  916:    // Reset atomic variables
    #####:  917:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  918:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  919:    
    #####:  920:    pool->block_size = 0;
    #####:  921:    pool->num_blocks = 0;
        -:  922:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 0 returned 0% blocks executed 0%
    #####:  901:void memory_pool_destroy(memory_pool_t* pool) {
    #####:  902:    if (!pool || !pool->all_blocks) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  903:    
        -:  904:    // Free all allocated block data
    #####:  905:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  906:        if (pool->all_blocks[i].data) {
branch  0 never executed
branch  1 never executed
    #####:  907:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 never executed
    #####:  908:            pool->all_blocks[i].data = NULL;
        -:  909:        }
        -:  910:    }
        -:  911:    
        -:  912:    // Free the block array
    #####:  913:    mercury_aligned_free(pool->all_blocks);
call    0 never executed
    #####:  914:    pool->all_blocks = NULL;
        -:  915:    
        -:  916:    // Reset atomic variables
    #####:  917:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  918:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  919:    
    #####:  920:    pool->block_size = 0;
    #####:  921:    pool->num_blocks = 0;
        -:  922:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 0 returned 0% blocks executed 0%
    #####:  901:void memory_pool_destroy(memory_pool_t* pool) {
    #####:  902:    if (!pool || !pool->all_blocks) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  903:    
        -:  904:    // Free all allocated block data
    #####:  905:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  906:        if (pool->all_blocks[i].data) {
branch  0 never executed
branch  1 never executed
    #####:  907:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 never executed
    #####:  908:            pool->all_blocks[i].data = NULL;
        -:  909:        }
        -:  910:    }
        -:  911:    
        -:  912:    // Free the block array
    #####:  913:    mercury_aligned_free(pool->all_blocks);
call    0 never executed
    #####:  914:    pool->all_blocks = NULL;
        -:  915:    
        -:  916:    // Reset atomic variables
    #####:  917:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  918:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  919:    
    #####:  920:    pool->block_size = 0;
    #####:  921:    pool->num_blocks = 0;
        -:  922:}
------------------
        -:  923:
        -:  924:// === ERROR CHAIN IMPLEMENTATION ===
        -:  925:
        -:  926:// Error chain types now in common.h
        -:  927:
    #####:  928:void error_chain_init(error_chain_t* chain) {
    #####:  929:    if (!chain) return;
        -:  930:    
    #####:  931:    chain->head = NULL;
    #####:  932:    chain->count = 0;
        -:  933:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####:  928:void error_chain_init(error_chain_t* chain) {
    #####:  929:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  930:    
    #####:  931:    chain->head = NULL;
    #####:  932:    chain->count = 0;
        -:  933:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####:  928:void error_chain_init(error_chain_t* chain) {
    #####:  929:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  930:    
    #####:  931:    chain->head = NULL;
    #####:  932:    chain->count = 0;
        -:  933:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####:  928:void error_chain_init(error_chain_t* chain) {
    #####:  929:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  930:    
    #####:  931:    chain->head = NULL;
    #####:  932:    chain->count = 0;
        -:  933:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####:  928:void error_chain_init(error_chain_t* chain) {
    #####:  929:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  930:    
    #####:  931:    chain->head = NULL;
    #####:  932:    chain->count = 0;
        -:  933:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####:  928:void error_chain_init(error_chain_t* chain) {
    #####:  929:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  930:    
    #####:  931:    chain->head = NULL;
    #####:  932:    chain->count = 0;
        -:  933:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####:  928:void error_chain_init(error_chain_t* chain) {
    #####:  929:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  930:    
    #####:  931:    chain->head = NULL;
    #####:  932:    chain->count = 0;
        -:  933:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####:  928:void error_chain_init(error_chain_t* chain) {
    #####:  929:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  930:    
    #####:  931:    chain->head = NULL;
    #####:  932:    chain->count = 0;
        -:  933:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####:  928:void error_chain_init(error_chain_t* chain) {
    #####:  929:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  930:    
    #####:  931:    chain->head = NULL;
    #####:  932:    chain->count = 0;
        -:  933:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####:  928:void error_chain_init(error_chain_t* chain) {
    #####:  929:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  930:    
    #####:  931:    chain->head = NULL;
    #####:  932:    chain->count = 0;
        -:  933:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####:  928:void error_chain_init(error_chain_t* chain) {
    #####:  929:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  930:    
    #####:  931:    chain->head = NULL;
    #####:  932:    chain->count = 0;
        -:  933:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####:  928:void error_chain_init(error_chain_t* chain) {
    #####:  929:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  930:    
    #####:  931:    chain->head = NULL;
    #####:  932:    chain->count = 0;
        -:  933:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####:  928:void error_chain_init(error_chain_t* chain) {
    #####:  929:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  930:    
    #####:  931:    chain->head = NULL;
    #####:  932:    chain->count = 0;
        -:  933:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####:  928:void error_chain_init(error_chain_t* chain) {
    #####:  929:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  930:    
    #####:  931:    chain->head = NULL;
    #####:  932:    chain->count = 0;
        -:  933:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####:  928:void error_chain_init(error_chain_t* chain) {
    #####:  929:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  930:    
    #####:  931:    chain->head = NULL;
    #####:  932:    chain->count = 0;
        -:  933:}
------------------
        -:  934:
    #####:  935:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####:  936:    if (!chain || !format) return;
        -:  937:    
    #####:  938:    error_node_t* node = malloc(sizeof(error_node_t));
    #####:  939:    if (!node) return;
        -:  940:    
    #####:  941:    node->code = code;
        -:  942:    
        -:  943:    va_list args;
    #####:  944:    va_start(args, format);
    #####:  945:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####:  946:    va_end(args);
        -:  947:    
        -:  948:    // Add to head (LIFO)
    #####:  949:    node->next = chain->head;
    #####:  950:    chain->head = node;
    #####:  951:    chain->count++;
        -:  952:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####:  935:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####:  936:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -:  937:    
    #####:  938:    error_node_t* node = malloc(sizeof(error_node_t));
    #####:  939:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -:  940:    
    #####:  941:    node->code = code;
        -:  942:    
        -:  943:    va_list args;
    #####:  944:    va_start(args, format);
    #####:  945:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####:  946:    va_end(args);
        -:  947:    
        -:  948:    // Add to head (LIFO)
    #####:  949:    node->next = chain->head;
    #####:  950:    chain->head = node;
    #####:  951:    chain->count++;
        -:  952:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####:  935:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####:  936:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -:  937:    
    #####:  938:    error_node_t* node = malloc(sizeof(error_node_t));
    #####:  939:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -:  940:    
    #####:  941:    node->code = code;
        -:  942:    
        -:  943:    va_list args;
    #####:  944:    va_start(args, format);
    #####:  945:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####:  946:    va_end(args);
        -:  947:    
        -:  948:    // Add to head (LIFO)
    #####:  949:    node->next = chain->head;
    #####:  950:    chain->head = node;
    #####:  951:    chain->count++;
        -:  952:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####:  935:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####:  936:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -:  937:    
    #####:  938:    error_node_t* node = malloc(sizeof(error_node_t));
    #####:  939:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -:  940:    
    #####:  941:    node->code = code;
        -:  942:    
        -:  943:    va_list args;
    #####:  944:    va_start(args, format);
    #####:  945:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####:  946:    va_end(args);
        -:  947:    
        -:  948:    // Add to head (LIFO)
    #####:  949:    node->next = chain->head;
    #####:  950:    chain->head = node;
    #####:  951:    chain->count++;
        -:  952:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####:  935:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####:  936:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -:  937:    
    #####:  938:    error_node_t* node = malloc(sizeof(error_node_t));
    #####:  939:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -:  940:    
    #####:  941:    node->code = code;
        -:  942:    
        -:  943:    va_list args;
    #####:  944:    va_start(args, format);
    #####:  945:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####:  946:    va_end(args);
        -:  947:    
        -:  948:    // Add to head (LIFO)
    #####:  949:    node->next = chain->head;
    #####:  950:    chain->head = node;
    #####:  951:    chain->count++;
        -:  952:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####:  935:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####:  936:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -:  937:    
    #####:  938:    error_node_t* node = malloc(sizeof(error_node_t));
    #####:  939:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -:  940:    
    #####:  941:    node->code = code;
        -:  942:    
        -:  943:    va_list args;
    #####:  944:    va_start(args, format);
    #####:  945:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####:  946:    va_end(args);
        -:  947:    
        -:  948:    // Add to head (LIFO)
    #####:  949:    node->next = chain->head;
    #####:  950:    chain->head = node;
    #####:  951:    chain->count++;
        -:  952:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####:  935:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####:  936:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -:  937:    
    #####:  938:    error_node_t* node = malloc(sizeof(error_node_t));
    #####:  939:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -:  940:    
    #####:  941:    node->code = code;
        -:  942:    
        -:  943:    va_list args;
    #####:  944:    va_start(args, format);
    #####:  945:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####:  946:    va_end(args);
        -:  947:    
        -:  948:    // Add to head (LIFO)
    #####:  949:    node->next = chain->head;
    #####:  950:    chain->head = node;
    #####:  951:    chain->count++;
        -:  952:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####:  935:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####:  936:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -:  937:    
    #####:  938:    error_node_t* node = malloc(sizeof(error_node_t));
    #####:  939:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -:  940:    
    #####:  941:    node->code = code;
        -:  942:    
        -:  943:    va_list args;
    #####:  944:    va_start(args, format);
    #####:  945:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####:  946:    va_end(args);
        -:  947:    
        -:  948:    // Add to head (LIFO)
    #####:  949:    node->next = chain->head;
    #####:  950:    chain->head = node;
    #####:  951:    chain->count++;
        -:  952:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####:  935:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####:  936:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -:  937:    
    #####:  938:    error_node_t* node = malloc(sizeof(error_node_t));
    #####:  939:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -:  940:    
    #####:  941:    node->code = code;
        -:  942:    
        -:  943:    va_list args;
    #####:  944:    va_start(args, format);
    #####:  945:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####:  946:    va_end(args);
        -:  947:    
        -:  948:    // Add to head (LIFO)
    #####:  949:    node->next = chain->head;
    #####:  950:    chain->head = node;
    #####:  951:    chain->count++;
        -:  952:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####:  935:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####:  936:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -:  937:    
    #####:  938:    error_node_t* node = malloc(sizeof(error_node_t));
    #####:  939:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -:  940:    
    #####:  941:    node->code = code;
        -:  942:    
        -:  943:    va_list args;
    #####:  944:    va_start(args, format);
    #####:  945:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####:  946:    va_end(args);
        -:  947:    
        -:  948:    // Add to head (LIFO)
    #####:  949:    node->next = chain->head;
    #####:  950:    chain->head = node;
    #####:  951:    chain->count++;
        -:  952:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####:  935:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####:  936:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -:  937:    
    #####:  938:    error_node_t* node = malloc(sizeof(error_node_t));
    #####:  939:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -:  940:    
    #####:  941:    node->code = code;
        -:  942:    
        -:  943:    va_list args;
    #####:  944:    va_start(args, format);
    #####:  945:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####:  946:    va_end(args);
        -:  947:    
        -:  948:    // Add to head (LIFO)
    #####:  949:    node->next = chain->head;
    #####:  950:    chain->head = node;
    #####:  951:    chain->count++;
        -:  952:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####:  935:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####:  936:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -:  937:    
    #####:  938:    error_node_t* node = malloc(sizeof(error_node_t));
    #####:  939:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -:  940:    
    #####:  941:    node->code = code;
        -:  942:    
        -:  943:    va_list args;
    #####:  944:    va_start(args, format);
    #####:  945:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####:  946:    va_end(args);
        -:  947:    
        -:  948:    // Add to head (LIFO)
    #####:  949:    node->next = chain->head;
    #####:  950:    chain->head = node;
    #####:  951:    chain->count++;
        -:  952:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####:  935:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####:  936:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -:  937:    
    #####:  938:    error_node_t* node = malloc(sizeof(error_node_t));
    #####:  939:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -:  940:    
    #####:  941:    node->code = code;
        -:  942:    
        -:  943:    va_list args;
    #####:  944:    va_start(args, format);
    #####:  945:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####:  946:    va_end(args);
        -:  947:    
        -:  948:    // Add to head (LIFO)
    #####:  949:    node->next = chain->head;
    #####:  950:    chain->head = node;
    #####:  951:    chain->count++;
        -:  952:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####:  935:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####:  936:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -:  937:    
    #####:  938:    error_node_t* node = malloc(sizeof(error_node_t));
    #####:  939:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -:  940:    
    #####:  941:    node->code = code;
        -:  942:    
        -:  943:    va_list args;
    #####:  944:    va_start(args, format);
    #####:  945:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####:  946:    va_end(args);
        -:  947:    
        -:  948:    // Add to head (LIFO)
    #####:  949:    node->next = chain->head;
    #####:  950:    chain->head = node;
    #####:  951:    chain->count++;
        -:  952:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####:  935:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####:  936:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -:  937:    
    #####:  938:    error_node_t* node = malloc(sizeof(error_node_t));
    #####:  939:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -:  940:    
    #####:  941:    node->code = code;
        -:  942:    
        -:  943:    va_list args;
    #####:  944:    va_start(args, format);
    #####:  945:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####:  946:    va_end(args);
        -:  947:    
        -:  948:    // Add to head (LIFO)
    #####:  949:    node->next = chain->head;
    #####:  950:    chain->head = node;
    #####:  951:    chain->count++;
        -:  952:}
------------------
        -:  953:
    #####:  954:void error_chain_destroy(error_chain_t* chain) {
    #####:  955:    if (!chain) return;
        -:  956:    
    #####:  957:    error_node_t* node = chain->head;
    #####:  958:    while (node) {
    #####:  959:        error_node_t* next = node->next;
    #####:  960:        free(node);
        -:  961:        node = next;
        -:  962:    }
        -:  963:    
    #####:  964:    chain->head = NULL;
    #####:  965:    chain->count = 0;
        -:  966:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####:  954:void error_chain_destroy(error_chain_t* chain) {
    #####:  955:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  956:    
    #####:  957:    error_node_t* node = chain->head;
    #####:  958:    while (node) {
branch  0 never executed
branch  1 never executed
    #####:  959:        error_node_t* next = node->next;
    #####:  960:        free(node);
        -:  961:        node = next;
        -:  962:    }
        -:  963:    
    #####:  964:    chain->head = NULL;
    #####:  965:    chain->count = 0;
        -:  966:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####:  954:void error_chain_destroy(error_chain_t* chain) {
    #####:  955:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  956:    
    #####:  957:    error_node_t* node = chain->head;
    #####:  958:    while (node) {
branch  0 never executed
branch  1 never executed
    #####:  959:        error_node_t* next = node->next;
    #####:  960:        free(node);
        -:  961:        node = next;
        -:  962:    }
        -:  963:    
    #####:  964:    chain->head = NULL;
    #####:  965:    chain->count = 0;
        -:  966:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####:  954:void error_chain_destroy(error_chain_t* chain) {
    #####:  955:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  956:    
    #####:  957:    error_node_t* node = chain->head;
    #####:  958:    while (node) {
branch  0 never executed
branch  1 never executed
    #####:  959:        error_node_t* next = node->next;
    #####:  960:        free(node);
        -:  961:        node = next;
        -:  962:    }
        -:  963:    
    #####:  964:    chain->head = NULL;
    #####:  965:    chain->count = 0;
        -:  966:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####:  954:void error_chain_destroy(error_chain_t* chain) {
    #####:  955:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  956:    
    #####:  957:    error_node_t* node = chain->head;
    #####:  958:    while (node) {
branch  0 never executed
branch  1 never executed
    #####:  959:        error_node_t* next = node->next;
    #####:  960:        free(node);
        -:  961:        node = next;
        -:  962:    }
        -:  963:    
    #####:  964:    chain->head = NULL;
    #####:  965:    chain->count = 0;
        -:  966:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####:  954:void error_chain_destroy(error_chain_t* chain) {
    #####:  955:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  956:    
    #####:  957:    error_node_t* node = chain->head;
    #####:  958:    while (node) {
branch  0 never executed
branch  1 never executed
    #####:  959:        error_node_t* next = node->next;
    #####:  960:        free(node);
        -:  961:        node = next;
        -:  962:    }
        -:  963:    
    #####:  964:    chain->head = NULL;
    #####:  965:    chain->count = 0;
        -:  966:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####:  954:void error_chain_destroy(error_chain_t* chain) {
    #####:  955:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  956:    
    #####:  957:    error_node_t* node = chain->head;
    #####:  958:    while (node) {
branch  0 never executed
branch  1 never executed
    #####:  959:        error_node_t* next = node->next;
    #####:  960:        free(node);
        -:  961:        node = next;
        -:  962:    }
        -:  963:    
    #####:  964:    chain->head = NULL;
    #####:  965:    chain->count = 0;
        -:  966:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####:  954:void error_chain_destroy(error_chain_t* chain) {
    #####:  955:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  956:    
    #####:  957:    error_node_t* node = chain->head;
    #####:  958:    while (node) {
branch  0 never executed
branch  1 never executed
    #####:  959:        error_node_t* next = node->next;
    #####:  960:        free(node);
        -:  961:        node = next;
        -:  962:    }
        -:  963:    
    #####:  964:    chain->head = NULL;
    #####:  965:    chain->count = 0;
        -:  966:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####:  954:void error_chain_destroy(error_chain_t* chain) {
    #####:  955:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  956:    
    #####:  957:    error_node_t* node = chain->head;
    #####:  958:    while (node) {
branch  0 never executed
branch  1 never executed
    #####:  959:        error_node_t* next = node->next;
    #####:  960:        free(node);
        -:  961:        node = next;
        -:  962:    }
        -:  963:    
    #####:  964:    chain->head = NULL;
    #####:  965:    chain->count = 0;
        -:  966:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####:  954:void error_chain_destroy(error_chain_t* chain) {
    #####:  955:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  956:    
    #####:  957:    error_node_t* node = chain->head;
    #####:  958:    while (node) {
branch  0 never executed
branch  1 never executed
    #####:  959:        error_node_t* next = node->next;
    #####:  960:        free(node);
        -:  961:        node = next;
        -:  962:    }
        -:  963:    
    #####:  964:    chain->head = NULL;
    #####:  965:    chain->count = 0;
        -:  966:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####:  954:void error_chain_destroy(error_chain_t* chain) {
    #####:  955:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  956:    
    #####:  957:    error_node_t* node = chain->head;
    #####:  958:    while (node) {
branch  0 never executed
branch  1 never executed
    #####:  959:        error_node_t* next = node->next;
    #####:  960:        free(node);
        -:  961:        node = next;
        -:  962:    }
        -:  963:    
    #####:  964:    chain->head = NULL;
    #####:  965:    chain->count = 0;
        -:  966:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####:  954:void error_chain_destroy(error_chain_t* chain) {
    #####:  955:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  956:    
    #####:  957:    error_node_t* node = chain->head;
    #####:  958:    while (node) {
branch  0 never executed
branch  1 never executed
    #####:  959:        error_node_t* next = node->next;
    #####:  960:        free(node);
        -:  961:        node = next;
        -:  962:    }
        -:  963:    
    #####:  964:    chain->head = NULL;
    #####:  965:    chain->count = 0;
        -:  966:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####:  954:void error_chain_destroy(error_chain_t* chain) {
    #####:  955:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  956:    
    #####:  957:    error_node_t* node = chain->head;
    #####:  958:    while (node) {
branch  0 never executed
branch  1 never executed
    #####:  959:        error_node_t* next = node->next;
    #####:  960:        free(node);
        -:  961:        node = next;
        -:  962:    }
        -:  963:    
    #####:  964:    chain->head = NULL;
    #####:  965:    chain->count = 0;
        -:  966:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####:  954:void error_chain_destroy(error_chain_t* chain) {
    #####:  955:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  956:    
    #####:  957:    error_node_t* node = chain->head;
    #####:  958:    while (node) {
branch  0 never executed
branch  1 never executed
    #####:  959:        error_node_t* next = node->next;
    #####:  960:        free(node);
        -:  961:        node = next;
        -:  962:    }
        -:  963:    
    #####:  964:    chain->head = NULL;
    #####:  965:    chain->count = 0;
        -:  966:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####:  954:void error_chain_destroy(error_chain_t* chain) {
    #####:  955:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -:  956:    
    #####:  957:    error_node_t* node = chain->head;
    #####:  958:    while (node) {
branch  0 never executed
branch  1 never executed
    #####:  959:        error_node_t* next = node->next;
    #####:  960:        free(node);
        -:  961:        node = next;
        -:  962:    }
        -:  963:    
    #####:  964:    chain->head = NULL;
    #####:  965:    chain->count = 0;
        -:  966:}
------------------
        -:  967:
        -:  968:// === SIMD OPTIMIZED OPERATIONS ===
        -:  969:
        -:  970:#ifdef USE_SIMD
    6349*:  971:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    6349*:  972:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
        -:  973:        return;
        -:  974:    }
        -:  975:    
        -:  976:    char* d = (char*)dest;
        -:  977:    const char* s = (const char*)src;
        -:  978:    
        -:  979:    // For small sizes, use regular memcpy
    6346*:  980:    if (MERCURY_UNLIKELY(size < 32)) {
        -:  981:        memcpy(dest, src, size);
    #####:  982:        return;
        -:  983:    }
        -:  984:    
        -:  985:    // AVX2 implementation for 256-bit (32-byte) chunks
    6346*:  986:    size_t avx_chunks = size / 32;
    6346*:  987:    size_t remainder = size % 32;
        -:  988:    
   20597*:  989:    for (size_t i = 0; i < avx_chunks; i++) {
   14251*:  990:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
   14251*:  991:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -:  992:    }
        -:  993:    
        -:  994:    // Handle remainder with regular memcpy
    6346*:  995:    if (remainder > 0) {
      25*:  996:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -:  997:    }
        -:  998:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 0 returned 0% blocks executed 0%
    #####:  971:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    #####:  972:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  973:        return;
        -:  974:    }
        -:  975:    
        -:  976:    char* d = (char*)dest;
        -:  977:    const char* s = (const char*)src;
        -:  978:    
        -:  979:    // For small sizes, use regular memcpy
    #####:  980:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 never executed
branch  1 never executed
        -:  981:        memcpy(dest, src, size);
    #####:  982:        return;
        -:  983:    }
        -:  984:    
        -:  985:    // AVX2 implementation for 256-bit (32-byte) chunks
    #####:  986:    size_t avx_chunks = size / 32;
    #####:  987:    size_t remainder = size % 32;
        -:  988:    
    #####:  989:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  990:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    #####:  991:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -:  992:    }
        -:  993:    
        -:  994:    // Handle remainder with regular memcpy
    #####:  995:    if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  996:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -:  997:    }
        -:  998:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 21 returned 100% blocks executed 90%
       21:  971:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
       21:  972:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  973:        return;
        -:  974:    }
        -:  975:    
        -:  976:    char* d = (char*)dest;
        -:  977:    const char* s = (const char*)src;
        -:  978:    
        -:  979:    // For small sizes, use regular memcpy
       21:  980:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  981:        memcpy(dest, src, size);
    #####:  982:        return;
        -:  983:    }
        -:  984:    
        -:  985:    // AVX2 implementation for 256-bit (32-byte) chunks
       21:  986:    size_t avx_chunks = size / 32;
       21:  987:    size_t remainder = size % 32;
        -:  988:    
     1612:  989:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
     1591:  990:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
     1591:  991:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -:  992:    }
        -:  993:    
        -:  994:    // Handle remainder with regular memcpy
       21:  995:    if (remainder > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       21:  996:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -:  997:    }
        -:  998:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 2 returned 100% blocks executed 80%
        2:  971:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
        2:  972:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  973:        return;
        -:  974:    }
        -:  975:    
        -:  976:    char* d = (char*)dest;
        -:  977:    const char* s = (const char*)src;
        -:  978:    
        -:  979:    // For small sizes, use regular memcpy
        2:  980:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  981:        memcpy(dest, src, size);
    #####:  982:        return;
        -:  983:    }
        -:  984:    
        -:  985:    // AVX2 implementation for 256-bit (32-byte) chunks
        2:  986:    size_t avx_chunks = size / 32;
        2:  987:    size_t remainder = size % 32;
        -:  988:    
       10:  989:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        8:  990:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
        8:  991:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -:  992:    }
        -:  993:    
        -:  994:    // Handle remainder with regular memcpy
        2:  995:    if (remainder > 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  996:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -:  997:    }
        -:  998:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 7 returned 100% blocks executed 90%
        7:  971:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
        7:  972:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
branch  2 taken 80% (fallthrough)
branch  3 taken 20%
        -:  973:        return;
        -:  974:    }
        -:  975:    
        -:  976:    char* d = (char*)dest;
        -:  977:    const char* s = (const char*)src;
        -:  978:    
        -:  979:    // For small sizes, use regular memcpy
        4:  980:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  981:        memcpy(dest, src, size);
    #####:  982:        return;
        -:  983:    }
        -:  984:    
        -:  985:    // AVX2 implementation for 256-bit (32-byte) chunks
        4:  986:    size_t avx_chunks = size / 32;
        4:  987:    size_t remainder = size % 32;
        -:  988:    
       18:  989:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 taken 78%
branch  1 taken 22% (fallthrough)
       14:  990:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
       14:  991:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -:  992:    }
        -:  993:    
        -:  994:    // Handle remainder with regular memcpy
        4:  995:    if (remainder > 0) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        1:  996:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -:  997:    }
        -:  998:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 0 returned 0% blocks executed 0%
    #####:  971:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    #####:  972:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  973:        return;
        -:  974:    }
        -:  975:    
        -:  976:    char* d = (char*)dest;
        -:  977:    const char* s = (const char*)src;
        -:  978:    
        -:  979:    // For small sizes, use regular memcpy
    #####:  980:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 never executed
branch  1 never executed
        -:  981:        memcpy(dest, src, size);
    #####:  982:        return;
        -:  983:    }
        -:  984:    
        -:  985:    // AVX2 implementation for 256-bit (32-byte) chunks
    #####:  986:    size_t avx_chunks = size / 32;
    #####:  987:    size_t remainder = size % 32;
        -:  988:    
    #####:  989:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  990:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    #####:  991:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -:  992:    }
        -:  993:    
        -:  994:    // Handle remainder with regular memcpy
    #####:  995:    if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  996:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -:  997:    }
        -:  998:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 0 returned 0% blocks executed 0%
    #####:  971:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    #####:  972:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  973:        return;
        -:  974:    }
        -:  975:    
        -:  976:    char* d = (char*)dest;
        -:  977:    const char* s = (const char*)src;
        -:  978:    
        -:  979:    // For small sizes, use regular memcpy
    #####:  980:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 never executed
branch  1 never executed
        -:  981:        memcpy(dest, src, size);
    #####:  982:        return;
        -:  983:    }
        -:  984:    
        -:  985:    // AVX2 implementation for 256-bit (32-byte) chunks
    #####:  986:    size_t avx_chunks = size / 32;
    #####:  987:    size_t remainder = size % 32;
        -:  988:    
    #####:  989:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  990:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    #####:  991:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -:  992:    }
        -:  993:    
        -:  994:    // Handle remainder with regular memcpy
    #####:  995:    if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  996:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -:  997:    }
        -:  998:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 0 returned 0% blocks executed 0%
    #####:  971:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    #####:  972:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  973:        return;
        -:  974:    }
        -:  975:    
        -:  976:    char* d = (char*)dest;
        -:  977:    const char* s = (const char*)src;
        -:  978:    
        -:  979:    // For small sizes, use regular memcpy
    #####:  980:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 never executed
branch  1 never executed
        -:  981:        memcpy(dest, src, size);
    #####:  982:        return;
        -:  983:    }
        -:  984:    
        -:  985:    // AVX2 implementation for 256-bit (32-byte) chunks
    #####:  986:    size_t avx_chunks = size / 32;
    #####:  987:    size_t remainder = size % 32;
        -:  988:    
    #####:  989:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  990:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    #####:  991:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -:  992:    }
        -:  993:    
        -:  994:    // Handle remainder with regular memcpy
    #####:  995:    if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  996:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -:  997:    }
        -:  998:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 0 returned 0% blocks executed 0%
    #####:  971:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    #####:  972:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  973:        return;
        -:  974:    }
        -:  975:    
        -:  976:    char* d = (char*)dest;
        -:  977:    const char* s = (const char*)src;
        -:  978:    
        -:  979:    // For small sizes, use regular memcpy
    #####:  980:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 never executed
branch  1 never executed
        -:  981:        memcpy(dest, src, size);
    #####:  982:        return;
        -:  983:    }
        -:  984:    
        -:  985:    // AVX2 implementation for 256-bit (32-byte) chunks
    #####:  986:    size_t avx_chunks = size / 32;
    #####:  987:    size_t remainder = size % 32;
        -:  988:    
    #####:  989:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  990:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    #####:  991:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -:  992:    }
        -:  993:    
        -:  994:    // Handle remainder with regular memcpy
    #####:  995:    if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  996:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -:  997:    }
        -:  998:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 0 returned 0% blocks executed 0%
    #####:  971:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    #####:  972:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  973:        return;
        -:  974:    }
        -:  975:    
        -:  976:    char* d = (char*)dest;
        -:  977:    const char* s = (const char*)src;
        -:  978:    
        -:  979:    // For small sizes, use regular memcpy
    #####:  980:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 never executed
branch  1 never executed
        -:  981:        memcpy(dest, src, size);
    #####:  982:        return;
        -:  983:    }
        -:  984:    
        -:  985:    // AVX2 implementation for 256-bit (32-byte) chunks
    #####:  986:    size_t avx_chunks = size / 32;
    #####:  987:    size_t remainder = size % 32;
        -:  988:    
    #####:  989:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  990:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    #####:  991:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -:  992:    }
        -:  993:    
        -:  994:    // Handle remainder with regular memcpy
    #####:  995:    if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  996:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -:  997:    }
        -:  998:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 107 returned 100% blocks executed 90%
      107:  971:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
      107:  972:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  973:        return;
        -:  974:    }
        -:  975:    
        -:  976:    char* d = (char*)dest;
        -:  977:    const char* s = (const char*)src;
        -:  978:    
        -:  979:    // For small sizes, use regular memcpy
      107:  980:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  981:        memcpy(dest, src, size);
    #####:  982:        return;
        -:  983:    }
        -:  984:    
        -:  985:    // AVX2 implementation for 256-bit (32-byte) chunks
      107:  986:    size_t avx_chunks = size / 32;
      107:  987:    size_t remainder = size % 32;
        -:  988:    
      321:  989:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
      214:  990:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
      214:  991:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -:  992:    }
        -:  993:    
        -:  994:    // Handle remainder with regular memcpy
      107:  995:    if (remainder > 0) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        1:  996:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -:  997:    }
        -:  998:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 6212 returned 100% blocks executed 90%
     6212:  971:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
     6212:  972:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  973:        return;
        -:  974:    }
        -:  975:    
        -:  976:    char* d = (char*)dest;
        -:  977:    const char* s = (const char*)src;
        -:  978:    
        -:  979:    // For small sizes, use regular memcpy
     6212:  980:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  981:        memcpy(dest, src, size);
    #####:  982:        return;
        -:  983:    }
        -:  984:    
        -:  985:    // AVX2 implementation for 256-bit (32-byte) chunks
     6212:  986:    size_t avx_chunks = size / 32;
     6212:  987:    size_t remainder = size % 32;
        -:  988:    
    18636:  989:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
    12424:  990:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    12424:  991:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -:  992:    }
        -:  993:    
        -:  994:    // Handle remainder with regular memcpy
     6212:  995:    if (remainder > 0) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        2:  996:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -:  997:    }
        -:  998:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 0 returned 0% blocks executed 0%
    #####:  971:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    #####:  972:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  973:        return;
        -:  974:    }
        -:  975:    
        -:  976:    char* d = (char*)dest;
        -:  977:    const char* s = (const char*)src;
        -:  978:    
        -:  979:    // For small sizes, use regular memcpy
    #####:  980:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 never executed
branch  1 never executed
        -:  981:        memcpy(dest, src, size);
    #####:  982:        return;
        -:  983:    }
        -:  984:    
        -:  985:    // AVX2 implementation for 256-bit (32-byte) chunks
    #####:  986:    size_t avx_chunks = size / 32;
    #####:  987:    size_t remainder = size % 32;
        -:  988:    
    #####:  989:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  990:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    #####:  991:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -:  992:    }
        -:  993:    
        -:  994:    // Handle remainder with regular memcpy
    #####:  995:    if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  996:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -:  997:    }
        -:  998:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 0 returned 0% blocks executed 0%
    #####:  971:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    #####:  972:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  973:        return;
        -:  974:    }
        -:  975:    
        -:  976:    char* d = (char*)dest;
        -:  977:    const char* s = (const char*)src;
        -:  978:    
        -:  979:    // For small sizes, use regular memcpy
    #####:  980:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 never executed
branch  1 never executed
        -:  981:        memcpy(dest, src, size);
    #####:  982:        return;
        -:  983:    }
        -:  984:    
        -:  985:    // AVX2 implementation for 256-bit (32-byte) chunks
    #####:  986:    size_t avx_chunks = size / 32;
    #####:  987:    size_t remainder = size % 32;
        -:  988:    
    #####:  989:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  990:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    #####:  991:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -:  992:    }
        -:  993:    
        -:  994:    // Handle remainder with regular memcpy
    #####:  995:    if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  996:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -:  997:    }
        -:  998:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 0 returned 0% blocks executed 0%
    #####:  971:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    #####:  972:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  973:        return;
        -:  974:    }
        -:  975:    
        -:  976:    char* d = (char*)dest;
        -:  977:    const char* s = (const char*)src;
        -:  978:    
        -:  979:    // For small sizes, use regular memcpy
    #####:  980:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 never executed
branch  1 never executed
        -:  981:        memcpy(dest, src, size);
    #####:  982:        return;
        -:  983:    }
        -:  984:    
        -:  985:    // AVX2 implementation for 256-bit (32-byte) chunks
    #####:  986:    size_t avx_chunks = size / 32;
    #####:  987:    size_t remainder = size % 32;
        -:  988:    
    #####:  989:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  990:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    #####:  991:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -:  992:    }
        -:  993:    
        -:  994:    // Handle remainder with regular memcpy
    #####:  995:    if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  996:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -:  997:    }
        -:  998:}
------------------
        -:  999:
        -: 1000:// SIMD-accelerated string search (Boyer-Moore style)
    #####: 1001:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1002:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
        -: 1003:        return -1;
        -: 1004:    }
        -: 1005:    
        -: 1006:    // For small patterns, use regular strstr
    #####: 1007:    if (pattern_len < 4) {
    #####: 1008:        const char* found = strstr(text, pattern);
    #####: 1009:        return found ? (int)(found - text) : -1;
        -: 1010:    }
        -: 1011:    
        -: 1012:    // Use SIMD for searching the first character of pattern
    #####: 1013:    const char first_char = pattern[0];
        -: 1014:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1015:    
    #####: 1016:    size_t max_pos = text_len - pattern_len;
        -: 1017:    size_t pos = 0;
        -: 1018:    
        -: 1019:    // SIMD scan for potential matches
    #####: 1020:    while (pos <= max_pos) {
    #####: 1021:        if (pos + 32 <= text_len) {
        -: 1022:            // Prefetch next chunk for sequential scanning
    #####: 1023:            if (pos + 64 <= text_len) {
    #####: 1024:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
        -: 1025:            }
        -: 1026:            
        -: 1027:            // Load 32 characters from text
    #####: 1028:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1029:            
        -: 1030:            // Compare with first character
        -: 1031:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1032:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1033:            
        -: 1034:            // Check each potential match
    #####: 1035:            while (match_mask != 0) {
    #####: 1036:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1037:                size_t match_pos = pos + bit_pos;
        -: 1038:                
    #####: 1039:                if (match_pos <= max_pos) {
        -: 1040:                    // Prefetch the potential match location
    #####: 1041:                    MERCURY_PREFETCH_READ(text + match_pos);
        -: 1042:                    
        -: 1043:                    // Verify full pattern match
    #####: 1044:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
    #####: 1045:                        return (int)match_pos;
        -: 1046:                    }
        -: 1047:                }
        -: 1048:                
    #####: 1049:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1050:            }
        -: 1051:            
        -: 1052:            pos += 32;
        -: 1053:        } else {
        -: 1054:            // Handle remainder with regular search
    #####: 1055:            const char* found = strstr(text + pos, pattern);
    #####: 1056:            return found ? (int)(found - text) : -1;
        -: 1057:        }
        -: 1058:    }
        -: 1059:    
        -: 1060:    return -1;  // Not found
        -: 1061:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1001:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1002:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1003:        return -1;
        -: 1004:    }
        -: 1005:    
        -: 1006:    // For small patterns, use regular strstr
    #####: 1007:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1008:        const char* found = strstr(text, pattern);
    #####: 1009:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1010:    }
        -: 1011:    
        -: 1012:    // Use SIMD for searching the first character of pattern
    #####: 1013:    const char first_char = pattern[0];
        -: 1014:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1015:    
    #####: 1016:    size_t max_pos = text_len - pattern_len;
        -: 1017:    size_t pos = 0;
        -: 1018:    
        -: 1019:    // SIMD scan for potential matches
    #####: 1020:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1021:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1022:            // Prefetch next chunk for sequential scanning
    #####: 1023:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1024:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1025:            }
        -: 1026:            
        -: 1027:            // Load 32 characters from text
    #####: 1028:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1029:            
        -: 1030:            // Compare with first character
        -: 1031:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1032:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1033:            
        -: 1034:            // Check each potential match
    #####: 1035:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1037:                size_t match_pos = pos + bit_pos;
        -: 1038:                
    #####: 1039:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1040:                    // Prefetch the potential match location
    #####: 1041:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1042:                    
        -: 1043:                    // Verify full pattern match
    #####: 1044:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1045:                        return (int)match_pos;
        -: 1046:                    }
        -: 1047:                }
        -: 1048:                
    #####: 1049:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1050:            }
        -: 1051:            
        -: 1052:            pos += 32;
        -: 1053:        } else {
        -: 1054:            // Handle remainder with regular search
    #####: 1055:            const char* found = strstr(text + pos, pattern);
    #####: 1056:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1057:        }
        -: 1058:    }
        -: 1059:    
        -: 1060:    return -1;  // Not found
        -: 1061:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1001:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1002:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1003:        return -1;
        -: 1004:    }
        -: 1005:    
        -: 1006:    // For small patterns, use regular strstr
    #####: 1007:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1008:        const char* found = strstr(text, pattern);
    #####: 1009:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1010:    }
        -: 1011:    
        -: 1012:    // Use SIMD for searching the first character of pattern
    #####: 1013:    const char first_char = pattern[0];
        -: 1014:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1015:    
    #####: 1016:    size_t max_pos = text_len - pattern_len;
        -: 1017:    size_t pos = 0;
        -: 1018:    
        -: 1019:    // SIMD scan for potential matches
    #####: 1020:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1021:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1022:            // Prefetch next chunk for sequential scanning
    #####: 1023:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1024:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1025:            }
        -: 1026:            
        -: 1027:            // Load 32 characters from text
    #####: 1028:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1029:            
        -: 1030:            // Compare with first character
        -: 1031:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1032:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1033:            
        -: 1034:            // Check each potential match
    #####: 1035:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1037:                size_t match_pos = pos + bit_pos;
        -: 1038:                
    #####: 1039:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1040:                    // Prefetch the potential match location
    #####: 1041:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1042:                    
        -: 1043:                    // Verify full pattern match
    #####: 1044:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1045:                        return (int)match_pos;
        -: 1046:                    }
        -: 1047:                }
        -: 1048:                
    #####: 1049:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1050:            }
        -: 1051:            
        -: 1052:            pos += 32;
        -: 1053:        } else {
        -: 1054:            // Handle remainder with regular search
    #####: 1055:            const char* found = strstr(text + pos, pattern);
    #####: 1056:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1057:        }
        -: 1058:    }
        -: 1059:    
        -: 1060:    return -1;  // Not found
        -: 1061:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1001:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1002:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1003:        return -1;
        -: 1004:    }
        -: 1005:    
        -: 1006:    // For small patterns, use regular strstr
    #####: 1007:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1008:        const char* found = strstr(text, pattern);
    #####: 1009:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1010:    }
        -: 1011:    
        -: 1012:    // Use SIMD for searching the first character of pattern
    #####: 1013:    const char first_char = pattern[0];
        -: 1014:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1015:    
    #####: 1016:    size_t max_pos = text_len - pattern_len;
        -: 1017:    size_t pos = 0;
        -: 1018:    
        -: 1019:    // SIMD scan for potential matches
    #####: 1020:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1021:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1022:            // Prefetch next chunk for sequential scanning
    #####: 1023:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1024:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1025:            }
        -: 1026:            
        -: 1027:            // Load 32 characters from text
    #####: 1028:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1029:            
        -: 1030:            // Compare with first character
        -: 1031:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1032:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1033:            
        -: 1034:            // Check each potential match
    #####: 1035:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1037:                size_t match_pos = pos + bit_pos;
        -: 1038:                
    #####: 1039:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1040:                    // Prefetch the potential match location
    #####: 1041:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1042:                    
        -: 1043:                    // Verify full pattern match
    #####: 1044:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1045:                        return (int)match_pos;
        -: 1046:                    }
        -: 1047:                }
        -: 1048:                
    #####: 1049:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1050:            }
        -: 1051:            
        -: 1052:            pos += 32;
        -: 1053:        } else {
        -: 1054:            // Handle remainder with regular search
    #####: 1055:            const char* found = strstr(text + pos, pattern);
    #####: 1056:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1057:        }
        -: 1058:    }
        -: 1059:    
        -: 1060:    return -1;  // Not found
        -: 1061:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1001:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1002:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1003:        return -1;
        -: 1004:    }
        -: 1005:    
        -: 1006:    // For small patterns, use regular strstr
    #####: 1007:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1008:        const char* found = strstr(text, pattern);
    #####: 1009:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1010:    }
        -: 1011:    
        -: 1012:    // Use SIMD for searching the first character of pattern
    #####: 1013:    const char first_char = pattern[0];
        -: 1014:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1015:    
    #####: 1016:    size_t max_pos = text_len - pattern_len;
        -: 1017:    size_t pos = 0;
        -: 1018:    
        -: 1019:    // SIMD scan for potential matches
    #####: 1020:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1021:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1022:            // Prefetch next chunk for sequential scanning
    #####: 1023:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1024:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1025:            }
        -: 1026:            
        -: 1027:            // Load 32 characters from text
    #####: 1028:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1029:            
        -: 1030:            // Compare with first character
        -: 1031:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1032:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1033:            
        -: 1034:            // Check each potential match
    #####: 1035:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1037:                size_t match_pos = pos + bit_pos;
        -: 1038:                
    #####: 1039:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1040:                    // Prefetch the potential match location
    #####: 1041:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1042:                    
        -: 1043:                    // Verify full pattern match
    #####: 1044:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1045:                        return (int)match_pos;
        -: 1046:                    }
        -: 1047:                }
        -: 1048:                
    #####: 1049:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1050:            }
        -: 1051:            
        -: 1052:            pos += 32;
        -: 1053:        } else {
        -: 1054:            // Handle remainder with regular search
    #####: 1055:            const char* found = strstr(text + pos, pattern);
    #####: 1056:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1057:        }
        -: 1058:    }
        -: 1059:    
        -: 1060:    return -1;  // Not found
        -: 1061:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1001:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1002:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1003:        return -1;
        -: 1004:    }
        -: 1005:    
        -: 1006:    // For small patterns, use regular strstr
    #####: 1007:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1008:        const char* found = strstr(text, pattern);
    #####: 1009:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1010:    }
        -: 1011:    
        -: 1012:    // Use SIMD for searching the first character of pattern
    #####: 1013:    const char first_char = pattern[0];
        -: 1014:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1015:    
    #####: 1016:    size_t max_pos = text_len - pattern_len;
        -: 1017:    size_t pos = 0;
        -: 1018:    
        -: 1019:    // SIMD scan for potential matches
    #####: 1020:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1021:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1022:            // Prefetch next chunk for sequential scanning
    #####: 1023:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1024:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1025:            }
        -: 1026:            
        -: 1027:            // Load 32 characters from text
    #####: 1028:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1029:            
        -: 1030:            // Compare with first character
        -: 1031:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1032:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1033:            
        -: 1034:            // Check each potential match
    #####: 1035:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1037:                size_t match_pos = pos + bit_pos;
        -: 1038:                
    #####: 1039:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1040:                    // Prefetch the potential match location
    #####: 1041:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1042:                    
        -: 1043:                    // Verify full pattern match
    #####: 1044:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1045:                        return (int)match_pos;
        -: 1046:                    }
        -: 1047:                }
        -: 1048:                
    #####: 1049:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1050:            }
        -: 1051:            
        -: 1052:            pos += 32;
        -: 1053:        } else {
        -: 1054:            // Handle remainder with regular search
    #####: 1055:            const char* found = strstr(text + pos, pattern);
    #####: 1056:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1057:        }
        -: 1058:    }
        -: 1059:    
        -: 1060:    return -1;  // Not found
        -: 1061:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1001:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1002:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1003:        return -1;
        -: 1004:    }
        -: 1005:    
        -: 1006:    // For small patterns, use regular strstr
    #####: 1007:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1008:        const char* found = strstr(text, pattern);
    #####: 1009:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1010:    }
        -: 1011:    
        -: 1012:    // Use SIMD for searching the first character of pattern
    #####: 1013:    const char first_char = pattern[0];
        -: 1014:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1015:    
    #####: 1016:    size_t max_pos = text_len - pattern_len;
        -: 1017:    size_t pos = 0;
        -: 1018:    
        -: 1019:    // SIMD scan for potential matches
    #####: 1020:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1021:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1022:            // Prefetch next chunk for sequential scanning
    #####: 1023:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1024:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1025:            }
        -: 1026:            
        -: 1027:            // Load 32 characters from text
    #####: 1028:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1029:            
        -: 1030:            // Compare with first character
        -: 1031:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1032:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1033:            
        -: 1034:            // Check each potential match
    #####: 1035:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1037:                size_t match_pos = pos + bit_pos;
        -: 1038:                
    #####: 1039:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1040:                    // Prefetch the potential match location
    #####: 1041:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1042:                    
        -: 1043:                    // Verify full pattern match
    #####: 1044:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1045:                        return (int)match_pos;
        -: 1046:                    }
        -: 1047:                }
        -: 1048:                
    #####: 1049:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1050:            }
        -: 1051:            
        -: 1052:            pos += 32;
        -: 1053:        } else {
        -: 1054:            // Handle remainder with regular search
    #####: 1055:            const char* found = strstr(text + pos, pattern);
    #####: 1056:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1057:        }
        -: 1058:    }
        -: 1059:    
        -: 1060:    return -1;  // Not found
        -: 1061:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1001:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1002:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1003:        return -1;
        -: 1004:    }
        -: 1005:    
        -: 1006:    // For small patterns, use regular strstr
    #####: 1007:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1008:        const char* found = strstr(text, pattern);
    #####: 1009:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1010:    }
        -: 1011:    
        -: 1012:    // Use SIMD for searching the first character of pattern
    #####: 1013:    const char first_char = pattern[0];
        -: 1014:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1015:    
    #####: 1016:    size_t max_pos = text_len - pattern_len;
        -: 1017:    size_t pos = 0;
        -: 1018:    
        -: 1019:    // SIMD scan for potential matches
    #####: 1020:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1021:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1022:            // Prefetch next chunk for sequential scanning
    #####: 1023:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1024:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1025:            }
        -: 1026:            
        -: 1027:            // Load 32 characters from text
    #####: 1028:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1029:            
        -: 1030:            // Compare with first character
        -: 1031:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1032:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1033:            
        -: 1034:            // Check each potential match
    #####: 1035:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1037:                size_t match_pos = pos + bit_pos;
        -: 1038:                
    #####: 1039:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1040:                    // Prefetch the potential match location
    #####: 1041:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1042:                    
        -: 1043:                    // Verify full pattern match
    #####: 1044:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1045:                        return (int)match_pos;
        -: 1046:                    }
        -: 1047:                }
        -: 1048:                
    #####: 1049:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1050:            }
        -: 1051:            
        -: 1052:            pos += 32;
        -: 1053:        } else {
        -: 1054:            // Handle remainder with regular search
    #####: 1055:            const char* found = strstr(text + pos, pattern);
    #####: 1056:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1057:        }
        -: 1058:    }
        -: 1059:    
        -: 1060:    return -1;  // Not found
        -: 1061:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1001:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1002:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1003:        return -1;
        -: 1004:    }
        -: 1005:    
        -: 1006:    // For small patterns, use regular strstr
    #####: 1007:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1008:        const char* found = strstr(text, pattern);
    #####: 1009:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1010:    }
        -: 1011:    
        -: 1012:    // Use SIMD for searching the first character of pattern
    #####: 1013:    const char first_char = pattern[0];
        -: 1014:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1015:    
    #####: 1016:    size_t max_pos = text_len - pattern_len;
        -: 1017:    size_t pos = 0;
        -: 1018:    
        -: 1019:    // SIMD scan for potential matches
    #####: 1020:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1021:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1022:            // Prefetch next chunk for sequential scanning
    #####: 1023:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1024:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1025:            }
        -: 1026:            
        -: 1027:            // Load 32 characters from text
    #####: 1028:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1029:            
        -: 1030:            // Compare with first character
        -: 1031:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1032:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1033:            
        -: 1034:            // Check each potential match
    #####: 1035:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1037:                size_t match_pos = pos + bit_pos;
        -: 1038:                
    #####: 1039:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1040:                    // Prefetch the potential match location
    #####: 1041:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1042:                    
        -: 1043:                    // Verify full pattern match
    #####: 1044:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1045:                        return (int)match_pos;
        -: 1046:                    }
        -: 1047:                }
        -: 1048:                
    #####: 1049:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1050:            }
        -: 1051:            
        -: 1052:            pos += 32;
        -: 1053:        } else {
        -: 1054:            // Handle remainder with regular search
    #####: 1055:            const char* found = strstr(text + pos, pattern);
    #####: 1056:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1057:        }
        -: 1058:    }
        -: 1059:    
        -: 1060:    return -1;  // Not found
        -: 1061:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1001:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1002:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1003:        return -1;
        -: 1004:    }
        -: 1005:    
        -: 1006:    // For small patterns, use regular strstr
    #####: 1007:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1008:        const char* found = strstr(text, pattern);
    #####: 1009:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1010:    }
        -: 1011:    
        -: 1012:    // Use SIMD for searching the first character of pattern
    #####: 1013:    const char first_char = pattern[0];
        -: 1014:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1015:    
    #####: 1016:    size_t max_pos = text_len - pattern_len;
        -: 1017:    size_t pos = 0;
        -: 1018:    
        -: 1019:    // SIMD scan for potential matches
    #####: 1020:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1021:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1022:            // Prefetch next chunk for sequential scanning
    #####: 1023:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1024:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1025:            }
        -: 1026:            
        -: 1027:            // Load 32 characters from text
    #####: 1028:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1029:            
        -: 1030:            // Compare with first character
        -: 1031:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1032:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1033:            
        -: 1034:            // Check each potential match
    #####: 1035:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1037:                size_t match_pos = pos + bit_pos;
        -: 1038:                
    #####: 1039:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1040:                    // Prefetch the potential match location
    #####: 1041:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1042:                    
        -: 1043:                    // Verify full pattern match
    #####: 1044:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1045:                        return (int)match_pos;
        -: 1046:                    }
        -: 1047:                }
        -: 1048:                
    #####: 1049:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1050:            }
        -: 1051:            
        -: 1052:            pos += 32;
        -: 1053:        } else {
        -: 1054:            // Handle remainder with regular search
    #####: 1055:            const char* found = strstr(text + pos, pattern);
    #####: 1056:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1057:        }
        -: 1058:    }
        -: 1059:    
        -: 1060:    return -1;  // Not found
        -: 1061:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1001:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1002:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1003:        return -1;
        -: 1004:    }
        -: 1005:    
        -: 1006:    // For small patterns, use regular strstr
    #####: 1007:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1008:        const char* found = strstr(text, pattern);
    #####: 1009:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1010:    }
        -: 1011:    
        -: 1012:    // Use SIMD for searching the first character of pattern
    #####: 1013:    const char first_char = pattern[0];
        -: 1014:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1015:    
    #####: 1016:    size_t max_pos = text_len - pattern_len;
        -: 1017:    size_t pos = 0;
        -: 1018:    
        -: 1019:    // SIMD scan for potential matches
    #####: 1020:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1021:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1022:            // Prefetch next chunk for sequential scanning
    #####: 1023:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1024:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1025:            }
        -: 1026:            
        -: 1027:            // Load 32 characters from text
    #####: 1028:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1029:            
        -: 1030:            // Compare with first character
        -: 1031:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1032:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1033:            
        -: 1034:            // Check each potential match
    #####: 1035:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1037:                size_t match_pos = pos + bit_pos;
        -: 1038:                
    #####: 1039:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1040:                    // Prefetch the potential match location
    #####: 1041:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1042:                    
        -: 1043:                    // Verify full pattern match
    #####: 1044:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1045:                        return (int)match_pos;
        -: 1046:                    }
        -: 1047:                }
        -: 1048:                
    #####: 1049:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1050:            }
        -: 1051:            
        -: 1052:            pos += 32;
        -: 1053:        } else {
        -: 1054:            // Handle remainder with regular search
    #####: 1055:            const char* found = strstr(text + pos, pattern);
    #####: 1056:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1057:        }
        -: 1058:    }
        -: 1059:    
        -: 1060:    return -1;  // Not found
        -: 1061:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1001:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1002:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1003:        return -1;
        -: 1004:    }
        -: 1005:    
        -: 1006:    // For small patterns, use regular strstr
    #####: 1007:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1008:        const char* found = strstr(text, pattern);
    #####: 1009:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1010:    }
        -: 1011:    
        -: 1012:    // Use SIMD for searching the first character of pattern
    #####: 1013:    const char first_char = pattern[0];
        -: 1014:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1015:    
    #####: 1016:    size_t max_pos = text_len - pattern_len;
        -: 1017:    size_t pos = 0;
        -: 1018:    
        -: 1019:    // SIMD scan for potential matches
    #####: 1020:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1021:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1022:            // Prefetch next chunk for sequential scanning
    #####: 1023:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1024:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1025:            }
        -: 1026:            
        -: 1027:            // Load 32 characters from text
    #####: 1028:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1029:            
        -: 1030:            // Compare with first character
        -: 1031:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1032:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1033:            
        -: 1034:            // Check each potential match
    #####: 1035:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1037:                size_t match_pos = pos + bit_pos;
        -: 1038:                
    #####: 1039:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1040:                    // Prefetch the potential match location
    #####: 1041:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1042:                    
        -: 1043:                    // Verify full pattern match
    #####: 1044:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1045:                        return (int)match_pos;
        -: 1046:                    }
        -: 1047:                }
        -: 1048:                
    #####: 1049:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1050:            }
        -: 1051:            
        -: 1052:            pos += 32;
        -: 1053:        } else {
        -: 1054:            // Handle remainder with regular search
    #####: 1055:            const char* found = strstr(text + pos, pattern);
    #####: 1056:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1057:        }
        -: 1058:    }
        -: 1059:    
        -: 1060:    return -1;  // Not found
        -: 1061:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1001:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1002:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1003:        return -1;
        -: 1004:    }
        -: 1005:    
        -: 1006:    // For small patterns, use regular strstr
    #####: 1007:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1008:        const char* found = strstr(text, pattern);
    #####: 1009:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1010:    }
        -: 1011:    
        -: 1012:    // Use SIMD for searching the first character of pattern
    #####: 1013:    const char first_char = pattern[0];
        -: 1014:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1015:    
    #####: 1016:    size_t max_pos = text_len - pattern_len;
        -: 1017:    size_t pos = 0;
        -: 1018:    
        -: 1019:    // SIMD scan for potential matches
    #####: 1020:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1021:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1022:            // Prefetch next chunk for sequential scanning
    #####: 1023:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1024:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1025:            }
        -: 1026:            
        -: 1027:            // Load 32 characters from text
    #####: 1028:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1029:            
        -: 1030:            // Compare with first character
        -: 1031:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1032:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1033:            
        -: 1034:            // Check each potential match
    #####: 1035:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1037:                size_t match_pos = pos + bit_pos;
        -: 1038:                
    #####: 1039:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1040:                    // Prefetch the potential match location
    #####: 1041:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1042:                    
        -: 1043:                    // Verify full pattern match
    #####: 1044:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1045:                        return (int)match_pos;
        -: 1046:                    }
        -: 1047:                }
        -: 1048:                
    #####: 1049:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1050:            }
        -: 1051:            
        -: 1052:            pos += 32;
        -: 1053:        } else {
        -: 1054:            // Handle remainder with regular search
    #####: 1055:            const char* found = strstr(text + pos, pattern);
    #####: 1056:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1057:        }
        -: 1058:    }
        -: 1059:    
        -: 1060:    return -1;  // Not found
        -: 1061:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1001:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1002:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1003:        return -1;
        -: 1004:    }
        -: 1005:    
        -: 1006:    // For small patterns, use regular strstr
    #####: 1007:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1008:        const char* found = strstr(text, pattern);
    #####: 1009:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1010:    }
        -: 1011:    
        -: 1012:    // Use SIMD for searching the first character of pattern
    #####: 1013:    const char first_char = pattern[0];
        -: 1014:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1015:    
    #####: 1016:    size_t max_pos = text_len - pattern_len;
        -: 1017:    size_t pos = 0;
        -: 1018:    
        -: 1019:    // SIMD scan for potential matches
    #####: 1020:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1021:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1022:            // Prefetch next chunk for sequential scanning
    #####: 1023:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1024:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1025:            }
        -: 1026:            
        -: 1027:            // Load 32 characters from text
    #####: 1028:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1029:            
        -: 1030:            // Compare with first character
        -: 1031:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1032:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1033:            
        -: 1034:            // Check each potential match
    #####: 1035:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1037:                size_t match_pos = pos + bit_pos;
        -: 1038:                
    #####: 1039:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1040:                    // Prefetch the potential match location
    #####: 1041:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1042:                    
        -: 1043:                    // Verify full pattern match
    #####: 1044:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1045:                        return (int)match_pos;
        -: 1046:                    }
        -: 1047:                }
        -: 1048:                
    #####: 1049:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1050:            }
        -: 1051:            
        -: 1052:            pos += 32;
        -: 1053:        } else {
        -: 1054:            // Handle remainder with regular search
    #####: 1055:            const char* found = strstr(text + pos, pattern);
    #####: 1056:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1057:        }
        -: 1058:    }
        -: 1059:    
        -: 1060:    return -1;  // Not found
        -: 1061:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1001:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1002:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1003:        return -1;
        -: 1004:    }
        -: 1005:    
        -: 1006:    // For small patterns, use regular strstr
    #####: 1007:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1008:        const char* found = strstr(text, pattern);
    #####: 1009:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1010:    }
        -: 1011:    
        -: 1012:    // Use SIMD for searching the first character of pattern
    #####: 1013:    const char first_char = pattern[0];
        -: 1014:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1015:    
    #####: 1016:    size_t max_pos = text_len - pattern_len;
        -: 1017:    size_t pos = 0;
        -: 1018:    
        -: 1019:    // SIMD scan for potential matches
    #####: 1020:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1021:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1022:            // Prefetch next chunk for sequential scanning
    #####: 1023:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1024:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1025:            }
        -: 1026:            
        -: 1027:            // Load 32 characters from text
    #####: 1028:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1029:            
        -: 1030:            // Compare with first character
        -: 1031:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1032:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1033:            
        -: 1034:            // Check each potential match
    #####: 1035:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1036:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1037:                size_t match_pos = pos + bit_pos;
        -: 1038:                
    #####: 1039:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1040:                    // Prefetch the potential match location
    #####: 1041:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1042:                    
        -: 1043:                    // Verify full pattern match
    #####: 1044:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1045:                        return (int)match_pos;
        -: 1046:                    }
        -: 1047:                }
        -: 1048:                
    #####: 1049:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1050:            }
        -: 1051:            
        -: 1052:            pos += 32;
        -: 1053:        } else {
        -: 1054:            // Handle remainder with regular search
    #####: 1055:            const char* found = strstr(text + pos, pattern);
    #####: 1056:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1057:        }
        -: 1058:    }
        -: 1059:    
        -: 1060:    return -1;  // Not found
        -: 1061:}
------------------
        -: 1062:
        -: 1063:// === MULTI-PATTERN SIMD SEARCH IMPLEMENTATION ===
        -: 1064:
       7*: 1065:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
       7*: 1066:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
       2*: 1067:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
       2*: 1068:        return NULL;
        -: 1069:    }
        -: 1070:    
       5*: 1071:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
       5*: 1072:    if (!mps) {
    #####: 1073:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1074:        return NULL;
        -: 1075:    }
        -: 1076:    
        -: 1077:    // Initialize structure
        -: 1078:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
       5*: 1079:    mps->pattern_count = count;
        -: 1080:    
        -: 1081:    // Copy patterns and build lookup tables
      38*: 1082:    for (size_t i = 0; i < count; i++) {
      33*: 1083:        if (!patterns[i]) {
    #####: 1084:            mercury_aligned_free(mps);
    #####: 1085:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1086:            return NULL;
        -: 1087:        }
        -: 1088:        
      33*: 1089:        size_t len = strlen(patterns[i]);
      33*: 1090:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
    #####: 1091:            mercury_aligned_free(mps);
    #####: 1092:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1093:            return NULL;
        -: 1094:        }
        -: 1095:        
        -: 1096:        // Copy pattern
      33*: 1097:        strcpy(mps->patterns[i], patterns[i]);
      33*: 1098:        mps->pattern_lengths[i] = len;
      33*: 1099:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1100:        
        -: 1101:        // Update first character lookup table
      33*: 1102:        uint8_t first_char = (uint8_t)patterns[i][0];
      33*: 1103:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1104:    }
        -: 1105:    
        -: 1106:    return mps;
        -: 1107:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1065:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1066:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1067:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1068:        return NULL;
        -: 1069:    }
        -: 1070:    
    #####: 1071:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1072:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1073:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1074:        return NULL;
        -: 1075:    }
        -: 1076:    
        -: 1077:    // Initialize structure
        -: 1078:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1079:    mps->pattern_count = count;
        -: 1080:    
        -: 1081:    // Copy patterns and build lookup tables
    #####: 1082:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1083:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1084:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1085:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1086:            return NULL;
        -: 1087:        }
        -: 1088:        
    #####: 1089:        size_t len = strlen(patterns[i]);
    #####: 1090:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1091:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1092:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1093:            return NULL;
        -: 1094:        }
        -: 1095:        
        -: 1096:        // Copy pattern
    #####: 1097:        strcpy(mps->patterns[i], patterns[i]);
    #####: 1098:        mps->pattern_lengths[i] = len;
    #####: 1099:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1100:        
        -: 1101:        // Update first character lookup table
    #####: 1102:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1103:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1104:    }
        -: 1105:    
        -: 1106:    return mps;
        -: 1107:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 5 returned 100% blocks executed 69%
        5: 1065:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
        5: 1066:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        2: 1067:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
        2: 1068:        return NULL;
        -: 1069:    }
        -: 1070:    
        3: 1071:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 returned 100%
        3: 1072:    if (!mps) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1073:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1074:        return NULL;
        -: 1075:    }
        -: 1076:    
        -: 1077:    // Initialize structure
        -: 1078:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
        3: 1079:    mps->pattern_count = count;
        -: 1080:    
        -: 1081:    // Copy patterns and build lookup tables
       15: 1082:    for (size_t i = 0; i < count; i++) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
       12: 1083:        if (!patterns[i]) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1084:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1085:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1086:            return NULL;
        -: 1087:        }
        -: 1088:        
       12: 1089:        size_t len = strlen(patterns[i]);
       12: 1090:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1091:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1092:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1093:            return NULL;
        -: 1094:        }
        -: 1095:        
        -: 1096:        // Copy pattern
       12: 1097:        strcpy(mps->patterns[i], patterns[i]);
       12: 1098:        mps->pattern_lengths[i] = len;
       12: 1099:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1100:        
        -: 1101:        // Update first character lookup table
       12: 1102:        uint8_t first_char = (uint8_t)patterns[i][0];
       12: 1103:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1104:    }
        -: 1105:    
        -: 1106:    return mps;
        -: 1107:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1065:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1066:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1067:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1068:        return NULL;
        -: 1069:    }
        -: 1070:    
    #####: 1071:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1072:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1073:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1074:        return NULL;
        -: 1075:    }
        -: 1076:    
        -: 1077:    // Initialize structure
        -: 1078:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1079:    mps->pattern_count = count;
        -: 1080:    
        -: 1081:    // Copy patterns and build lookup tables
    #####: 1082:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1083:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1084:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1085:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1086:            return NULL;
        -: 1087:        }
        -: 1088:        
    #####: 1089:        size_t len = strlen(patterns[i]);
    #####: 1090:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1091:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1092:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1093:            return NULL;
        -: 1094:        }
        -: 1095:        
        -: 1096:        // Copy pattern
    #####: 1097:        strcpy(mps->patterns[i], patterns[i]);
    #####: 1098:        mps->pattern_lengths[i] = len;
    #####: 1099:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1100:        
        -: 1101:        // Update first character lookup table
    #####: 1102:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1103:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1104:    }
        -: 1105:    
        -: 1106:    return mps;
        -: 1107:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 2 returned 100% blocks executed 62%
        2: 1065:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
        2: 1066:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1067:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1068:        return NULL;
        -: 1069:    }
        -: 1070:    
        2: 1071:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 returned 100%
        2: 1072:    if (!mps) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1073:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1074:        return NULL;
        -: 1075:    }
        -: 1076:    
        -: 1077:    // Initialize structure
        -: 1078:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
        2: 1079:    mps->pattern_count = count;
        -: 1080:    
        -: 1081:    // Copy patterns and build lookup tables
       23: 1082:    for (size_t i = 0; i < count; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       21: 1083:        if (!patterns[i]) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1084:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1085:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1086:            return NULL;
        -: 1087:        }
        -: 1088:        
       21: 1089:        size_t len = strlen(patterns[i]);
       21: 1090:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1091:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1092:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1093:            return NULL;
        -: 1094:        }
        -: 1095:        
        -: 1096:        // Copy pattern
       21: 1097:        strcpy(mps->patterns[i], patterns[i]);
       21: 1098:        mps->pattern_lengths[i] = len;
       21: 1099:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1100:        
        -: 1101:        // Update first character lookup table
       21: 1102:        uint8_t first_char = (uint8_t)patterns[i][0];
       21: 1103:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1104:    }
        -: 1105:    
        -: 1106:    return mps;
        -: 1107:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1065:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1066:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1067:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1068:        return NULL;
        -: 1069:    }
        -: 1070:    
    #####: 1071:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1072:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1073:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1074:        return NULL;
        -: 1075:    }
        -: 1076:    
        -: 1077:    // Initialize structure
        -: 1078:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1079:    mps->pattern_count = count;
        -: 1080:    
        -: 1081:    // Copy patterns and build lookup tables
    #####: 1082:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1083:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1084:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1085:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1086:            return NULL;
        -: 1087:        }
        -: 1088:        
    #####: 1089:        size_t len = strlen(patterns[i]);
    #####: 1090:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1091:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1092:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1093:            return NULL;
        -: 1094:        }
        -: 1095:        
        -: 1096:        // Copy pattern
    #####: 1097:        strcpy(mps->patterns[i], patterns[i]);
    #####: 1098:        mps->pattern_lengths[i] = len;
    #####: 1099:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1100:        
        -: 1101:        // Update first character lookup table
    #####: 1102:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1103:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1104:    }
        -: 1105:    
        -: 1106:    return mps;
        -: 1107:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1065:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1066:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1067:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1068:        return NULL;
        -: 1069:    }
        -: 1070:    
    #####: 1071:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1072:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1073:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1074:        return NULL;
        -: 1075:    }
        -: 1076:    
        -: 1077:    // Initialize structure
        -: 1078:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1079:    mps->pattern_count = count;
        -: 1080:    
        -: 1081:    // Copy patterns and build lookup tables
    #####: 1082:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1083:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1084:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1085:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1086:            return NULL;
        -: 1087:        }
        -: 1088:        
    #####: 1089:        size_t len = strlen(patterns[i]);
    #####: 1090:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1091:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1092:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1093:            return NULL;
        -: 1094:        }
        -: 1095:        
        -: 1096:        // Copy pattern
    #####: 1097:        strcpy(mps->patterns[i], patterns[i]);
    #####: 1098:        mps->pattern_lengths[i] = len;
    #####: 1099:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1100:        
        -: 1101:        // Update first character lookup table
    #####: 1102:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1103:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1104:    }
        -: 1105:    
        -: 1106:    return mps;
        -: 1107:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1065:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1066:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1067:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1068:        return NULL;
        -: 1069:    }
        -: 1070:    
    #####: 1071:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1072:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1073:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1074:        return NULL;
        -: 1075:    }
        -: 1076:    
        -: 1077:    // Initialize structure
        -: 1078:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1079:    mps->pattern_count = count;
        -: 1080:    
        -: 1081:    // Copy patterns and build lookup tables
    #####: 1082:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1083:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1084:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1085:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1086:            return NULL;
        -: 1087:        }
        -: 1088:        
    #####: 1089:        size_t len = strlen(patterns[i]);
    #####: 1090:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1091:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1092:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1093:            return NULL;
        -: 1094:        }
        -: 1095:        
        -: 1096:        // Copy pattern
    #####: 1097:        strcpy(mps->patterns[i], patterns[i]);
    #####: 1098:        mps->pattern_lengths[i] = len;
    #####: 1099:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1100:        
        -: 1101:        // Update first character lookup table
    #####: 1102:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1103:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1104:    }
        -: 1105:    
        -: 1106:    return mps;
        -: 1107:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1065:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1066:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1067:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1068:        return NULL;
        -: 1069:    }
        -: 1070:    
    #####: 1071:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1072:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1073:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1074:        return NULL;
        -: 1075:    }
        -: 1076:    
        -: 1077:    // Initialize structure
        -: 1078:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1079:    mps->pattern_count = count;
        -: 1080:    
        -: 1081:    // Copy patterns and build lookup tables
    #####: 1082:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1083:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1084:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1085:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1086:            return NULL;
        -: 1087:        }
        -: 1088:        
    #####: 1089:        size_t len = strlen(patterns[i]);
    #####: 1090:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1091:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1092:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1093:            return NULL;
        -: 1094:        }
        -: 1095:        
        -: 1096:        // Copy pattern
    #####: 1097:        strcpy(mps->patterns[i], patterns[i]);
    #####: 1098:        mps->pattern_lengths[i] = len;
    #####: 1099:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1100:        
        -: 1101:        // Update first character lookup table
    #####: 1102:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1103:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1104:    }
        -: 1105:    
        -: 1106:    return mps;
        -: 1107:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1065:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1066:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1067:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1068:        return NULL;
        -: 1069:    }
        -: 1070:    
    #####: 1071:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1072:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1073:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1074:        return NULL;
        -: 1075:    }
        -: 1076:    
        -: 1077:    // Initialize structure
        -: 1078:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1079:    mps->pattern_count = count;
        -: 1080:    
        -: 1081:    // Copy patterns and build lookup tables
    #####: 1082:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1083:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1084:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1085:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1086:            return NULL;
        -: 1087:        }
        -: 1088:        
    #####: 1089:        size_t len = strlen(patterns[i]);
    #####: 1090:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1091:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1092:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1093:            return NULL;
        -: 1094:        }
        -: 1095:        
        -: 1096:        // Copy pattern
    #####: 1097:        strcpy(mps->patterns[i], patterns[i]);
    #####: 1098:        mps->pattern_lengths[i] = len;
    #####: 1099:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1100:        
        -: 1101:        // Update first character lookup table
    #####: 1102:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1103:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1104:    }
        -: 1105:    
        -: 1106:    return mps;
        -: 1107:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1065:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1066:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1067:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1068:        return NULL;
        -: 1069:    }
        -: 1070:    
    #####: 1071:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1072:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1073:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1074:        return NULL;
        -: 1075:    }
        -: 1076:    
        -: 1077:    // Initialize structure
        -: 1078:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1079:    mps->pattern_count = count;
        -: 1080:    
        -: 1081:    // Copy patterns and build lookup tables
    #####: 1082:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1083:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1084:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1085:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1086:            return NULL;
        -: 1087:        }
        -: 1088:        
    #####: 1089:        size_t len = strlen(patterns[i]);
    #####: 1090:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1091:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1092:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1093:            return NULL;
        -: 1094:        }
        -: 1095:        
        -: 1096:        // Copy pattern
    #####: 1097:        strcpy(mps->patterns[i], patterns[i]);
    #####: 1098:        mps->pattern_lengths[i] = len;
    #####: 1099:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1100:        
        -: 1101:        // Update first character lookup table
    #####: 1102:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1103:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1104:    }
        -: 1105:    
        -: 1106:    return mps;
        -: 1107:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1065:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1066:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1067:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1068:        return NULL;
        -: 1069:    }
        -: 1070:    
    #####: 1071:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1072:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1073:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1074:        return NULL;
        -: 1075:    }
        -: 1076:    
        -: 1077:    // Initialize structure
        -: 1078:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1079:    mps->pattern_count = count;
        -: 1080:    
        -: 1081:    // Copy patterns and build lookup tables
    #####: 1082:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1083:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1084:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1085:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1086:            return NULL;
        -: 1087:        }
        -: 1088:        
    #####: 1089:        size_t len = strlen(patterns[i]);
    #####: 1090:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1091:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1092:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1093:            return NULL;
        -: 1094:        }
        -: 1095:        
        -: 1096:        // Copy pattern
    #####: 1097:        strcpy(mps->patterns[i], patterns[i]);
    #####: 1098:        mps->pattern_lengths[i] = len;
    #####: 1099:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1100:        
        -: 1101:        // Update first character lookup table
    #####: 1102:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1103:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1104:    }
        -: 1105:    
        -: 1106:    return mps;
        -: 1107:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1065:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1066:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1067:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1068:        return NULL;
        -: 1069:    }
        -: 1070:    
    #####: 1071:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1072:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1073:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1074:        return NULL;
        -: 1075:    }
        -: 1076:    
        -: 1077:    // Initialize structure
        -: 1078:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1079:    mps->pattern_count = count;
        -: 1080:    
        -: 1081:    // Copy patterns and build lookup tables
    #####: 1082:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1083:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1084:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1085:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1086:            return NULL;
        -: 1087:        }
        -: 1088:        
    #####: 1089:        size_t len = strlen(patterns[i]);
    #####: 1090:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1091:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1092:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1093:            return NULL;
        -: 1094:        }
        -: 1095:        
        -: 1096:        // Copy pattern
    #####: 1097:        strcpy(mps->patterns[i], patterns[i]);
    #####: 1098:        mps->pattern_lengths[i] = len;
    #####: 1099:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1100:        
        -: 1101:        // Update first character lookup table
    #####: 1102:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1103:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1104:    }
        -: 1105:    
        -: 1106:    return mps;
        -: 1107:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1065:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1066:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1067:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1068:        return NULL;
        -: 1069:    }
        -: 1070:    
    #####: 1071:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1072:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1073:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1074:        return NULL;
        -: 1075:    }
        -: 1076:    
        -: 1077:    // Initialize structure
        -: 1078:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1079:    mps->pattern_count = count;
        -: 1080:    
        -: 1081:    // Copy patterns and build lookup tables
    #####: 1082:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1083:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1084:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1085:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1086:            return NULL;
        -: 1087:        }
        -: 1088:        
    #####: 1089:        size_t len = strlen(patterns[i]);
    #####: 1090:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1091:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1092:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1093:            return NULL;
        -: 1094:        }
        -: 1095:        
        -: 1096:        // Copy pattern
    #####: 1097:        strcpy(mps->patterns[i], patterns[i]);
    #####: 1098:        mps->pattern_lengths[i] = len;
    #####: 1099:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1100:        
        -: 1101:        // Update first character lookup table
    #####: 1102:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1103:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1104:    }
        -: 1105:    
        -: 1106:    return mps;
        -: 1107:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1065:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1066:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1067:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1068:        return NULL;
        -: 1069:    }
        -: 1070:    
    #####: 1071:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1072:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1073:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1074:        return NULL;
        -: 1075:    }
        -: 1076:    
        -: 1077:    // Initialize structure
        -: 1078:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1079:    mps->pattern_count = count;
        -: 1080:    
        -: 1081:    // Copy patterns and build lookup tables
    #####: 1082:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1083:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1084:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1085:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1086:            return NULL;
        -: 1087:        }
        -: 1088:        
    #####: 1089:        size_t len = strlen(patterns[i]);
    #####: 1090:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1091:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1092:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1093:            return NULL;
        -: 1094:        }
        -: 1095:        
        -: 1096:        // Copy pattern
    #####: 1097:        strcpy(mps->patterns[i], patterns[i]);
    #####: 1098:        mps->pattern_lengths[i] = len;
    #####: 1099:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1100:        
        -: 1101:        // Update first character lookup table
    #####: 1102:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1103:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1104:    }
        -: 1105:    
        -: 1106:    return mps;
        -: 1107:}
------------------
        -: 1108:
       5*: 1109:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
       5*: 1110:    if (mps) {
       5*: 1111:        mercury_aligned_free(mps);
        -: 1112:    }
       5*: 1113:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1109:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1110:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1111:        mercury_aligned_free(mps);
call    0 never executed
        -: 1112:    }
    #####: 1113:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 3 returned 100% blocks executed 100%
        3: 1109:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
        3: 1110:    if (mps) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3: 1111:        mercury_aligned_free(mps);
call    0 returned 100%
        -: 1112:    }
        3: 1113:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1109:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1110:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1111:        mercury_aligned_free(mps);
call    0 never executed
        -: 1112:    }
    #####: 1113:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 2 returned 100% blocks executed 100%
        2: 1109:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
        2: 1110:    if (mps) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2: 1111:        mercury_aligned_free(mps);
call    0 returned 100%
        -: 1112:    }
        2: 1113:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1109:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1110:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1111:        mercury_aligned_free(mps);
call    0 never executed
        -: 1112:    }
    #####: 1113:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1109:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1110:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1111:        mercury_aligned_free(mps);
call    0 never executed
        -: 1112:    }
    #####: 1113:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1109:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1110:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1111:        mercury_aligned_free(mps);
call    0 never executed
        -: 1112:    }
    #####: 1113:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1109:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1110:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1111:        mercury_aligned_free(mps);
call    0 never executed
        -: 1112:    }
    #####: 1113:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1109:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1110:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1111:        mercury_aligned_free(mps);
call    0 never executed
        -: 1112:    }
    #####: 1113:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1109:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1110:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1111:        mercury_aligned_free(mps);
call    0 never executed
        -: 1112:    }
    #####: 1113:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1109:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1110:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1111:        mercury_aligned_free(mps);
call    0 never executed
        -: 1112:    }
    #####: 1113:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1109:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1110:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1111:        mercury_aligned_free(mps);
call    0 never executed
        -: 1112:    }
    #####: 1113:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1109:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1110:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1111:        mercury_aligned_free(mps);
call    0 never executed
        -: 1112:    }
    #####: 1113:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1109:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1110:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1111:        mercury_aligned_free(mps);
call    0 never executed
        -: 1112:    }
    #####: 1113:}
------------------
        -: 1114:
       6*: 1115:int mercury_multi_pattern_search_simd(const MercuryMultiPatternSearch* mps, const char* text, 
        -: 1116:                                     size_t text_len, int* pattern_id) {
       6*: 1117:    if (!mps || !text || !pattern_id || text_len == 0) {
        -: 1118:        return -1;
        -: 1119:    }
        -: 1120:    
       6*: 1121:    *pattern_id = -1;
        -: 1122:    
        -: 1123:    // Smart multi-pattern search using optimized strstr
        -: 1124:    // Find the leftmost match across all patterns
        -: 1125:    int best_position = -1;
        -: 1126:    int best_pattern = -1;
        -: 1127:    
        -: 1128:    // Use highly optimized strstr for each pattern
      45*: 1129:    for (size_t p = 0; p < mps->pattern_count; p++) {
      39*: 1130:        const char* found = strstr(text, mps->patterns[p]);
        -: 1131:        
      39*: 1132:        if (found) {
      20*: 1133:            int pos = (int)(found - text);
      20*: 1134:            if (best_position == -1 || pos < best_position) {
        -: 1135:                best_position = pos;
       6*: 1136:                best_pattern = (int)p;
        -: 1137:            }
        -: 1138:        }
        -: 1139:    }
        -: 1140:    
       6*: 1141:    if (best_position >= 0) {
       5*: 1142:        *pattern_id = best_pattern;
       5*: 1143:        return best_position;
        -: 1144:    }
        -: 1145:    
        -: 1146:    return -1;  // No patterns found
        -: 1147:}
        -: 1148:
        -: 1149:#else
        -: 1150:// Fallback implementations when SIMD is not available
        -: 1151:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
        -: 1152:    memcpy(dest, src, size);
        -: 1153:}
        -: 1154:
        -: 1155:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
        -: 1156:    const char* found = strstr(text, pattern);
        -: 1157:    return found ? (int)(found - text) : -1;
        -: 1158:}
        -: 1159:
        -: 1160:// Multi-pattern search fallback implementation
        -: 1161:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
        -: 1162:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
        -: 1163:        return NULL;
        -: 1164:    }
        -: 1165:    
        -: 1166:    MercuryMultiPatternSearch* mps = malloc(sizeof(MercuryMultiPatternSearch));
        -: 1167:    if (!mps) return NULL;
        -: 1168:    
        -: 1169:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
        -: 1170:    mps->pattern_count = count;
        -: 1171:    
        -: 1172:    for (size_t i = 0; i < count; i++) {
        -: 1173:        if (!patterns[i]) {
        -: 1174:            free(mps);
        -: 1175:            return NULL;
        -: 1176:        }
        -: 1177:        
        -: 1178:        size_t len = strlen(patterns[i]);
        -: 1179:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
        -: 1180:            free(mps);
        -: 1181:            return NULL;
        -: 1182:        }
        -: 1183:        
        -: 1184:        strcpy(mps->patterns[i], patterns[i]);
        -: 1185:        mps->pattern_lengths[i] = len;
        -: 1186:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1187:        
        -: 1188:        uint8_t first_char = (uint8_t)patterns[i][0];
        -: 1189:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1190:    }
        -: 1191:    
        -: 1192:    return mps;
        -: 1193:}
        -: 1194:
        -: 1195:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
        -: 1196:    if (mps) {
        -: 1197:        free(mps);
        -: 1198:    }
        -: 1199:}
        -: 1200:
        -: 1201:int mercury_multi_pattern_search_simd(const MercuryMultiPatternSearch* mps, const char* text, 
        -: 1202:                                     size_t text_len, int* pattern_id) {
        -: 1203:    if (!mps || !text || !pattern_id || text_len == 0) {
        -: 1204:        return -1;
        -: 1205:    }
        -: 1206:    
        -: 1207:    *pattern_id = -1;
        -: 1208:    
        -: 1209:    // Fallback using optimized strstr
        -: 1210:    int best_position = -1;
        -: 1211:    int best_pattern = -1;
        -: 1212:    
        -: 1213:    for (size_t p = 0; p < mps->pattern_count; p++) {
        -: 1214:        const char* found = strstr(text, mps->patterns[p]);
        -: 1215:        
        -: 1216:        if (found) {
        -: 1217:            int pos = (int)(found - text);
        -: 1218:            if (best_position == -1 || pos < best_position) {
        -: 1219:                best_position = pos;
        -: 1220:                best_pattern = (int)p;
        -: 1221:            }
        -: 1222:        }
        -: 1223:    }
        -: 1224:    
        -: 1225:    if (best_position >= 0) {
        -: 1226:        *pattern_id = best_pattern;
        -: 1227:        return best_position;
        -: 1228:    }
        -: 1229:    
        -: 1230:    return -1;  // No patterns found
        -: 1231:}
        -: 1232:#endif

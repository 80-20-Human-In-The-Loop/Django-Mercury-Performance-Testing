        -:    0:Source:common.c
        -:    0:Source is newer than graph
        -:    1:/**
        -:    2: * @file common.c
        -:    3: * @brief Implementation of shared utilities for Mercury Performance Testing Framework
        -:    4: * 
        -:    5: * @details This file implements the common data structures and utility functions declared in common.h.
        -:    6: * It provides cross-platform compatibility and high-performance implementations for:
        -:    7: * - Memory management and ring buffers
        -:    8: * - String operations and Boyer-Moore pattern matching
        -:    9: * - Timing utilities and RDTSC calibration
        -:   10: * - SIMD-accelerated operations
        -:   11: * - Error handling and logging
        -:   12: *
        -:   13: * @author Django Mercury Team
        -:   14: * @date 2024
        -:   15: * @version 2.0.0
        -:   16: * 
        -:   17: * @warning Thread safety varies by function - see individual function documentation
        -:   18: * @note All memory allocation functions return NULL on failure
        -:   19: */
        -:   20:
        -:   21:/* Define feature test macros BEFORE any includes */
        -:   22:#ifndef _GNU_SOURCE
        -:   23:#define _GNU_SOURCE
        -:   24:#endif
        -:   25:#ifndef _POSIX_C_SOURCE
        -:   26:#define _POSIX_C_SOURCE 200809L
        -:   27:#endif
        -:   28:
        -:   29:#include "common.h"
        -:   30:#include <assert.h>
        -:   31:#include <stdarg.h>
        -:   32:
        -:   33:#ifdef MERCURY_LINUX
        -:   34:#include <time.h>
        -:   35:#endif
        -:   36:
        -:   37:// === GLOBAL VARIABLES ===
        -:   38:
        -:   39:// RDTSC frequency for timing calibration
        -:   40:#ifdef MERCURY_X86_64
        -:   41:uint64_t mercury_rdtsc_frequency = 0;
        -:   42:#endif
        -:   43:
        -:   44:// Global error context (removed thread-local for PIC compatibility)
        -:   45:// Note: Thread-local storage is incompatible with Position Independent Code
        -:   46:// required for shared libraries. Using global error context instead.
        -:   47:MercuryErrorContext mercury_last_error = {MERCURY_SUCCESS, {0}, NULL, NULL, 0};
        -:   48:
        -:   49:// Default logger function pointer
        -:   50:void (*mercury_log_function)(MercuryLogLevel level, const char* format, ...) = mercury_default_logger;
        -:   51:
        -:   52:// === TIMING UTILITIES ===
        -:   53:
        -:   54:#ifdef MERCURY_X86_64
        -:   55:/**
        -:   56: * @brief Calibrate RDTSC frequency for high-precision timing
        -:   57: * 
        -:   58: * @details Calibrates the RDTSC (Read Time-Stamp Counter) against the system clock
        -:   59: * to enable accurate nanosecond-level timing measurements. This calibration is
        -:   60: * performed once and cached for the lifetime of the program.
        -:   61: * 
        -:   62: * @pre MERCURY_X86_64 must be defined
        -:   63: * @post mercury_rdtsc_frequency is set to calibrated value
        -:   64: * 
        -:   65: * @warning Not thread-safe - should be called once at initialization
        -:   66: * @note Falls back to frequency=1 if calibration fails
        -:   67: */
      29*:   68:void mercury_calibrate_rdtsc(void) {
      29*:   69:    if (mercury_rdtsc_frequency != 0) {
       4*:   70:        return;  // Already calibrated
        -:   71:    }
        -:   72:    
        -:   73:    // Calibrate RDTSC against system clock
      25*:   74:    MercuryTimestamp start_sys = mercury_get_timestamp();
        -:   75:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   76:    
        -:   77:    // Wait approximately 100ms
        -:   78:    #ifdef MERCURY_LINUX
      25*:   79:        struct timespec sleep_time = {0, 100000000};  // 100ms
      25*:   80:        nanosleep(&sleep_time, NULL);
        -:   81:    #elif defined(MERCURY_MACOS)
        -:   82:        usleep(100000);  // 100ms
        -:   83:    #elif defined(MERCURY_WINDOWS)
        -:   84:        Sleep(100);  // 100ms
        -:   85:    #endif
        -:   86:    
      25*:   87:    MercuryTimestamp end_sys = mercury_get_timestamp();
        -:   88:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   89:    
      25*:   90:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
      25*:   91:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   92:    
      25*:   93:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
      25*:   94:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
      25*:   95:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
        -:   96:    } else {
    #####:   97:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
    #####:   98:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   99:    }
        -:  100:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   68:void mercury_calibrate_rdtsc(void) {
    #####:   69:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   70:        return;  // Already calibrated
        -:   71:    }
        -:   72:    
        -:   73:    // Calibrate RDTSC against system clock
    #####:   74:    MercuryTimestamp start_sys = mercury_get_timestamp();
call    0 never executed
        -:   75:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   76:    
        -:   77:    // Wait approximately 100ms
        -:   78:    #ifdef MERCURY_LINUX
    #####:   79:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   80:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   81:    #elif defined(MERCURY_MACOS)
        -:   82:        usleep(100000);  // 100ms
        -:   83:    #elif defined(MERCURY_WINDOWS)
        -:   84:        Sleep(100);  // 100ms
        -:   85:    #endif
        -:   86:    
    #####:   87:    MercuryTimestamp end_sys = mercury_get_timestamp();
call    0 never executed
        -:   88:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   89:    
    #####:   90:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   91:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   92:    
    #####:   93:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   94:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   95:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   96:    } else {
    #####:   97:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   98:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   99:    }
        -:  100:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 6 returned 100% blocks executed 80%
        6:   68:void mercury_calibrate_rdtsc(void) {
        6:   69:    if (mercury_rdtsc_frequency != 0) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        4:   70:        return;  // Already calibrated
        -:   71:    }
        -:   72:    
        -:   73:    // Calibrate RDTSC against system clock
        2:   74:    MercuryTimestamp start_sys = mercury_get_timestamp();
call    0 returned 100%
        -:   75:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   76:    
        -:   77:    // Wait approximately 100ms
        -:   78:    #ifdef MERCURY_LINUX
        2:   79:        struct timespec sleep_time = {0, 100000000};  // 100ms
        2:   80:        nanosleep(&sleep_time, NULL);
call    0 returned 100%
        -:   81:    #elif defined(MERCURY_MACOS)
        -:   82:        usleep(100000);  // 100ms
        -:   83:    #elif defined(MERCURY_WINDOWS)
        -:   84:        Sleep(100);  // 100ms
        -:   85:    #endif
        -:   86:    
        2:   87:    MercuryTimestamp end_sys = mercury_get_timestamp();
call    0 returned 100%
        -:   88:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   89:    
        2:   90:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
        2:   91:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   92:    
        2:   93:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:   94:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
        2:   95:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:   96:    } else {
    #####:   97:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   98:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   99:    }
        -:  100:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 22 returned 100% blocks executed 73%
       22:   68:void mercury_calibrate_rdtsc(void) {
       22:   69:    if (mercury_rdtsc_frequency != 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   70:        return;  // Already calibrated
        -:   71:    }
        -:   72:    
        -:   73:    // Calibrate RDTSC against system clock
       22:   74:    MercuryTimestamp start_sys = mercury_get_timestamp();
call    0 returned 100%
        -:   75:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   76:    
        -:   77:    // Wait approximately 100ms
        -:   78:    #ifdef MERCURY_LINUX
       22:   79:        struct timespec sleep_time = {0, 100000000};  // 100ms
       22:   80:        nanosleep(&sleep_time, NULL);
call    0 returned 100%
        -:   81:    #elif defined(MERCURY_MACOS)
        -:   82:        usleep(100000);  // 100ms
        -:   83:    #elif defined(MERCURY_WINDOWS)
        -:   84:        Sleep(100);  // 100ms
        -:   85:    #endif
        -:   86:    
       22:   87:    MercuryTimestamp end_sys = mercury_get_timestamp();
call    0 returned 100%
        -:   88:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   89:    
       22:   90:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
       22:   91:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   92:    
       22:   93:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       22:   94:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
       22:   95:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:   96:    } else {
    #####:   97:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   98:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   99:    }
        -:  100:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   68:void mercury_calibrate_rdtsc(void) {
    #####:   69:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   70:        return;  // Already calibrated
        -:   71:    }
        -:   72:    
        -:   73:    // Calibrate RDTSC against system clock
    #####:   74:    MercuryTimestamp start_sys = mercury_get_timestamp();
call    0 never executed
        -:   75:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   76:    
        -:   77:    // Wait approximately 100ms
        -:   78:    #ifdef MERCURY_LINUX
    #####:   79:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   80:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   81:    #elif defined(MERCURY_MACOS)
        -:   82:        usleep(100000);  // 100ms
        -:   83:    #elif defined(MERCURY_WINDOWS)
        -:   84:        Sleep(100);  // 100ms
        -:   85:    #endif
        -:   86:    
    #####:   87:    MercuryTimestamp end_sys = mercury_get_timestamp();
call    0 never executed
        -:   88:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   89:    
    #####:   90:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   91:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   92:    
    #####:   93:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   94:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   95:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   96:    } else {
    #####:   97:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   98:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   99:    }
        -:  100:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   68:void mercury_calibrate_rdtsc(void) {
    #####:   69:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   70:        return;  // Already calibrated
        -:   71:    }
        -:   72:    
        -:   73:    // Calibrate RDTSC against system clock
    #####:   74:    MercuryTimestamp start_sys = mercury_get_timestamp();
call    0 never executed
        -:   75:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   76:    
        -:   77:    // Wait approximately 100ms
        -:   78:    #ifdef MERCURY_LINUX
    #####:   79:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   80:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   81:    #elif defined(MERCURY_MACOS)
        -:   82:        usleep(100000);  // 100ms
        -:   83:    #elif defined(MERCURY_WINDOWS)
        -:   84:        Sleep(100);  // 100ms
        -:   85:    #endif
        -:   86:    
    #####:   87:    MercuryTimestamp end_sys = mercury_get_timestamp();
call    0 never executed
        -:   88:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   89:    
    #####:   90:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   91:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   92:    
    #####:   93:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   94:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   95:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   96:    } else {
    #####:   97:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   98:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   99:    }
        -:  100:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 1 returned 100% blocks executed 73%
        1:   68:void mercury_calibrate_rdtsc(void) {
        1:   69:    if (mercury_rdtsc_frequency != 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   70:        return;  // Already calibrated
        -:   71:    }
        -:   72:    
        -:   73:    // Calibrate RDTSC against system clock
        1:   74:    MercuryTimestamp start_sys = mercury_get_timestamp();
call    0 returned 100%
        -:   75:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   76:    
        -:   77:    // Wait approximately 100ms
        -:   78:    #ifdef MERCURY_LINUX
        1:   79:        struct timespec sleep_time = {0, 100000000};  // 100ms
        1:   80:        nanosleep(&sleep_time, NULL);
call    0 returned 100%
        -:   81:    #elif defined(MERCURY_MACOS)
        -:   82:        usleep(100000);  // 100ms
        -:   83:    #elif defined(MERCURY_WINDOWS)
        -:   84:        Sleep(100);  // 100ms
        -:   85:    #endif
        -:   86:    
        1:   87:    MercuryTimestamp end_sys = mercury_get_timestamp();
call    0 returned 100%
        -:   88:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   89:    
        1:   90:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
        1:   91:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   92:    
        1:   93:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:   94:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
        1:   95:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:   96:    } else {
    #####:   97:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   98:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   99:    }
        -:  100:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   68:void mercury_calibrate_rdtsc(void) {
    #####:   69:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   70:        return;  // Already calibrated
        -:   71:    }
        -:   72:    
        -:   73:    // Calibrate RDTSC against system clock
    #####:   74:    MercuryTimestamp start_sys = mercury_get_timestamp();
call    0 never executed
        -:   75:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   76:    
        -:   77:    // Wait approximately 100ms
        -:   78:    #ifdef MERCURY_LINUX
    #####:   79:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   80:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   81:    #elif defined(MERCURY_MACOS)
        -:   82:        usleep(100000);  // 100ms
        -:   83:    #elif defined(MERCURY_WINDOWS)
        -:   84:        Sleep(100);  // 100ms
        -:   85:    #endif
        -:   86:    
    #####:   87:    MercuryTimestamp end_sys = mercury_get_timestamp();
call    0 never executed
        -:   88:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   89:    
    #####:   90:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   91:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   92:    
    #####:   93:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   94:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   95:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   96:    } else {
    #####:   97:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   98:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   99:    }
        -:  100:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   68:void mercury_calibrate_rdtsc(void) {
    #####:   69:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   70:        return;  // Already calibrated
        -:   71:    }
        -:   72:    
        -:   73:    // Calibrate RDTSC against system clock
    #####:   74:    MercuryTimestamp start_sys = mercury_get_timestamp();
call    0 never executed
        -:   75:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   76:    
        -:   77:    // Wait approximately 100ms
        -:   78:    #ifdef MERCURY_LINUX
    #####:   79:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   80:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   81:    #elif defined(MERCURY_MACOS)
        -:   82:        usleep(100000);  // 100ms
        -:   83:    #elif defined(MERCURY_WINDOWS)
        -:   84:        Sleep(100);  // 100ms
        -:   85:    #endif
        -:   86:    
    #####:   87:    MercuryTimestamp end_sys = mercury_get_timestamp();
call    0 never executed
        -:   88:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   89:    
    #####:   90:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   91:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   92:    
    #####:   93:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   94:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   95:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   96:    } else {
    #####:   97:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   98:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   99:    }
        -:  100:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   68:void mercury_calibrate_rdtsc(void) {
    #####:   69:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   70:        return;  // Already calibrated
        -:   71:    }
        -:   72:    
        -:   73:    // Calibrate RDTSC against system clock
    #####:   74:    MercuryTimestamp start_sys = mercury_get_timestamp();
call    0 never executed
        -:   75:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   76:    
        -:   77:    // Wait approximately 100ms
        -:   78:    #ifdef MERCURY_LINUX
    #####:   79:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   80:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   81:    #elif defined(MERCURY_MACOS)
        -:   82:        usleep(100000);  // 100ms
        -:   83:    #elif defined(MERCURY_WINDOWS)
        -:   84:        Sleep(100);  // 100ms
        -:   85:    #endif
        -:   86:    
    #####:   87:    MercuryTimestamp end_sys = mercury_get_timestamp();
call    0 never executed
        -:   88:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   89:    
    #####:   90:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   91:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   92:    
    #####:   93:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   94:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   95:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   96:    } else {
    #####:   97:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   98:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   99:    }
        -:  100:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   68:void mercury_calibrate_rdtsc(void) {
    #####:   69:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   70:        return;  // Already calibrated
        -:   71:    }
        -:   72:    
        -:   73:    // Calibrate RDTSC against system clock
    #####:   74:    MercuryTimestamp start_sys = mercury_get_timestamp();
call    0 never executed
        -:   75:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   76:    
        -:   77:    // Wait approximately 100ms
        -:   78:    #ifdef MERCURY_LINUX
    #####:   79:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   80:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   81:    #elif defined(MERCURY_MACOS)
        -:   82:        usleep(100000);  // 100ms
        -:   83:    #elif defined(MERCURY_WINDOWS)
        -:   84:        Sleep(100);  // 100ms
        -:   85:    #endif
        -:   86:    
    #####:   87:    MercuryTimestamp end_sys = mercury_get_timestamp();
call    0 never executed
        -:   88:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   89:    
    #####:   90:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   91:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   92:    
    #####:   93:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   94:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   95:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   96:    } else {
    #####:   97:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   98:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   99:    }
        -:  100:}
------------------
mercury_calibrate_rdtsc:
function mercury_calibrate_rdtsc called 0 returned 0% blocks executed 0%
    #####:   68:void mercury_calibrate_rdtsc(void) {
    #####:   69:    if (mercury_rdtsc_frequency != 0) {
branch  0 never executed
branch  1 never executed
    #####:   70:        return;  // Already calibrated
        -:   71:    }
        -:   72:    
        -:   73:    // Calibrate RDTSC against system clock
    #####:   74:    MercuryTimestamp start_sys = mercury_get_timestamp();
call    0 never executed
        -:   75:    uint64_t start_rdtsc = mercury_rdtsc();
        -:   76:    
        -:   77:    // Wait approximately 100ms
        -:   78:    #ifdef MERCURY_LINUX
    #####:   79:        struct timespec sleep_time = {0, 100000000};  // 100ms
    #####:   80:        nanosleep(&sleep_time, NULL);
call    0 never executed
        -:   81:    #elif defined(MERCURY_MACOS)
        -:   82:        usleep(100000);  // 100ms
        -:   83:    #elif defined(MERCURY_WINDOWS)
        -:   84:        Sleep(100);  // 100ms
        -:   85:    #endif
        -:   86:    
    #####:   87:    MercuryTimestamp end_sys = mercury_get_timestamp();
call    0 never executed
        -:   88:    uint64_t end_rdtsc = mercury_rdtsc();
        -:   89:    
    #####:   90:    uint64_t sys_elapsed = end_sys.nanoseconds - start_sys.nanoseconds;
    #####:   91:    uint64_t rdtsc_elapsed = end_rdtsc - start_rdtsc;
        -:   92:    
    #####:   93:    if (sys_elapsed > 0 && rdtsc_elapsed > 0) {
branch  0 never executed
branch  1 never executed
    #####:   94:        mercury_rdtsc_frequency = (rdtsc_elapsed * 1000000000ULL) / sys_elapsed;
    #####:   95:        MERCURY_INFO("RDTSC calibrated: %llu Hz", mercury_rdtsc_frequency);
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:   96:    } else {
    #####:   97:        MERCURY_WARN("RDTSC calibration failed, using fallback timing");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:   98:        mercury_rdtsc_frequency = 1;  // Fallback to prevent division by zero
        -:   99:    }
        -:  100:}
------------------
        -:  101:#endif
        -:  102:
        -:  103:// === MEMORY UTILITIES ===
        -:  104:
        -:  105:/**
        -:  106: * @brief Allocate aligned memory for optimal performance
        -:  107: * 
        -:  108: * @details Allocates memory with specified alignment for cache-line optimization
        -:  109: * and SIMD operations. Uses platform-specific functions when available.
        -:  110: * 
        -:  111: * @param size Size in bytes to allocate
        -:  112: * @param alignment Required alignment (must be power of 2)
        -:  113: * @return Pointer to aligned memory or NULL on failure
        -:  114: * 
        -:  115: * @pre alignment must be a power of 2
        -:  116: * @post Memory is aligned to specified boundary
        -:  117: * 
        -:  118: * @warning Caller must free with mercury_aligned_free()
        -:  119: * @note Sets error context on failure
        -:  120: */
  105413*:  121:void* mercury_aligned_alloc(size_t size, size_t alignment) {
  105413*:  122:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
      10*:  123:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
      10*:  124:        return NULL;
        -:  125:    }
        -:  126:    
  105403*:  127:    void* ptr = NULL;
        -:  128:    
        -:  129:#ifdef MERCURY_LINUX
  105403*:  130:    if (posix_memalign(&ptr, alignment, size) != 0) {
       3*:  131:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
       3*:  132:        return NULL;
        -:  133:    }
        -:  134:#elif defined(MERCURY_MACOS)
        -:  135:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  136:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  137:        return NULL;
        -:  138:    }
        -:  139:#elif defined(MERCURY_WINDOWS)
        -:  140:    ptr = _aligned_malloc(size, alignment);
        -:  141:    if (!ptr) {
        -:  142:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  143:        return NULL;
        -:  144:    }
        -:  145:#else
        -:  146:    // Fallback: allocate extra space and align manually
        -:  147:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  148:    if (!raw_ptr) {
        -:  149:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  150:        return NULL;
        -:  151:    }
        -:  152:    
        -:  153:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  154:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  155:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  156:    ptr = aligned_ptr;
        -:  157:#endif
        -:  158:    
  105400*:  159:    return ptr;
        -:  160:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 100002 returned 100% blocks executed 75%
   100002:  121:void* mercury_aligned_alloc(size_t size, size_t alignment) {
   100002:  122:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  123:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:  124:        return NULL;
        -:  125:    }
        -:  126:    
   100002:  127:    void* ptr = NULL;
        -:  128:    
        -:  129:#ifdef MERCURY_LINUX
   100002:  130:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  131:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  132:        return NULL;
        -:  133:    }
        -:  134:#elif defined(MERCURY_MACOS)
        -:  135:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  136:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  137:        return NULL;
        -:  138:    }
        -:  139:#elif defined(MERCURY_WINDOWS)
        -:  140:    ptr = _aligned_malloc(size, alignment);
        -:  141:    if (!ptr) {
        -:  142:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  143:        return NULL;
        -:  144:    }
        -:  145:#else
        -:  146:    // Fallback: allocate extra space and align manually
        -:  147:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  148:    if (!raw_ptr) {
        -:  149:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  150:        return NULL;
        -:  151:    }
        -:  152:    
        -:  153:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  154:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  155:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  156:    ptr = aligned_ptr;
        -:  157:#endif
        -:  158:    
   100002:  159:    return ptr;
        -:  160:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 139 returned 100% blocks executed 100%
      139:  121:void* mercury_aligned_alloc(size_t size, size_t alignment) {
      139:  122:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
branch  2 taken 2% (fallthrough)
branch  3 taken 98%
        7:  123:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
        7:  124:        return NULL;
        -:  125:    }
        -:  126:    
      132:  127:    void* ptr = NULL;
        -:  128:    
        -:  129:#ifdef MERCURY_LINUX
      132:  130:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 2% (fallthrough)
branch  2 taken 98%
        2:  131:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        2:  132:        return NULL;
        -:  133:    }
        -:  134:#elif defined(MERCURY_MACOS)
        -:  135:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  136:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  137:        return NULL;
        -:  138:    }
        -:  139:#elif defined(MERCURY_WINDOWS)
        -:  140:    ptr = _aligned_malloc(size, alignment);
        -:  141:    if (!ptr) {
        -:  142:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  143:        return NULL;
        -:  144:    }
        -:  145:#else
        -:  146:    // Fallback: allocate extra space and align manually
        -:  147:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  148:    if (!raw_ptr) {
        -:  149:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  150:        return NULL;
        -:  151:    }
        -:  152:    
        -:  153:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  154:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  155:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  156:    ptr = aligned_ptr;
        -:  157:#endif
        -:  158:    
      130:  159:    return ptr;
        -:  160:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 116 returned 100% blocks executed 100%
      116:  121:void* mercury_aligned_alloc(size_t size, size_t alignment) {
      116:  122:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
branch  2 taken 1% (fallthrough)
branch  3 taken 99%
        3:  123:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
        3:  124:        return NULL;
        -:  125:    }
        -:  126:    
      113:  127:    void* ptr = NULL;
        -:  128:    
        -:  129:#ifdef MERCURY_LINUX
      113:  130:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        1:  131:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        1:  132:        return NULL;
        -:  133:    }
        -:  134:#elif defined(MERCURY_MACOS)
        -:  135:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  136:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  137:        return NULL;
        -:  138:    }
        -:  139:#elif defined(MERCURY_WINDOWS)
        -:  140:    ptr = _aligned_malloc(size, alignment);
        -:  141:    if (!ptr) {
        -:  142:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  143:        return NULL;
        -:  144:    }
        -:  145:#else
        -:  146:    // Fallback: allocate extra space and align manually
        -:  147:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  148:    if (!raw_ptr) {
        -:  149:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  150:        return NULL;
        -:  151:    }
        -:  152:    
        -:  153:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  154:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  155:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  156:    ptr = aligned_ptr;
        -:  157:#endif
        -:  158:    
      112:  159:    return ptr;
        -:  160:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 19 returned 100% blocks executed 75%
       19:  121:void* mercury_aligned_alloc(size_t size, size_t alignment) {
       19:  122:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  123:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:  124:        return NULL;
        -:  125:    }
        -:  126:    
       19:  127:    void* ptr = NULL;
        -:  128:    
        -:  129:#ifdef MERCURY_LINUX
       19:  130:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  131:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  132:        return NULL;
        -:  133:    }
        -:  134:#elif defined(MERCURY_MACOS)
        -:  135:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  136:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  137:        return NULL;
        -:  138:    }
        -:  139:#elif defined(MERCURY_WINDOWS)
        -:  140:    ptr = _aligned_malloc(size, alignment);
        -:  141:    if (!ptr) {
        -:  142:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  143:        return NULL;
        -:  144:    }
        -:  145:#else
        -:  146:    // Fallback: allocate extra space and align manually
        -:  147:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  148:    if (!raw_ptr) {
        -:  149:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  150:        return NULL;
        -:  151:    }
        -:  152:    
        -:  153:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  154:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  155:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  156:    ptr = aligned_ptr;
        -:  157:#endif
        -:  158:    
       19:  159:    return ptr;
        -:  160:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 0 returned 0% blocks executed 0%
    #####:  121:void* mercury_aligned_alloc(size_t size, size_t alignment) {
    #####:  122:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  123:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:  124:        return NULL;
        -:  125:    }
        -:  126:    
    #####:  127:    void* ptr = NULL;
        -:  128:    
        -:  129:#ifdef MERCURY_LINUX
    #####:  130:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  131:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  132:        return NULL;
        -:  133:    }
        -:  134:#elif defined(MERCURY_MACOS)
        -:  135:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  136:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  137:        return NULL;
        -:  138:    }
        -:  139:#elif defined(MERCURY_WINDOWS)
        -:  140:    ptr = _aligned_malloc(size, alignment);
        -:  141:    if (!ptr) {
        -:  142:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  143:        return NULL;
        -:  144:    }
        -:  145:#else
        -:  146:    // Fallback: allocate extra space and align manually
        -:  147:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  148:    if (!raw_ptr) {
        -:  149:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  150:        return NULL;
        -:  151:    }
        -:  152:    
        -:  153:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  154:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  155:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  156:    ptr = aligned_ptr;
        -:  157:#endif
        -:  158:    
    #####:  159:    return ptr;
        -:  160:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 123 returned 100% blocks executed 75%
      123:  121:void* mercury_aligned_alloc(size_t size, size_t alignment) {
      123:  122:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  123:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:  124:        return NULL;
        -:  125:    }
        -:  126:    
      123:  127:    void* ptr = NULL;
        -:  128:    
        -:  129:#ifdef MERCURY_LINUX
      123:  130:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  131:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  132:        return NULL;
        -:  133:    }
        -:  134:#elif defined(MERCURY_MACOS)
        -:  135:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  136:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  137:        return NULL;
        -:  138:    }
        -:  139:#elif defined(MERCURY_WINDOWS)
        -:  140:    ptr = _aligned_malloc(size, alignment);
        -:  141:    if (!ptr) {
        -:  142:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  143:        return NULL;
        -:  144:    }
        -:  145:#else
        -:  146:    // Fallback: allocate extra space and align manually
        -:  147:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  148:    if (!raw_ptr) {
        -:  149:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  150:        return NULL;
        -:  151:    }
        -:  152:    
        -:  153:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  154:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  155:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  156:    ptr = aligned_ptr;
        -:  157:#endif
        -:  158:    
      123:  159:    return ptr;
        -:  160:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 2504 returned 100% blocks executed 75%
     2504:  121:void* mercury_aligned_alloc(size_t size, size_t alignment) {
     2504:  122:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  123:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:  124:        return NULL;
        -:  125:    }
        -:  126:    
     2504:  127:    void* ptr = NULL;
        -:  128:    
        -:  129:#ifdef MERCURY_LINUX
     2504:  130:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  131:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  132:        return NULL;
        -:  133:    }
        -:  134:#elif defined(MERCURY_MACOS)
        -:  135:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  136:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  137:        return NULL;
        -:  138:    }
        -:  139:#elif defined(MERCURY_WINDOWS)
        -:  140:    ptr = _aligned_malloc(size, alignment);
        -:  141:    if (!ptr) {
        -:  142:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  143:        return NULL;
        -:  144:    }
        -:  145:#else
        -:  146:    // Fallback: allocate extra space and align manually
        -:  147:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  148:    if (!raw_ptr) {
        -:  149:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  150:        return NULL;
        -:  151:    }
        -:  152:    
        -:  153:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  154:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  155:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  156:    ptr = aligned_ptr;
        -:  157:#endif
        -:  158:    
     2504:  159:    return ptr;
        -:  160:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 2504 returned 100% blocks executed 75%
     2504:  121:void* mercury_aligned_alloc(size_t size, size_t alignment) {
     2504:  122:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  123:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:  124:        return NULL;
        -:  125:    }
        -:  126:    
     2504:  127:    void* ptr = NULL;
        -:  128:    
        -:  129:#ifdef MERCURY_LINUX
     2504:  130:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  131:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  132:        return NULL;
        -:  133:    }
        -:  134:#elif defined(MERCURY_MACOS)
        -:  135:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  136:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  137:        return NULL;
        -:  138:    }
        -:  139:#elif defined(MERCURY_WINDOWS)
        -:  140:    ptr = _aligned_malloc(size, alignment);
        -:  141:    if (!ptr) {
        -:  142:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  143:        return NULL;
        -:  144:    }
        -:  145:#else
        -:  146:    // Fallback: allocate extra space and align manually
        -:  147:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  148:    if (!raw_ptr) {
        -:  149:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  150:        return NULL;
        -:  151:    }
        -:  152:    
        -:  153:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  154:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  155:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  156:    ptr = aligned_ptr;
        -:  157:#endif
        -:  158:    
     2504:  159:    return ptr;
        -:  160:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 2 returned 100% blocks executed 75%
        2:  121:void* mercury_aligned_alloc(size_t size, size_t alignment) {
        2:  122:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  123:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:  124:        return NULL;
        -:  125:    }
        -:  126:    
        2:  127:    void* ptr = NULL;
        -:  128:    
        -:  129:#ifdef MERCURY_LINUX
        2:  130:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  131:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  132:        return NULL;
        -:  133:    }
        -:  134:#elif defined(MERCURY_MACOS)
        -:  135:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  136:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  137:        return NULL;
        -:  138:    }
        -:  139:#elif defined(MERCURY_WINDOWS)
        -:  140:    ptr = _aligned_malloc(size, alignment);
        -:  141:    if (!ptr) {
        -:  142:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  143:        return NULL;
        -:  144:    }
        -:  145:#else
        -:  146:    // Fallback: allocate extra space and align manually
        -:  147:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  148:    if (!raw_ptr) {
        -:  149:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  150:        return NULL;
        -:  151:    }
        -:  152:    
        -:  153:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  154:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  155:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  156:    ptr = aligned_ptr;
        -:  157:#endif
        -:  158:    
        2:  159:    return ptr;
        -:  160:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 2 returned 100% blocks executed 75%
        2:  121:void* mercury_aligned_alloc(size_t size, size_t alignment) {
        2:  122:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  123:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:  124:        return NULL;
        -:  125:    }
        -:  126:    
        2:  127:    void* ptr = NULL;
        -:  128:    
        -:  129:#ifdef MERCURY_LINUX
        2:  130:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  131:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  132:        return NULL;
        -:  133:    }
        -:  134:#elif defined(MERCURY_MACOS)
        -:  135:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  136:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  137:        return NULL;
        -:  138:    }
        -:  139:#elif defined(MERCURY_WINDOWS)
        -:  140:    ptr = _aligned_malloc(size, alignment);
        -:  141:    if (!ptr) {
        -:  142:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  143:        return NULL;
        -:  144:    }
        -:  145:#else
        -:  146:    // Fallback: allocate extra space and align manually
        -:  147:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  148:    if (!raw_ptr) {
        -:  149:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  150:        return NULL;
        -:  151:    }
        -:  152:    
        -:  153:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  154:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  155:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  156:    ptr = aligned_ptr;
        -:  157:#endif
        -:  158:    
        2:  159:    return ptr;
        -:  160:}
------------------
mercury_aligned_alloc:
function mercury_aligned_alloc called 2 returned 100% blocks executed 75%
        2:  121:void* mercury_aligned_alloc(size_t size, size_t alignment) {
        2:  122:    if (size == 0 || alignment == 0 || (alignment & (alignment - 1)) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  123:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid size or alignment");
    #####:  124:        return NULL;
        -:  125:    }
        -:  126:    
        2:  127:    void* ptr = NULL;
        -:  128:    
        -:  129:#ifdef MERCURY_LINUX
        2:  130:    if (posix_memalign(&ptr, alignment, size) != 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  131:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
    #####:  132:        return NULL;
        -:  133:    }
        -:  134:#elif defined(MERCURY_MACOS)
        -:  135:    if (posix_memalign(&ptr, alignment, size) != 0) {
        -:  136:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "posix_memalign failed");
        -:  137:        return NULL;
        -:  138:    }
        -:  139:#elif defined(MERCURY_WINDOWS)
        -:  140:    ptr = _aligned_malloc(size, alignment);
        -:  141:    if (!ptr) {
        -:  142:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "_aligned_malloc failed");
        -:  143:        return NULL;
        -:  144:    }
        -:  145:#else
        -:  146:    // Fallback: allocate extra space and align manually
        -:  147:    void* raw_ptr = malloc(size + alignment - 1 + sizeof(void*));
        -:  148:    if (!raw_ptr) {
        -:  149:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "malloc failed");
        -:  150:        return NULL;
        -:  151:    }
        -:  152:    
        -:  153:    char* aligned_ptr = (char*)raw_ptr + sizeof(void*);
        -:  154:    aligned_ptr += alignment - ((uintptr_t)aligned_ptr % alignment);
        -:  155:    ((void**)aligned_ptr)[-1] = raw_ptr;  // Store original pointer
        -:  156:    ptr = aligned_ptr;
        -:  157:#endif
        -:  158:    
        2:  159:    return ptr;
        -:  160:}
------------------
        -:  161:
        -:  162:/**
        -:  163: * @brief Free memory allocated with mercury_aligned_alloc
        -:  164: * 
        -:  165: * @param ptr Pointer returned by mercury_aligned_alloc (may be NULL)
        -:  166: * 
        -:  167: * @warning Only use with memory from mercury_aligned_alloc
        -:  168: * @note Safe to call with NULL pointer
        -:  169: */
  105401*:  170:void mercury_aligned_free(void* ptr) {
  105401*:  171:    if (!ptr) return;
        -:  172:    
        -:  173:#ifdef MERCURY_LINUX
  105400*:  174:    free(ptr);
        -:  175:#elif defined(MERCURY_MACOS)
        -:  176:    free(ptr);
        -:  177:#elif defined(MERCURY_WINDOWS)
        -:  178:    _aligned_free(ptr);
        -:  179:#else
        -:  180:    // Fallback: retrieve original pointer and free
        -:  181:    void* raw_ptr = ((void**)ptr)[-1];
        -:  182:    free(raw_ptr);
        -:  183:#endif
        -:  184:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 100002 returned 100% blocks executed 100%
   100002:  170:void mercury_aligned_free(void* ptr) {
   100002:  171:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  172:    
        -:  173:#ifdef MERCURY_LINUX
   100002:  174:    free(ptr);
        -:  175:#elif defined(MERCURY_MACOS)
        -:  176:    free(ptr);
        -:  177:#elif defined(MERCURY_WINDOWS)
        -:  178:    _aligned_free(ptr);
        -:  179:#else
        -:  180:    // Fallback: retrieve original pointer and free
        -:  181:    void* raw_ptr = ((void**)ptr)[-1];
        -:  182:    free(raw_ptr);
        -:  183:#endif
        -:  184:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 131 returned 100% blocks executed 100%
      131:  170:void mercury_aligned_free(void* ptr) {
      131:  171:    if (!ptr) return;
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  172:    
        -:  173:#ifdef MERCURY_LINUX
      130:  174:    free(ptr);
        -:  175:#elif defined(MERCURY_MACOS)
        -:  176:    free(ptr);
        -:  177:#elif defined(MERCURY_WINDOWS)
        -:  178:    _aligned_free(ptr);
        -:  179:#else
        -:  180:    // Fallback: retrieve original pointer and free
        -:  181:    void* raw_ptr = ((void**)ptr)[-1];
        -:  182:    free(raw_ptr);
        -:  183:#endif
        -:  184:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 112 returned 100% blocks executed 100%
      112:  170:void mercury_aligned_free(void* ptr) {
      112:  171:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  172:    
        -:  173:#ifdef MERCURY_LINUX
      112:  174:    free(ptr);
        -:  175:#elif defined(MERCURY_MACOS)
        -:  176:    free(ptr);
        -:  177:#elif defined(MERCURY_WINDOWS)
        -:  178:    _aligned_free(ptr);
        -:  179:#else
        -:  180:    // Fallback: retrieve original pointer and free
        -:  181:    void* raw_ptr = ((void**)ptr)[-1];
        -:  182:    free(raw_ptr);
        -:  183:#endif
        -:  184:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 19 returned 100% blocks executed 100%
       19:  170:void mercury_aligned_free(void* ptr) {
       19:  171:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  172:    
        -:  173:#ifdef MERCURY_LINUX
       19:  174:    free(ptr);
        -:  175:#elif defined(MERCURY_MACOS)
        -:  176:    free(ptr);
        -:  177:#elif defined(MERCURY_WINDOWS)
        -:  178:    _aligned_free(ptr);
        -:  179:#else
        -:  180:    // Fallback: retrieve original pointer and free
        -:  181:    void* raw_ptr = ((void**)ptr)[-1];
        -:  182:    free(raw_ptr);
        -:  183:#endif
        -:  184:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 0 returned 0% blocks executed 0%
    #####:  170:void mercury_aligned_free(void* ptr) {
    #####:  171:    if (!ptr) return;
branch  0 never executed
branch  1 never executed
        -:  172:    
        -:  173:#ifdef MERCURY_LINUX
    #####:  174:    free(ptr);
        -:  175:#elif defined(MERCURY_MACOS)
        -:  176:    free(ptr);
        -:  177:#elif defined(MERCURY_WINDOWS)
        -:  178:    _aligned_free(ptr);
        -:  179:#else
        -:  180:    // Fallback: retrieve original pointer and free
        -:  181:    void* raw_ptr = ((void**)ptr)[-1];
        -:  182:    free(raw_ptr);
        -:  183:#endif
        -:  184:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 123 returned 100% blocks executed 100%
      123:  170:void mercury_aligned_free(void* ptr) {
      123:  171:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  172:    
        -:  173:#ifdef MERCURY_LINUX
      123:  174:    free(ptr);
        -:  175:#elif defined(MERCURY_MACOS)
        -:  176:    free(ptr);
        -:  177:#elif defined(MERCURY_WINDOWS)
        -:  178:    _aligned_free(ptr);
        -:  179:#else
        -:  180:    // Fallback: retrieve original pointer and free
        -:  181:    void* raw_ptr = ((void**)ptr)[-1];
        -:  182:    free(raw_ptr);
        -:  183:#endif
        -:  184:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 2504 returned 100% blocks executed 100%
     2504:  170:void mercury_aligned_free(void* ptr) {
     2504:  171:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  172:    
        -:  173:#ifdef MERCURY_LINUX
     2504:  174:    free(ptr);
        -:  175:#elif defined(MERCURY_MACOS)
        -:  176:    free(ptr);
        -:  177:#elif defined(MERCURY_WINDOWS)
        -:  178:    _aligned_free(ptr);
        -:  179:#else
        -:  180:    // Fallback: retrieve original pointer and free
        -:  181:    void* raw_ptr = ((void**)ptr)[-1];
        -:  182:    free(raw_ptr);
        -:  183:#endif
        -:  184:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 2504 returned 100% blocks executed 100%
     2504:  170:void mercury_aligned_free(void* ptr) {
     2504:  171:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  172:    
        -:  173:#ifdef MERCURY_LINUX
     2504:  174:    free(ptr);
        -:  175:#elif defined(MERCURY_MACOS)
        -:  176:    free(ptr);
        -:  177:#elif defined(MERCURY_WINDOWS)
        -:  178:    _aligned_free(ptr);
        -:  179:#else
        -:  180:    // Fallback: retrieve original pointer and free
        -:  181:    void* raw_ptr = ((void**)ptr)[-1];
        -:  182:    free(raw_ptr);
        -:  183:#endif
        -:  184:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 2 returned 100% blocks executed 100%
        2:  170:void mercury_aligned_free(void* ptr) {
        2:  171:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  172:    
        -:  173:#ifdef MERCURY_LINUX
        2:  174:    free(ptr);
        -:  175:#elif defined(MERCURY_MACOS)
        -:  176:    free(ptr);
        -:  177:#elif defined(MERCURY_WINDOWS)
        -:  178:    _aligned_free(ptr);
        -:  179:#else
        -:  180:    // Fallback: retrieve original pointer and free
        -:  181:    void* raw_ptr = ((void**)ptr)[-1];
        -:  182:    free(raw_ptr);
        -:  183:#endif
        -:  184:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 2 returned 100% blocks executed 100%
        2:  170:void mercury_aligned_free(void* ptr) {
        2:  171:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  172:    
        -:  173:#ifdef MERCURY_LINUX
        2:  174:    free(ptr);
        -:  175:#elif defined(MERCURY_MACOS)
        -:  176:    free(ptr);
        -:  177:#elif defined(MERCURY_WINDOWS)
        -:  178:    _aligned_free(ptr);
        -:  179:#else
        -:  180:    // Fallback: retrieve original pointer and free
        -:  181:    void* raw_ptr = ((void**)ptr)[-1];
        -:  182:    free(raw_ptr);
        -:  183:#endif
        -:  184:}
------------------
mercury_aligned_free:
function mercury_aligned_free called 2 returned 100% blocks executed 100%
        2:  170:void mercury_aligned_free(void* ptr) {
        2:  171:    if (!ptr) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  172:    
        -:  173:#ifdef MERCURY_LINUX
        2:  174:    free(ptr);
        -:  175:#elif defined(MERCURY_MACOS)
        -:  176:    free(ptr);
        -:  177:#elif defined(MERCURY_WINDOWS)
        -:  178:    _aligned_free(ptr);
        -:  179:#else
        -:  180:    // Fallback: retrieve original pointer and free
        -:  181:    void* raw_ptr = ((void**)ptr)[-1];
        -:  182:    free(raw_ptr);
        -:  183:#endif
        -:  184:}
------------------
        -:  185:
        -:  186:// === RING BUFFER IMPLEMENTATION ===
        -:  187:
        -:  188:/**
        -:  189: * @brief Create a lock-free ring buffer for high-performance data exchange
        -:  190: * 
        -:  191: * @details Creates a cache-aligned ring buffer with atomic operations for
        -:  192: * thread-safe producer-consumer patterns. Optimized for high-throughput
        -:  193: * with minimal contention.
        -:  194: * 
        -:  195: * @param element_size Size of each element in bytes
        -:  196: * @param capacity Maximum number of elements the buffer can hold
        -:  197: * @return Pointer to ring buffer or NULL on failure
        -:  198: * 
        -:  199: * @pre element_size > 0 and capacity > 0
        -:  200: * @post Ring buffer is initialized and ready for use
        -:  201: * 
        -:  202: * @warning Caller must call mercury_ring_buffer_destroy() to free
        -:  203: * @note Limited to 1GB total size to prevent accidental huge allocations
        -:  204: */
      13*:  205:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
      13*:  206:    if (element_size == 0 || capacity == 0) {
       4*:  207:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
       4*:  208:        return NULL;
        -:  209:    }
        -:  210:    
        -:  211:    // Check for overflow in size calculation
        -:  212:    size_t total_size;
       9*:  213:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
    #####:  214:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  215:                         "Buffer size would overflow");
    #####:  216:        return NULL;
        -:  217:    }
        -:  218:    
        -:  219:    // Sanity check: limit to 1GB to prevent accidental huge allocations
       9*:  220:    if (total_size > (1ULL << 30)) {
       1*:  221:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  222:                         "Buffer size too large (max 1GB)");
       1*:  223:        return NULL;
        -:  224:    }
        -:  225:    
       8*:  226:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
       8*:  227:    if (!buffer) {
    #####:  228:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  229:                         "Failed to allocate ring buffer structure");
    #####:  230:        return NULL;
        -:  231:    }
        -:  232:    
       8*:  233:    buffer->data = mercury_aligned_alloc(total_size, 64);
       8*:  234:    if (!buffer->data) {
    #####:  235:        mercury_aligned_free(buffer);
    #####:  236:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  237:                         "Failed to allocate ring buffer data");
    #####:  238:        return NULL;
        -:  239:    }
        -:  240:    
       8*:  241:    buffer->element_size = element_size;
       8*:  242:    buffer->capacity = capacity;
       8*:  243:    atomic_store(&buffer->head, 0);
       8*:  244:    atomic_store(&buffer->tail, 0);
       8*:  245:    atomic_store(&buffer->count, 0);
        -:  246:    
       8*:  247:    return buffer;
        -:  248:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 1 returned 100% blocks executed 65%
        1:  205:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
        1:  206:    if (element_size == 0 || capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  207:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  208:        return NULL;
        -:  209:    }
        -:  210:    
        -:  211:    // Check for overflow in size calculation
        -:  212:    size_t total_size;
        1:  213:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  214:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  215:                         "Buffer size would overflow");
    #####:  216:        return NULL;
        -:  217:    }
        -:  218:    
        -:  219:    // Sanity check: limit to 1GB to prevent accidental huge allocations
        1:  220:    if (total_size > (1ULL << 30)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  221:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  222:                         "Buffer size too large (max 1GB)");
    #####:  223:        return NULL;
        -:  224:    }
        -:  225:    
        1:  226:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 returned 100%
        1:  227:    if (!buffer) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  228:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  229:                         "Failed to allocate ring buffer structure");
    #####:  230:        return NULL;
        -:  231:    }
        -:  232:    
        1:  233:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 returned 100%
        1:  234:    if (!buffer->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  235:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  236:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  237:                         "Failed to allocate ring buffer data");
    #####:  238:        return NULL;
        -:  239:    }
        -:  240:    
        1:  241:    buffer->element_size = element_size;
        1:  242:    buffer->capacity = capacity;
        1:  243:    atomic_store(&buffer->head, 0);
        1:  244:    atomic_store(&buffer->tail, 0);
        1:  245:    atomic_store(&buffer->count, 0);
        -:  246:    
        1:  247:    return buffer;
        -:  248:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 8 returned 100% blocks executed 76%
        8:  205:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
        8:  206:    if (element_size == 0 || capacity == 0) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        4:  207:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
        4:  208:        return NULL;
        -:  209:    }
        -:  210:    
        -:  211:    // Check for overflow in size calculation
        -:  212:    size_t total_size;
        4:  213:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  214:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  215:                         "Buffer size would overflow");
    #####:  216:        return NULL;
        -:  217:    }
        -:  218:    
        -:  219:    // Sanity check: limit to 1GB to prevent accidental huge allocations
        4:  220:    if (total_size > (1ULL << 30)) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        1:  221:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  222:                         "Buffer size too large (max 1GB)");
        1:  223:        return NULL;
        -:  224:    }
        -:  225:    
        3:  226:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 returned 100%
        3:  227:    if (!buffer) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  228:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  229:                         "Failed to allocate ring buffer structure");
    #####:  230:        return NULL;
        -:  231:    }
        -:  232:    
        3:  233:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 returned 100%
        3:  234:    if (!buffer->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  235:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  236:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  237:                         "Failed to allocate ring buffer data");
    #####:  238:        return NULL;
        -:  239:    }
        -:  240:    
        3:  241:    buffer->element_size = element_size;
        3:  242:    buffer->capacity = capacity;
        3:  243:    atomic_store(&buffer->head, 0);
        3:  244:    atomic_store(&buffer->tail, 0);
        3:  245:    atomic_store(&buffer->count, 0);
        -:  246:    
        3:  247:    return buffer;
        -:  248:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 2 returned 100% blocks executed 65%
        2:  205:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
        2:  206:    if (element_size == 0 || capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  207:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  208:        return NULL;
        -:  209:    }
        -:  210:    
        -:  211:    // Check for overflow in size calculation
        -:  212:    size_t total_size;
        2:  213:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  214:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  215:                         "Buffer size would overflow");
    #####:  216:        return NULL;
        -:  217:    }
        -:  218:    
        -:  219:    // Sanity check: limit to 1GB to prevent accidental huge allocations
        2:  220:    if (total_size > (1ULL << 30)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  221:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  222:                         "Buffer size too large (max 1GB)");
    #####:  223:        return NULL;
        -:  224:    }
        -:  225:    
        2:  226:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 returned 100%
        2:  227:    if (!buffer) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  228:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  229:                         "Failed to allocate ring buffer structure");
    #####:  230:        return NULL;
        -:  231:    }
        -:  232:    
        2:  233:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 returned 100%
        2:  234:    if (!buffer->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  235:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  236:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  237:                         "Failed to allocate ring buffer data");
    #####:  238:        return NULL;
        -:  239:    }
        -:  240:    
        2:  241:    buffer->element_size = element_size;
        2:  242:    buffer->capacity = capacity;
        2:  243:    atomic_store(&buffer->head, 0);
        2:  244:    atomic_store(&buffer->tail, 0);
        2:  245:    atomic_store(&buffer->count, 0);
        -:  246:    
        2:  247:    return buffer;
        -:  248:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 0 returned 0% blocks executed 0%
    #####:  205:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
    #####:  206:    if (element_size == 0 || capacity == 0) {
branch  0 never executed
branch  1 never executed
    #####:  207:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  208:        return NULL;
        -:  209:    }
        -:  210:    
        -:  211:    // Check for overflow in size calculation
        -:  212:    size_t total_size;
    #####:  213:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 never executed
branch  1 never executed
    #####:  214:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  215:                         "Buffer size would overflow");
    #####:  216:        return NULL;
        -:  217:    }
        -:  218:    
        -:  219:    // Sanity check: limit to 1GB to prevent accidental huge allocations
    #####:  220:    if (total_size > (1ULL << 30)) {
branch  0 never executed
branch  1 never executed
    #####:  221:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  222:                         "Buffer size too large (max 1GB)");
    #####:  223:        return NULL;
        -:  224:    }
        -:  225:    
    #####:  226:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 never executed
    #####:  227:    if (!buffer) {
branch  0 never executed
branch  1 never executed
    #####:  228:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  229:                         "Failed to allocate ring buffer structure");
    #####:  230:        return NULL;
        -:  231:    }
        -:  232:    
    #####:  233:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 never executed
    #####:  234:    if (!buffer->data) {
branch  0 never executed
branch  1 never executed
    #####:  235:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  236:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  237:                         "Failed to allocate ring buffer data");
    #####:  238:        return NULL;
        -:  239:    }
        -:  240:    
    #####:  241:    buffer->element_size = element_size;
    #####:  242:    buffer->capacity = capacity;
    #####:  243:    atomic_store(&buffer->head, 0);
    #####:  244:    atomic_store(&buffer->tail, 0);
    #####:  245:    atomic_store(&buffer->count, 0);
        -:  246:    
    #####:  247:    return buffer;
        -:  248:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 0 returned 0% blocks executed 0%
    #####:  205:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
    #####:  206:    if (element_size == 0 || capacity == 0) {
branch  0 never executed
branch  1 never executed
    #####:  207:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  208:        return NULL;
        -:  209:    }
        -:  210:    
        -:  211:    // Check for overflow in size calculation
        -:  212:    size_t total_size;
    #####:  213:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 never executed
branch  1 never executed
    #####:  214:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  215:                         "Buffer size would overflow");
    #####:  216:        return NULL;
        -:  217:    }
        -:  218:    
        -:  219:    // Sanity check: limit to 1GB to prevent accidental huge allocations
    #####:  220:    if (total_size > (1ULL << 30)) {
branch  0 never executed
branch  1 never executed
    #####:  221:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  222:                         "Buffer size too large (max 1GB)");
    #####:  223:        return NULL;
        -:  224:    }
        -:  225:    
    #####:  226:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 never executed
    #####:  227:    if (!buffer) {
branch  0 never executed
branch  1 never executed
    #####:  228:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  229:                         "Failed to allocate ring buffer structure");
    #####:  230:        return NULL;
        -:  231:    }
        -:  232:    
    #####:  233:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 never executed
    #####:  234:    if (!buffer->data) {
branch  0 never executed
branch  1 never executed
    #####:  235:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  236:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  237:                         "Failed to allocate ring buffer data");
    #####:  238:        return NULL;
        -:  239:    }
        -:  240:    
    #####:  241:    buffer->element_size = element_size;
    #####:  242:    buffer->capacity = capacity;
    #####:  243:    atomic_store(&buffer->head, 0);
    #####:  244:    atomic_store(&buffer->tail, 0);
    #####:  245:    atomic_store(&buffer->count, 0);
        -:  246:    
    #####:  247:    return buffer;
        -:  248:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 0 returned 0% blocks executed 0%
    #####:  205:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
    #####:  206:    if (element_size == 0 || capacity == 0) {
branch  0 never executed
branch  1 never executed
    #####:  207:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  208:        return NULL;
        -:  209:    }
        -:  210:    
        -:  211:    // Check for overflow in size calculation
        -:  212:    size_t total_size;
    #####:  213:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 never executed
branch  1 never executed
    #####:  214:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  215:                         "Buffer size would overflow");
    #####:  216:        return NULL;
        -:  217:    }
        -:  218:    
        -:  219:    // Sanity check: limit to 1GB to prevent accidental huge allocations
    #####:  220:    if (total_size > (1ULL << 30)) {
branch  0 never executed
branch  1 never executed
    #####:  221:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  222:                         "Buffer size too large (max 1GB)");
    #####:  223:        return NULL;
        -:  224:    }
        -:  225:    
    #####:  226:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 never executed
    #####:  227:    if (!buffer) {
branch  0 never executed
branch  1 never executed
    #####:  228:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  229:                         "Failed to allocate ring buffer structure");
    #####:  230:        return NULL;
        -:  231:    }
        -:  232:    
    #####:  233:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 never executed
    #####:  234:    if (!buffer->data) {
branch  0 never executed
branch  1 never executed
    #####:  235:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  236:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  237:                         "Failed to allocate ring buffer data");
    #####:  238:        return NULL;
        -:  239:    }
        -:  240:    
    #####:  241:    buffer->element_size = element_size;
    #####:  242:    buffer->capacity = capacity;
    #####:  243:    atomic_store(&buffer->head, 0);
    #####:  244:    atomic_store(&buffer->tail, 0);
    #####:  245:    atomic_store(&buffer->count, 0);
        -:  246:    
    #####:  247:    return buffer;
        -:  248:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 1 returned 100% blocks executed 65%
        1:  205:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
        1:  206:    if (element_size == 0 || capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  207:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  208:        return NULL;
        -:  209:    }
        -:  210:    
        -:  211:    // Check for overflow in size calculation
        -:  212:    size_t total_size;
        1:  213:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  214:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  215:                         "Buffer size would overflow");
    #####:  216:        return NULL;
        -:  217:    }
        -:  218:    
        -:  219:    // Sanity check: limit to 1GB to prevent accidental huge allocations
        1:  220:    if (total_size > (1ULL << 30)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  221:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  222:                         "Buffer size too large (max 1GB)");
    #####:  223:        return NULL;
        -:  224:    }
        -:  225:    
        1:  226:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 returned 100%
        1:  227:    if (!buffer) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  228:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  229:                         "Failed to allocate ring buffer structure");
    #####:  230:        return NULL;
        -:  231:    }
        -:  232:    
        1:  233:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 returned 100%
        1:  234:    if (!buffer->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  235:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  236:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  237:                         "Failed to allocate ring buffer data");
    #####:  238:        return NULL;
        -:  239:    }
        -:  240:    
        1:  241:    buffer->element_size = element_size;
        1:  242:    buffer->capacity = capacity;
        1:  243:    atomic_store(&buffer->head, 0);
        1:  244:    atomic_store(&buffer->tail, 0);
        1:  245:    atomic_store(&buffer->count, 0);
        -:  246:    
        1:  247:    return buffer;
        -:  248:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 1 returned 100% blocks executed 65%
        1:  205:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
        1:  206:    if (element_size == 0 || capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  207:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  208:        return NULL;
        -:  209:    }
        -:  210:    
        -:  211:    // Check for overflow in size calculation
        -:  212:    size_t total_size;
        1:  213:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  214:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  215:                         "Buffer size would overflow");
    #####:  216:        return NULL;
        -:  217:    }
        -:  218:    
        -:  219:    // Sanity check: limit to 1GB to prevent accidental huge allocations
        1:  220:    if (total_size > (1ULL << 30)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  221:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  222:                         "Buffer size too large (max 1GB)");
    #####:  223:        return NULL;
        -:  224:    }
        -:  225:    
        1:  226:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 returned 100%
        1:  227:    if (!buffer) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  228:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  229:                         "Failed to allocate ring buffer structure");
    #####:  230:        return NULL;
        -:  231:    }
        -:  232:    
        1:  233:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 returned 100%
        1:  234:    if (!buffer->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  235:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  236:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  237:                         "Failed to allocate ring buffer data");
    #####:  238:        return NULL;
        -:  239:    }
        -:  240:    
        1:  241:    buffer->element_size = element_size;
        1:  242:    buffer->capacity = capacity;
        1:  243:    atomic_store(&buffer->head, 0);
        1:  244:    atomic_store(&buffer->tail, 0);
        1:  245:    atomic_store(&buffer->count, 0);
        -:  246:    
        1:  247:    return buffer;
        -:  248:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 0 returned 0% blocks executed 0%
    #####:  205:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
    #####:  206:    if (element_size == 0 || capacity == 0) {
branch  0 never executed
branch  1 never executed
    #####:  207:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  208:        return NULL;
        -:  209:    }
        -:  210:    
        -:  211:    // Check for overflow in size calculation
        -:  212:    size_t total_size;
    #####:  213:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 never executed
branch  1 never executed
    #####:  214:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  215:                         "Buffer size would overflow");
    #####:  216:        return NULL;
        -:  217:    }
        -:  218:    
        -:  219:    // Sanity check: limit to 1GB to prevent accidental huge allocations
    #####:  220:    if (total_size > (1ULL << 30)) {
branch  0 never executed
branch  1 never executed
    #####:  221:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  222:                         "Buffer size too large (max 1GB)");
    #####:  223:        return NULL;
        -:  224:    }
        -:  225:    
    #####:  226:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 never executed
    #####:  227:    if (!buffer) {
branch  0 never executed
branch  1 never executed
    #####:  228:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  229:                         "Failed to allocate ring buffer structure");
    #####:  230:        return NULL;
        -:  231:    }
        -:  232:    
    #####:  233:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 never executed
    #####:  234:    if (!buffer->data) {
branch  0 never executed
branch  1 never executed
    #####:  235:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  236:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  237:                         "Failed to allocate ring buffer data");
    #####:  238:        return NULL;
        -:  239:    }
        -:  240:    
    #####:  241:    buffer->element_size = element_size;
    #####:  242:    buffer->capacity = capacity;
    #####:  243:    atomic_store(&buffer->head, 0);
    #####:  244:    atomic_store(&buffer->tail, 0);
    #####:  245:    atomic_store(&buffer->count, 0);
        -:  246:    
    #####:  247:    return buffer;
        -:  248:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 0 returned 0% blocks executed 0%
    #####:  205:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
    #####:  206:    if (element_size == 0 || capacity == 0) {
branch  0 never executed
branch  1 never executed
    #####:  207:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  208:        return NULL;
        -:  209:    }
        -:  210:    
        -:  211:    // Check for overflow in size calculation
        -:  212:    size_t total_size;
    #####:  213:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 never executed
branch  1 never executed
    #####:  214:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  215:                         "Buffer size would overflow");
    #####:  216:        return NULL;
        -:  217:    }
        -:  218:    
        -:  219:    // Sanity check: limit to 1GB to prevent accidental huge allocations
    #####:  220:    if (total_size > (1ULL << 30)) {
branch  0 never executed
branch  1 never executed
    #####:  221:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  222:                         "Buffer size too large (max 1GB)");
    #####:  223:        return NULL;
        -:  224:    }
        -:  225:    
    #####:  226:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 never executed
    #####:  227:    if (!buffer) {
branch  0 never executed
branch  1 never executed
    #####:  228:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  229:                         "Failed to allocate ring buffer structure");
    #####:  230:        return NULL;
        -:  231:    }
        -:  232:    
    #####:  233:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 never executed
    #####:  234:    if (!buffer->data) {
branch  0 never executed
branch  1 never executed
    #####:  235:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  236:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  237:                         "Failed to allocate ring buffer data");
    #####:  238:        return NULL;
        -:  239:    }
        -:  240:    
    #####:  241:    buffer->element_size = element_size;
    #####:  242:    buffer->capacity = capacity;
    #####:  243:    atomic_store(&buffer->head, 0);
    #####:  244:    atomic_store(&buffer->tail, 0);
    #####:  245:    atomic_store(&buffer->count, 0);
        -:  246:    
    #####:  247:    return buffer;
        -:  248:}
------------------
mercury_ring_buffer_create:
function mercury_ring_buffer_create called 0 returned 0% blocks executed 0%
    #####:  205:MercuryRingBuffer* mercury_ring_buffer_create(size_t element_size, size_t capacity) {
    #####:  206:    if (element_size == 0 || capacity == 0) {
branch  0 never executed
branch  1 never executed
    #####:  207:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid element size or capacity");
    #####:  208:        return NULL;
        -:  209:    }
        -:  210:    
        -:  211:    // Check for overflow in size calculation
        -:  212:    size_t total_size;
    #####:  213:    if (!mercury_safe_mul_size(element_size, capacity, &total_size)) {
branch  0 never executed
branch  1 never executed
    #####:  214:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  215:                         "Buffer size would overflow");
    #####:  216:        return NULL;
        -:  217:    }
        -:  218:    
        -:  219:    // Sanity check: limit to 1GB to prevent accidental huge allocations
    #####:  220:    if (total_size > (1ULL << 30)) {
branch  0 never executed
branch  1 never executed
    #####:  221:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, 
        -:  222:                         "Buffer size too large (max 1GB)");
    #####:  223:        return NULL;
        -:  224:    }
        -:  225:    
    #####:  226:    MercuryRingBuffer* buffer = mercury_aligned_alloc(sizeof(MercuryRingBuffer), 64);
call    0 never executed
    #####:  227:    if (!buffer) {
branch  0 never executed
branch  1 never executed
    #####:  228:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  229:                         "Failed to allocate ring buffer structure");
    #####:  230:        return NULL;
        -:  231:    }
        -:  232:    
    #####:  233:    buffer->data = mercury_aligned_alloc(total_size, 64);
call    0 never executed
    #####:  234:    if (!buffer->data) {
branch  0 never executed
branch  1 never executed
    #####:  235:        mercury_aligned_free(buffer);
call    0 never executed
    #####:  236:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, 
        -:  237:                         "Failed to allocate ring buffer data");
    #####:  238:        return NULL;
        -:  239:    }
        -:  240:    
    #####:  241:    buffer->element_size = element_size;
    #####:  242:    buffer->capacity = capacity;
    #####:  243:    atomic_store(&buffer->head, 0);
    #####:  244:    atomic_store(&buffer->tail, 0);
    #####:  245:    atomic_store(&buffer->count, 0);
        -:  246:    
    #####:  247:    return buffer;
        -:  248:}
------------------
        -:  249:
        -:  250:/**
        -:  251: * @brief Destroy ring buffer and free all resources
        -:  252: * 
        -:  253: * @param buffer Ring buffer to destroy (may be NULL)
        -:  254: * 
        -:  255: * @note Safe to call with NULL pointer
        -:  256: */
       8*:  257:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
       8*:  258:    if (!buffer) return;
        -:  259:    
       8*:  260:    mercury_aligned_free(buffer->data);
       8*:  261:    mercury_aligned_free(buffer);
        -:  262:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 1 returned 100% blocks executed 100%
        1:  257:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
        1:  258:    if (!buffer) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  259:    
        1:  260:    mercury_aligned_free(buffer->data);
call    0 returned 100%
        1:  261:    mercury_aligned_free(buffer);
call    0 returned 100%
        -:  262:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 3 returned 100% blocks executed 100%
        3:  257:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
        3:  258:    if (!buffer) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  259:    
        3:  260:    mercury_aligned_free(buffer->data);
call    0 returned 100%
        3:  261:    mercury_aligned_free(buffer);
call    0 returned 100%
        -:  262:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 2 returned 100% blocks executed 100%
        2:  257:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
        2:  258:    if (!buffer) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  259:    
        2:  260:    mercury_aligned_free(buffer->data);
call    0 returned 100%
        2:  261:    mercury_aligned_free(buffer);
call    0 returned 100%
        -:  262:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 0 returned 0% blocks executed 0%
    #####:  257:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
    #####:  258:    if (!buffer) return;
branch  0 never executed
branch  1 never executed
        -:  259:    
    #####:  260:    mercury_aligned_free(buffer->data);
call    0 never executed
    #####:  261:    mercury_aligned_free(buffer);
call    0 never executed
        -:  262:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 0 returned 0% blocks executed 0%
    #####:  257:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
    #####:  258:    if (!buffer) return;
branch  0 never executed
branch  1 never executed
        -:  259:    
    #####:  260:    mercury_aligned_free(buffer->data);
call    0 never executed
    #####:  261:    mercury_aligned_free(buffer);
call    0 never executed
        -:  262:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 0 returned 0% blocks executed 0%
    #####:  257:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
    #####:  258:    if (!buffer) return;
branch  0 never executed
branch  1 never executed
        -:  259:    
    #####:  260:    mercury_aligned_free(buffer->data);
call    0 never executed
    #####:  261:    mercury_aligned_free(buffer);
call    0 never executed
        -:  262:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 1 returned 100% blocks executed 100%
        1:  257:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
        1:  258:    if (!buffer) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  259:    
        1:  260:    mercury_aligned_free(buffer->data);
call    0 returned 100%
        1:  261:    mercury_aligned_free(buffer);
call    0 returned 100%
        -:  262:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 1 returned 100% blocks executed 100%
        1:  257:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
        1:  258:    if (!buffer) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  259:    
        1:  260:    mercury_aligned_free(buffer->data);
call    0 returned 100%
        1:  261:    mercury_aligned_free(buffer);
call    0 returned 100%
        -:  262:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 0 returned 0% blocks executed 0%
    #####:  257:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
    #####:  258:    if (!buffer) return;
branch  0 never executed
branch  1 never executed
        -:  259:    
    #####:  260:    mercury_aligned_free(buffer->data);
call    0 never executed
    #####:  261:    mercury_aligned_free(buffer);
call    0 never executed
        -:  262:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 0 returned 0% blocks executed 0%
    #####:  257:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
    #####:  258:    if (!buffer) return;
branch  0 never executed
branch  1 never executed
        -:  259:    
    #####:  260:    mercury_aligned_free(buffer->data);
call    0 never executed
    #####:  261:    mercury_aligned_free(buffer);
call    0 never executed
        -:  262:}
------------------
mercury_ring_buffer_destroy:
function mercury_ring_buffer_destroy called 0 returned 0% blocks executed 0%
    #####:  257:void mercury_ring_buffer_destroy(MercuryRingBuffer* buffer) {
    #####:  258:    if (!buffer) return;
branch  0 never executed
branch  1 never executed
        -:  259:    
    #####:  260:    mercury_aligned_free(buffer->data);
call    0 never executed
    #####:  261:    mercury_aligned_free(buffer);
call    0 never executed
        -:  262:}
------------------
        -:  263:
        -:  264:/**
        -:  265: * @brief Push element to ring buffer (thread-safe)
        -:  266: * 
        -:  267: * @details Uses lock-free atomic operations for thread-safe insertion.
        -:  268: * Optimized with cache prefetching for sequential access patterns.
        -:  269: * 
        -:  270: * @param buffer Ring buffer to push to
        -:  271: * @param element Pointer to element data to copy
        -:  272: * @return true if successful, false if buffer is full or invalid
        -:  273: * 
        -:  274: * @warning Does not block - returns false immediately if full
        -:  275: * @note Thread-safe with multiple producers
        -:  276: */
    4497*:  277:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    4497*:  278:    if (MERCURY_UNLIKELY(!buffer || !element)) {
        -:  279:        return false;
        -:  280:    }
        -:  281:    
        -:  282:    // Debug: verify buffer integrity
        -:  283:    MERCURY_VERIFY_BUFFER(buffer);
        -:  284:    
        -:  285:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  286:    size_t current_count, new_count;
        -:  287:    do {
    4504*:  288:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    4504*:  289:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
        -:  290:            return false;  // Buffer is full
        -:  291:        }
    3495*:  292:        new_count = current_count + 1;
    3495*:  293:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
        -:  294:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  295:    
        -:  296:    // Now we have successfully reserved a slot, get our position
    3488*:  297:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    3488*:  298:    head = head % buffer->capacity;  // Wrap around
        -:  299:    
        -:  300:    // Copy data to reserved slot
    3488*:  301:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  302:    
        -:  303:    // Prefetch destination for write
    3488*:  304:    MERCURY_PREFETCH_WRITE(dest);
        -:  305:    
        -:  306:    // Prefetch next few slots for sequential writes (cache warming)
    3488*:  307:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
    3478*:  308:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
        -:  309:    }
    3488*:  310:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
    3470*:  311:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
        -:  312:    }
        -:  313:    
        -:  314:    // Optimized copy based on element size
        -:  315:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  316:    // to prevent compiler warnings about buffer overflows
    3488*:  317:    if (buffer->element_size <= 16) {
        -:  318:        // Fast path for small and medium elements (most common case)
        -:  319:        memcpy(dest, element, buffer->element_size);
        -:  320:    } else {
        -:  321:        // For very large elements, still use regular memcpy for ring buffers
        -:  322:        // SIMD is not beneficial for the typical ring buffer use case
        -:  323:        memcpy(dest, element, buffer->element_size);
        -:  324:    }
        -:  325:    
        -:  326:    // Count was already updated atomically in the CAS loop above
        -:  327:    
        -:  328:    return true;
        -:  329:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 205 returned 100% blocks executed 92%
      205:  277:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
      205:  278:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  279:        return false;
        -:  280:    }
        -:  281:    
        -:  282:    // Debug: verify buffer integrity
        -:  283:    MERCURY_VERIFY_BUFFER(buffer);
        -:  284:    
        -:  285:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  286:    size_t current_count, new_count;
        -:  287:    do {
      212:  288:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
      212:  289:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
        -:  290:            return false;  // Buffer is full
        -:  291:        }
      207:  292:        new_count = current_count + 1;
      207:  293:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 3%
branch  2 taken 97% (fallthrough)
        -:  294:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  295:    
        -:  296:    // Now we have successfully reserved a slot, get our position
      200:  297:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
      200:  298:    head = head % buffer->capacity;  // Wrap around
        -:  299:    
        -:  300:    // Copy data to reserved slot
      200:  301:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  302:    
        -:  303:    // Prefetch destination for write
      200:  304:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  305:    
        -:  306:    // Prefetch next few slots for sequential writes (cache warming)
      200:  307:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
      197:  308:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 returned 100%
        -:  309:    }
      200:  310:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
      194:  311:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 returned 100%
        -:  312:    }
        -:  313:    
        -:  314:    // Optimized copy based on element size
        -:  315:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  316:    // to prevent compiler warnings about buffer overflows
      200:  317:    if (buffer->element_size <= 16) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  318:        // Fast path for small and medium elements (most common case)
        -:  319:        memcpy(dest, element, buffer->element_size);
        -:  320:    } else {
        -:  321:        // For very large elements, still use regular memcpy for ring buffers
        -:  322:        // SIMD is not beneficial for the typical ring buffer use case
        -:  323:        memcpy(dest, element, buffer->element_size);
        -:  324:    }
        -:  325:    
        -:  326:    // Count was already updated atomically in the CAS loop above
        -:  327:    
        -:  328:    return true;
        -:  329:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 11 returned 100% blocks executed 100%
       11:  277:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
       11:  278:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  279:        return false;
        -:  280:    }
        -:  281:    
        -:  282:    // Debug: verify buffer integrity
        -:  283:    MERCURY_VERIFY_BUFFER(buffer);
        -:  284:    
        -:  285:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  286:    size_t current_count, new_count;
        -:  287:    do {
       11:  288:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
       11:  289:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
        -:  290:            return false;  // Buffer is full
        -:  291:        }
        8:  292:        new_count = current_count + 1;
        8:  293:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  294:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  295:    
        -:  296:    // Now we have successfully reserved a slot, get our position
        8:  297:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
        8:  298:    head = head % buffer->capacity;  // Wrap around
        -:  299:    
        -:  300:    // Copy data to reserved slot
        8:  301:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  302:    
        -:  303:    // Prefetch destination for write
        8:  304:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  305:    
        -:  306:    // Prefetch next few slots for sequential writes (cache warming)
        8:  307:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
        5:  308:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 returned 100%
        -:  309:    }
        8:  310:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
        3:  311:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 returned 100%
        -:  312:    }
        -:  313:    
        -:  314:    // Optimized copy based on element size
        -:  315:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  316:    // to prevent compiler warnings about buffer overflows
        8:  317:    if (buffer->element_size <= 16) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
        -:  318:        // Fast path for small and medium elements (most common case)
        -:  319:        memcpy(dest, element, buffer->element_size);
        -:  320:    } else {
        -:  321:        // For very large elements, still use regular memcpy for ring buffers
        -:  322:        // SIMD is not beneficial for the typical ring buffer use case
        -:  323:        memcpy(dest, element, buffer->element_size);
        -:  324:    }
        -:  325:    
        -:  326:    // Count was already updated atomically in the CAS loop above
        -:  327:    
        -:  328:    return true;
        -:  329:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 3 returned 100% blocks executed 100%
        3:  277:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
        3:  278:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  279:        return false;
        -:  280:    }
        -:  281:    
        -:  282:    // Debug: verify buffer integrity
        -:  283:    MERCURY_VERIFY_BUFFER(buffer);
        -:  284:    
        -:  285:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  286:    size_t current_count, new_count;
        -:  287:    do {
        3:  288:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
        3:  289:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -:  290:            return false;  // Buffer is full
        -:  291:        }
        2:  292:        new_count = current_count + 1;
        2:  293:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  294:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  295:    
        -:  296:    // Now we have successfully reserved a slot, get our position
        2:  297:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
        2:  298:    head = head % buffer->capacity;  // Wrap around
        -:  299:    
        -:  300:    // Copy data to reserved slot
        2:  301:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  302:    
        -:  303:    // Prefetch destination for write
        2:  304:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  305:    
        -:  306:    // Prefetch next few slots for sequential writes (cache warming)
        2:  307:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:  308:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 returned 100%
        -:  309:    }
        2:  310:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:  311:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 returned 100%
        -:  312:    }
        -:  313:    
        -:  314:    // Optimized copy based on element size
        -:  315:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  316:    // to prevent compiler warnings about buffer overflows
        2:  317:    if (buffer->element_size <= 16) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  318:        // Fast path for small and medium elements (most common case)
        -:  319:        memcpy(dest, element, buffer->element_size);
        -:  320:    } else {
        -:  321:        // For very large elements, still use regular memcpy for ring buffers
        -:  322:        // SIMD is not beneficial for the typical ring buffer use case
        -:  323:        memcpy(dest, element, buffer->element_size);
        -:  324:    }
        -:  325:    
        -:  326:    // Count was already updated atomically in the CAS loop above
        -:  327:    
        -:  328:    return true;
        -:  329:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 0 returned 0% blocks executed 0%
    #####:  277:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    #####:  278:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  279:        return false;
        -:  280:    }
        -:  281:    
        -:  282:    // Debug: verify buffer integrity
        -:  283:    MERCURY_VERIFY_BUFFER(buffer);
        -:  284:    
        -:  285:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  286:    size_t current_count, new_count;
        -:  287:    do {
    #####:  288:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  289:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  290:            return false;  // Buffer is full
        -:  291:        }
    #####:  292:        new_count = current_count + 1;
    #####:  293:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  294:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  295:    
        -:  296:    // Now we have successfully reserved a slot, get our position
    #####:  297:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    #####:  298:    head = head % buffer->capacity;  // Wrap around
        -:  299:    
        -:  300:    // Copy data to reserved slot
    #####:  301:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  302:    
        -:  303:    // Prefetch destination for write
    #####:  304:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  305:    
        -:  306:    // Prefetch next few slots for sequential writes (cache warming)
    #####:  307:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  308:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 never executed
        -:  309:    }
    #####:  310:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  311:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 never executed
        -:  312:    }
        -:  313:    
        -:  314:    // Optimized copy based on element size
        -:  315:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  316:    // to prevent compiler warnings about buffer overflows
    #####:  317:    if (buffer->element_size <= 16) {
branch  0 never executed
branch  1 never executed
        -:  318:        // Fast path for small and medium elements (most common case)
        -:  319:        memcpy(dest, element, buffer->element_size);
        -:  320:    } else {
        -:  321:        // For very large elements, still use regular memcpy for ring buffers
        -:  322:        // SIMD is not beneficial for the typical ring buffer use case
        -:  323:        memcpy(dest, element, buffer->element_size);
        -:  324:    }
        -:  325:    
        -:  326:    // Count was already updated atomically in the CAS loop above
        -:  327:    
        -:  328:    return true;
        -:  329:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 0 returned 0% blocks executed 0%
    #####:  277:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    #####:  278:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  279:        return false;
        -:  280:    }
        -:  281:    
        -:  282:    // Debug: verify buffer integrity
        -:  283:    MERCURY_VERIFY_BUFFER(buffer);
        -:  284:    
        -:  285:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  286:    size_t current_count, new_count;
        -:  287:    do {
    #####:  288:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  289:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  290:            return false;  // Buffer is full
        -:  291:        }
    #####:  292:        new_count = current_count + 1;
    #####:  293:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  294:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  295:    
        -:  296:    // Now we have successfully reserved a slot, get our position
    #####:  297:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    #####:  298:    head = head % buffer->capacity;  // Wrap around
        -:  299:    
        -:  300:    // Copy data to reserved slot
    #####:  301:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  302:    
        -:  303:    // Prefetch destination for write
    #####:  304:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  305:    
        -:  306:    // Prefetch next few slots for sequential writes (cache warming)
    #####:  307:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  308:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 never executed
        -:  309:    }
    #####:  310:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  311:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 never executed
        -:  312:    }
        -:  313:    
        -:  314:    // Optimized copy based on element size
        -:  315:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  316:    // to prevent compiler warnings about buffer overflows
    #####:  317:    if (buffer->element_size <= 16) {
branch  0 never executed
branch  1 never executed
        -:  318:        // Fast path for small and medium elements (most common case)
        -:  319:        memcpy(dest, element, buffer->element_size);
        -:  320:    } else {
        -:  321:        // For very large elements, still use regular memcpy for ring buffers
        -:  322:        // SIMD is not beneficial for the typical ring buffer use case
        -:  323:        memcpy(dest, element, buffer->element_size);
        -:  324:    }
        -:  325:    
        -:  326:    // Count was already updated atomically in the CAS loop above
        -:  327:    
        -:  328:    return true;
        -:  329:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 0 returned 0% blocks executed 0%
    #####:  277:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    #####:  278:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  279:        return false;
        -:  280:    }
        -:  281:    
        -:  282:    // Debug: verify buffer integrity
        -:  283:    MERCURY_VERIFY_BUFFER(buffer);
        -:  284:    
        -:  285:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  286:    size_t current_count, new_count;
        -:  287:    do {
    #####:  288:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  289:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  290:            return false;  // Buffer is full
        -:  291:        }
    #####:  292:        new_count = current_count + 1;
    #####:  293:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  294:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  295:    
        -:  296:    // Now we have successfully reserved a slot, get our position
    #####:  297:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    #####:  298:    head = head % buffer->capacity;  // Wrap around
        -:  299:    
        -:  300:    // Copy data to reserved slot
    #####:  301:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  302:    
        -:  303:    // Prefetch destination for write
    #####:  304:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  305:    
        -:  306:    // Prefetch next few slots for sequential writes (cache warming)
    #####:  307:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  308:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 never executed
        -:  309:    }
    #####:  310:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  311:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 never executed
        -:  312:    }
        -:  313:    
        -:  314:    // Optimized copy based on element size
        -:  315:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  316:    // to prevent compiler warnings about buffer overflows
    #####:  317:    if (buffer->element_size <= 16) {
branch  0 never executed
branch  1 never executed
        -:  318:        // Fast path for small and medium elements (most common case)
        -:  319:        memcpy(dest, element, buffer->element_size);
        -:  320:    } else {
        -:  321:        // For very large elements, still use regular memcpy for ring buffers
        -:  322:        // SIMD is not beneficial for the typical ring buffer use case
        -:  323:        memcpy(dest, element, buffer->element_size);
        -:  324:    }
        -:  325:    
        -:  326:    // Count was already updated atomically in the CAS loop above
        -:  327:    
        -:  328:    return true;
        -:  329:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 173 returned 100% blocks executed 92%
      173:  277:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
      173:  278:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  279:        return false;
        -:  280:    }
        -:  281:    
        -:  282:    // Debug: verify buffer integrity
        -:  283:    MERCURY_VERIFY_BUFFER(buffer);
        -:  284:    
        -:  285:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  286:    size_t current_count, new_count;
        -:  287:    do {
      173:  288:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
      173:  289:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  290:            return false;  // Buffer is full
        -:  291:        }
      173:  292:        new_count = current_count + 1;
      173:  293:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  294:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  295:    
        -:  296:    // Now we have successfully reserved a slot, get our position
      173:  297:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
      173:  298:    head = head % buffer->capacity;  // Wrap around
        -:  299:    
        -:  300:    // Copy data to reserved slot
      173:  301:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  302:    
        -:  303:    // Prefetch destination for write
      173:  304:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  305:    
        -:  306:    // Prefetch next few slots for sequential writes (cache warming)
      173:  307:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      173:  308:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 returned 100%
        -:  309:    }
      173:  310:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      173:  311:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 returned 100%
        -:  312:    }
        -:  313:    
        -:  314:    // Optimized copy based on element size
        -:  315:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  316:    // to prevent compiler warnings about buffer overflows
      173:  317:    if (buffer->element_size <= 16) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  318:        // Fast path for small and medium elements (most common case)
        -:  319:        memcpy(dest, element, buffer->element_size);
        -:  320:    } else {
        -:  321:        // For very large elements, still use regular memcpy for ring buffers
        -:  322:        // SIMD is not beneficial for the typical ring buffer use case
        -:  323:        memcpy(dest, element, buffer->element_size);
        -:  324:    }
        -:  325:    
        -:  326:    // Count was already updated atomically in the CAS loop above
        -:  327:    
        -:  328:    return true;
        -:  329:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 4105 returned 100% blocks executed 92%
     4105:  277:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
     4105:  278:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  279:        return false;
        -:  280:    }
        -:  281:    
        -:  282:    // Debug: verify buffer integrity
        -:  283:    MERCURY_VERIFY_BUFFER(buffer);
        -:  284:    
        -:  285:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  286:    size_t current_count, new_count;
        -:  287:    do {
     4105:  288:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
     4105:  289:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
        -:  290:            return false;  // Buffer is full
        -:  291:        }
     3105:  292:        new_count = current_count + 1;
     3105:  293:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  294:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  295:    
        -:  296:    // Now we have successfully reserved a slot, get our position
     3105:  297:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
     3105:  298:    head = head % buffer->capacity;  // Wrap around
        -:  299:    
        -:  300:    // Copy data to reserved slot
     3105:  301:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  302:    
        -:  303:    // Prefetch destination for write
     3105:  304:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  305:    
        -:  306:    // Prefetch next few slots for sequential writes (cache warming)
     3105:  307:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     3102:  308:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 returned 100%
        -:  309:    }
     3105:  310:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     3099:  311:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 returned 100%
        -:  312:    }
        -:  313:    
        -:  314:    // Optimized copy based on element size
        -:  315:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  316:    // to prevent compiler warnings about buffer overflows
     3105:  317:    if (buffer->element_size <= 16) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  318:        // Fast path for small and medium elements (most common case)
        -:  319:        memcpy(dest, element, buffer->element_size);
        -:  320:    } else {
        -:  321:        // For very large elements, still use regular memcpy for ring buffers
        -:  322:        // SIMD is not beneficial for the typical ring buffer use case
        -:  323:        memcpy(dest, element, buffer->element_size);
        -:  324:    }
        -:  325:    
        -:  326:    // Count was already updated atomically in the CAS loop above
        -:  327:    
        -:  328:    return true;
        -:  329:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 0 returned 0% blocks executed 0%
    #####:  277:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    #####:  278:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  279:        return false;
        -:  280:    }
        -:  281:    
        -:  282:    // Debug: verify buffer integrity
        -:  283:    MERCURY_VERIFY_BUFFER(buffer);
        -:  284:    
        -:  285:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  286:    size_t current_count, new_count;
        -:  287:    do {
    #####:  288:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  289:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  290:            return false;  // Buffer is full
        -:  291:        }
    #####:  292:        new_count = current_count + 1;
    #####:  293:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  294:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  295:    
        -:  296:    // Now we have successfully reserved a slot, get our position
    #####:  297:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    #####:  298:    head = head % buffer->capacity;  // Wrap around
        -:  299:    
        -:  300:    // Copy data to reserved slot
    #####:  301:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  302:    
        -:  303:    // Prefetch destination for write
    #####:  304:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  305:    
        -:  306:    // Prefetch next few slots for sequential writes (cache warming)
    #####:  307:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  308:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 never executed
        -:  309:    }
    #####:  310:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  311:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 never executed
        -:  312:    }
        -:  313:    
        -:  314:    // Optimized copy based on element size
        -:  315:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  316:    // to prevent compiler warnings about buffer overflows
    #####:  317:    if (buffer->element_size <= 16) {
branch  0 never executed
branch  1 never executed
        -:  318:        // Fast path for small and medium elements (most common case)
        -:  319:        memcpy(dest, element, buffer->element_size);
        -:  320:    } else {
        -:  321:        // For very large elements, still use regular memcpy for ring buffers
        -:  322:        // SIMD is not beneficial for the typical ring buffer use case
        -:  323:        memcpy(dest, element, buffer->element_size);
        -:  324:    }
        -:  325:    
        -:  326:    // Count was already updated atomically in the CAS loop above
        -:  327:    
        -:  328:    return true;
        -:  329:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 0 returned 0% blocks executed 0%
    #####:  277:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    #####:  278:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  279:        return false;
        -:  280:    }
        -:  281:    
        -:  282:    // Debug: verify buffer integrity
        -:  283:    MERCURY_VERIFY_BUFFER(buffer);
        -:  284:    
        -:  285:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  286:    size_t current_count, new_count;
        -:  287:    do {
    #####:  288:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  289:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  290:            return false;  // Buffer is full
        -:  291:        }
    #####:  292:        new_count = current_count + 1;
    #####:  293:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  294:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  295:    
        -:  296:    // Now we have successfully reserved a slot, get our position
    #####:  297:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    #####:  298:    head = head % buffer->capacity;  // Wrap around
        -:  299:    
        -:  300:    // Copy data to reserved slot
    #####:  301:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  302:    
        -:  303:    // Prefetch destination for write
    #####:  304:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  305:    
        -:  306:    // Prefetch next few slots for sequential writes (cache warming)
    #####:  307:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  308:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 never executed
        -:  309:    }
    #####:  310:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  311:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 never executed
        -:  312:    }
        -:  313:    
        -:  314:    // Optimized copy based on element size
        -:  315:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  316:    // to prevent compiler warnings about buffer overflows
    #####:  317:    if (buffer->element_size <= 16) {
branch  0 never executed
branch  1 never executed
        -:  318:        // Fast path for small and medium elements (most common case)
        -:  319:        memcpy(dest, element, buffer->element_size);
        -:  320:    } else {
        -:  321:        // For very large elements, still use regular memcpy for ring buffers
        -:  322:        // SIMD is not beneficial for the typical ring buffer use case
        -:  323:        memcpy(dest, element, buffer->element_size);
        -:  324:    }
        -:  325:    
        -:  326:    // Count was already updated atomically in the CAS loop above
        -:  327:    
        -:  328:    return true;
        -:  329:}
------------------
mercury_ring_buffer_push:
function mercury_ring_buffer_push called 0 returned 0% blocks executed 0%
    #####:  277:bool mercury_ring_buffer_push(MercuryRingBuffer* buffer, const void* element) {
    #####:  278:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  279:        return false;
        -:  280:    }
        -:  281:    
        -:  282:    // Debug: verify buffer integrity
        -:  283:    MERCURY_VERIFY_BUFFER(buffer);
        -:  284:    
        -:  285:    // Atomic CAS loop to ensure we don't exceed capacity
        -:  286:    size_t current_count, new_count;
        -:  287:    do {
    #####:  288:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  289:        if (MERCURY_UNLIKELY(current_count >= buffer->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  290:            return false;  // Buffer is full
        -:  291:        }
    #####:  292:        new_count = current_count + 1;
    #####:  293:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  294:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  295:    
        -:  296:    // Now we have successfully reserved a slot, get our position
    #####:  297:    size_t head = atomic_fetch_add_explicit(&buffer->head, 1, memory_order_acq_rel);
    #####:  298:    head = head % buffer->capacity;  // Wrap around
        -:  299:    
        -:  300:    // Copy data to reserved slot
    #####:  301:    char* dest = (char*)buffer->data + (head * buffer->element_size);
        -:  302:    
        -:  303:    // Prefetch destination for write
    #####:  304:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  305:    
        -:  306:    // Prefetch next few slots for sequential writes (cache warming)
    #####:  307:    if (MERCURY_LIKELY(head + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  308:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 1) * buffer->element_size));
call    0 never executed
        -:  309:    }
    #####:  310:    if (MERCURY_LIKELY(head + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  311:        MERCURY_PREFETCH_WRITE_LOW((char*)buffer->data + ((head + 2) * buffer->element_size));
call    0 never executed
        -:  312:    }
        -:  313:    
        -:  314:    // Optimized copy based on element size
        -:  315:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  316:    // to prevent compiler warnings about buffer overflows
    #####:  317:    if (buffer->element_size <= 16) {
branch  0 never executed
branch  1 never executed
        -:  318:        // Fast path for small and medium elements (most common case)
        -:  319:        memcpy(dest, element, buffer->element_size);
        -:  320:    } else {
        -:  321:        // For very large elements, still use regular memcpy for ring buffers
        -:  322:        // SIMD is not beneficial for the typical ring buffer use case
        -:  323:        memcpy(dest, element, buffer->element_size);
        -:  324:    }
        -:  325:    
        -:  326:    // Count was already updated atomically in the CAS loop above
        -:  327:    
        -:  328:    return true;
        -:  329:}
------------------
        -:  330:
        -:  331:/**
        -:  332: * @brief Pop element from ring buffer (thread-safe)
        -:  333: * 
        -:  334: * @details Uses lock-free atomic operations for thread-safe removal.
        -:  335: * Optimized with cache prefetching for sequential access patterns.
        -:  336: * 
        -:  337: * @param buffer Ring buffer to pop from
        -:  338: * @param element Pointer to store popped element data
        -:  339: * @return true if successful, false if buffer is empty or invalid
        -:  340: * 
        -:  341: * @warning Does not block - returns false immediately if empty
        -:  342: * @note Thread-safe with multiple consumers
        -:  343: */
    3519*:  344:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    3519*:  345:    if (MERCURY_UNLIKELY(!buffer || !element)) {
        -:  346:        return false;
        -:  347:    }
        -:  348:    
        -:  349:    // Debug: verify buffer integrity
        -:  350:    MERCURY_VERIFY_BUFFER(buffer);
        -:  351:    
        -:  352:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  353:    size_t current_count, new_count;
        -:  354:    do {
    3519*:  355:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    3519*:  356:        if (MERCURY_UNLIKELY(current_count == 0)) {
        -:  357:            return false;  // Buffer is empty
        -:  358:        }
    3488*:  359:        new_count = current_count - 1;
    3488*:  360:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
        -:  361:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  362:    
        -:  363:    // Now we have successfully reserved a slot, get our position
    3488*:  364:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    3488*:  365:    tail = tail % buffer->capacity;  // Wrap around
        -:  366:    
        -:  367:    // Copy data from reserved slot
    3488*:  368:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  369:    
        -:  370:    // Prefetch source for read
    3488*:  371:    MERCURY_PREFETCH_READ(src);
        -:  372:    
        -:  373:    // Prefetch next few slots for sequential reads (cache warming)
    3488*:  374:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
    3478*:  375:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
        -:  376:    }
    3488*:  377:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
    3470*:  378:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
        -:  379:    }
        -:  380:    
        -:  381:    // Optimized copy based on element size
        -:  382:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  383:    // to prevent compiler warnings about buffer overflows
    3488*:  384:    if (buffer->element_size <= 16) {
        -:  385:        // Fast path for small and medium elements (most common case)
        -:  386:        memcpy(element, src, buffer->element_size);
        -:  387:    } else {
        -:  388:        // For very large elements, still use regular memcpy for ring buffers
        -:  389:        // SIMD is not beneficial for the typical ring buffer use case
        -:  390:        memcpy(element, src, buffer->element_size);
        -:  391:    }
        -:  392:    
        -:  393:    // Count was already updated atomically in the CAS loop above
        -:  394:    
        -:  395:    return true;
        -:  396:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 204 returned 100% blocks executed 92%
      204:  344:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
      204:  345:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  346:        return false;
        -:  347:    }
        -:  348:    
        -:  349:    // Debug: verify buffer integrity
        -:  350:    MERCURY_VERIFY_BUFFER(buffer);
        -:  351:    
        -:  352:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  353:    size_t current_count, new_count;
        -:  354:    do {
      204:  355:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
      204:  356:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
        -:  357:            return false;  // Buffer is empty
        -:  358:        }
      200:  359:        new_count = current_count - 1;
      200:  360:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  361:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  362:    
        -:  363:    // Now we have successfully reserved a slot, get our position
      200:  364:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
      200:  365:    tail = tail % buffer->capacity;  // Wrap around
        -:  366:    
        -:  367:    // Copy data from reserved slot
      200:  368:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  369:    
        -:  370:    // Prefetch source for read
      200:  371:    MERCURY_PREFETCH_READ(src);
call    0 returned 100%
        -:  372:    
        -:  373:    // Prefetch next few slots for sequential reads (cache warming)
      200:  374:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
      197:  375:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 returned 100%
        -:  376:    }
      200:  377:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
      194:  378:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 returned 100%
        -:  379:    }
        -:  380:    
        -:  381:    // Optimized copy based on element size
        -:  382:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  383:    // to prevent compiler warnings about buffer overflows
      200:  384:    if (buffer->element_size <= 16) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  385:        // Fast path for small and medium elements (most common case)
        -:  386:        memcpy(element, src, buffer->element_size);
        -:  387:    } else {
        -:  388:        // For very large elements, still use regular memcpy for ring buffers
        -:  389:        // SIMD is not beneficial for the typical ring buffer use case
        -:  390:        memcpy(element, src, buffer->element_size);
        -:  391:    }
        -:  392:    
        -:  393:    // Count was already updated atomically in the CAS loop above
        -:  394:    
        -:  395:    return true;
        -:  396:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 11 returned 100% blocks executed 100%
       11:  344:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
       11:  345:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  346:        return false;
        -:  347:    }
        -:  348:    
        -:  349:    // Debug: verify buffer integrity
        -:  350:    MERCURY_VERIFY_BUFFER(buffer);
        -:  351:    
        -:  352:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  353:    size_t current_count, new_count;
        -:  354:    do {
       11:  355:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
       11:  356:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 taken 73% (fallthrough)
branch  1 taken 27%
        -:  357:            return false;  // Buffer is empty
        -:  358:        }
        8:  359:        new_count = current_count - 1;
        8:  360:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  361:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  362:    
        -:  363:    // Now we have successfully reserved a slot, get our position
        8:  364:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
        8:  365:    tail = tail % buffer->capacity;  // Wrap around
        -:  366:    
        -:  367:    // Copy data from reserved slot
        8:  368:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  369:    
        -:  370:    // Prefetch source for read
        8:  371:    MERCURY_PREFETCH_READ(src);
call    0 returned 100%
        -:  372:    
        -:  373:    // Prefetch next few slots for sequential reads (cache warming)
        8:  374:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
        5:  375:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 returned 100%
        -:  376:    }
        8:  377:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
        3:  378:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 returned 100%
        -:  379:    }
        -:  380:    
        -:  381:    // Optimized copy based on element size
        -:  382:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  383:    // to prevent compiler warnings about buffer overflows
        8:  384:    if (buffer->element_size <= 16) {
branch  0 taken 62% (fallthrough)
branch  1 taken 38%
        -:  385:        // Fast path for small and medium elements (most common case)
        -:  386:        memcpy(element, src, buffer->element_size);
        -:  387:    } else {
        -:  388:        // For very large elements, still use regular memcpy for ring buffers
        -:  389:        // SIMD is not beneficial for the typical ring buffer use case
        -:  390:        memcpy(element, src, buffer->element_size);
        -:  391:    }
        -:  392:    
        -:  393:    // Count was already updated atomically in the CAS loop above
        -:  394:    
        -:  395:    return true;
        -:  396:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 3 returned 100% blocks executed 100%
        3:  344:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
        3:  345:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  346:        return false;
        -:  347:    }
        -:  348:    
        -:  349:    // Debug: verify buffer integrity
        -:  350:    MERCURY_VERIFY_BUFFER(buffer);
        -:  351:    
        -:  352:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  353:    size_t current_count, new_count;
        -:  354:    do {
        3:  355:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
        3:  356:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -:  357:            return false;  // Buffer is empty
        -:  358:        }
        2:  359:        new_count = current_count - 1;
        2:  360:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  361:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  362:    
        -:  363:    // Now we have successfully reserved a slot, get our position
        2:  364:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
        2:  365:    tail = tail % buffer->capacity;  // Wrap around
        -:  366:    
        -:  367:    // Copy data from reserved slot
        2:  368:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  369:    
        -:  370:    // Prefetch source for read
        2:  371:    MERCURY_PREFETCH_READ(src);
call    0 returned 100%
        -:  372:    
        -:  373:    // Prefetch next few slots for sequential reads (cache warming)
        2:  374:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:  375:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 returned 100%
        -:  376:    }
        2:  377:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        1:  378:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 returned 100%
        -:  379:    }
        -:  380:    
        -:  381:    // Optimized copy based on element size
        -:  382:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  383:    // to prevent compiler warnings about buffer overflows
        2:  384:    if (buffer->element_size <= 16) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  385:        // Fast path for small and medium elements (most common case)
        -:  386:        memcpy(element, src, buffer->element_size);
        -:  387:    } else {
        -:  388:        // For very large elements, still use regular memcpy for ring buffers
        -:  389:        // SIMD is not beneficial for the typical ring buffer use case
        -:  390:        memcpy(element, src, buffer->element_size);
        -:  391:    }
        -:  392:    
        -:  393:    // Count was already updated atomically in the CAS loop above
        -:  394:    
        -:  395:    return true;
        -:  396:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 0 returned 0% blocks executed 0%
    #####:  344:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    #####:  345:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  346:        return false;
        -:  347:    }
        -:  348:    
        -:  349:    // Debug: verify buffer integrity
        -:  350:    MERCURY_VERIFY_BUFFER(buffer);
        -:  351:    
        -:  352:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  353:    size_t current_count, new_count;
        -:  354:    do {
    #####:  355:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  356:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 never executed
branch  1 never executed
        -:  357:            return false;  // Buffer is empty
        -:  358:        }
    #####:  359:        new_count = current_count - 1;
    #####:  360:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  361:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  362:    
        -:  363:    // Now we have successfully reserved a slot, get our position
    #####:  364:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    #####:  365:    tail = tail % buffer->capacity;  // Wrap around
        -:  366:    
        -:  367:    // Copy data from reserved slot
    #####:  368:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  369:    
        -:  370:    // Prefetch source for read
    #####:  371:    MERCURY_PREFETCH_READ(src);
call    0 never executed
        -:  372:    
        -:  373:    // Prefetch next few slots for sequential reads (cache warming)
    #####:  374:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  375:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 never executed
        -:  376:    }
    #####:  377:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  378:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 never executed
        -:  379:    }
        -:  380:    
        -:  381:    // Optimized copy based on element size
        -:  382:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  383:    // to prevent compiler warnings about buffer overflows
    #####:  384:    if (buffer->element_size <= 16) {
branch  0 never executed
branch  1 never executed
        -:  385:        // Fast path for small and medium elements (most common case)
        -:  386:        memcpy(element, src, buffer->element_size);
        -:  387:    } else {
        -:  388:        // For very large elements, still use regular memcpy for ring buffers
        -:  389:        // SIMD is not beneficial for the typical ring buffer use case
        -:  390:        memcpy(element, src, buffer->element_size);
        -:  391:    }
        -:  392:    
        -:  393:    // Count was already updated atomically in the CAS loop above
        -:  394:    
        -:  395:    return true;
        -:  396:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 0 returned 0% blocks executed 0%
    #####:  344:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    #####:  345:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  346:        return false;
        -:  347:    }
        -:  348:    
        -:  349:    // Debug: verify buffer integrity
        -:  350:    MERCURY_VERIFY_BUFFER(buffer);
        -:  351:    
        -:  352:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  353:    size_t current_count, new_count;
        -:  354:    do {
    #####:  355:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  356:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 never executed
branch  1 never executed
        -:  357:            return false;  // Buffer is empty
        -:  358:        }
    #####:  359:        new_count = current_count - 1;
    #####:  360:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  361:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  362:    
        -:  363:    // Now we have successfully reserved a slot, get our position
    #####:  364:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    #####:  365:    tail = tail % buffer->capacity;  // Wrap around
        -:  366:    
        -:  367:    // Copy data from reserved slot
    #####:  368:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  369:    
        -:  370:    // Prefetch source for read
    #####:  371:    MERCURY_PREFETCH_READ(src);
call    0 never executed
        -:  372:    
        -:  373:    // Prefetch next few slots for sequential reads (cache warming)
    #####:  374:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  375:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 never executed
        -:  376:    }
    #####:  377:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  378:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 never executed
        -:  379:    }
        -:  380:    
        -:  381:    // Optimized copy based on element size
        -:  382:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  383:    // to prevent compiler warnings about buffer overflows
    #####:  384:    if (buffer->element_size <= 16) {
branch  0 never executed
branch  1 never executed
        -:  385:        // Fast path for small and medium elements (most common case)
        -:  386:        memcpy(element, src, buffer->element_size);
        -:  387:    } else {
        -:  388:        // For very large elements, still use regular memcpy for ring buffers
        -:  389:        // SIMD is not beneficial for the typical ring buffer use case
        -:  390:        memcpy(element, src, buffer->element_size);
        -:  391:    }
        -:  392:    
        -:  393:    // Count was already updated atomically in the CAS loop above
        -:  394:    
        -:  395:    return true;
        -:  396:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 0 returned 0% blocks executed 0%
    #####:  344:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    #####:  345:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  346:        return false;
        -:  347:    }
        -:  348:    
        -:  349:    // Debug: verify buffer integrity
        -:  350:    MERCURY_VERIFY_BUFFER(buffer);
        -:  351:    
        -:  352:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  353:    size_t current_count, new_count;
        -:  354:    do {
    #####:  355:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  356:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 never executed
branch  1 never executed
        -:  357:            return false;  // Buffer is empty
        -:  358:        }
    #####:  359:        new_count = current_count - 1;
    #####:  360:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  361:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  362:    
        -:  363:    // Now we have successfully reserved a slot, get our position
    #####:  364:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    #####:  365:    tail = tail % buffer->capacity;  // Wrap around
        -:  366:    
        -:  367:    // Copy data from reserved slot
    #####:  368:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  369:    
        -:  370:    // Prefetch source for read
    #####:  371:    MERCURY_PREFETCH_READ(src);
call    0 never executed
        -:  372:    
        -:  373:    // Prefetch next few slots for sequential reads (cache warming)
    #####:  374:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  375:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 never executed
        -:  376:    }
    #####:  377:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  378:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 never executed
        -:  379:    }
        -:  380:    
        -:  381:    // Optimized copy based on element size
        -:  382:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  383:    // to prevent compiler warnings about buffer overflows
    #####:  384:    if (buffer->element_size <= 16) {
branch  0 never executed
branch  1 never executed
        -:  385:        // Fast path for small and medium elements (most common case)
        -:  386:        memcpy(element, src, buffer->element_size);
        -:  387:    } else {
        -:  388:        // For very large elements, still use regular memcpy for ring buffers
        -:  389:        // SIMD is not beneficial for the typical ring buffer use case
        -:  390:        memcpy(element, src, buffer->element_size);
        -:  391:    }
        -:  392:    
        -:  393:    // Count was already updated atomically in the CAS loop above
        -:  394:    
        -:  395:    return true;
        -:  396:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 179 returned 100% blocks executed 92%
      179:  344:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
      179:  345:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  346:        return false;
        -:  347:    }
        -:  348:    
        -:  349:    // Debug: verify buffer integrity
        -:  350:    MERCURY_VERIFY_BUFFER(buffer);
        -:  351:    
        -:  352:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  353:    size_t current_count, new_count;
        -:  354:    do {
      179:  355:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
      179:  356:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
        -:  357:            return false;  // Buffer is empty
        -:  358:        }
      173:  359:        new_count = current_count - 1;
      173:  360:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  361:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  362:    
        -:  363:    // Now we have successfully reserved a slot, get our position
      173:  364:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
      173:  365:    tail = tail % buffer->capacity;  // Wrap around
        -:  366:    
        -:  367:    // Copy data from reserved slot
      173:  368:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  369:    
        -:  370:    // Prefetch source for read
      173:  371:    MERCURY_PREFETCH_READ(src);
call    0 returned 100%
        -:  372:    
        -:  373:    // Prefetch next few slots for sequential reads (cache warming)
      173:  374:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      173:  375:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 returned 100%
        -:  376:    }
      173:  377:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      173:  378:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 returned 100%
        -:  379:    }
        -:  380:    
        -:  381:    // Optimized copy based on element size
        -:  382:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  383:    // to prevent compiler warnings about buffer overflows
      173:  384:    if (buffer->element_size <= 16) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  385:        // Fast path for small and medium elements (most common case)
        -:  386:        memcpy(element, src, buffer->element_size);
        -:  387:    } else {
        -:  388:        // For very large elements, still use regular memcpy for ring buffers
        -:  389:        // SIMD is not beneficial for the typical ring buffer use case
        -:  390:        memcpy(element, src, buffer->element_size);
        -:  391:    }
        -:  392:    
        -:  393:    // Count was already updated atomically in the CAS loop above
        -:  394:    
        -:  395:    return true;
        -:  396:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 3122 returned 100% blocks executed 92%
     3122:  344:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
     3122:  345:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  346:        return false;
        -:  347:    }
        -:  348:    
        -:  349:    // Debug: verify buffer integrity
        -:  350:    MERCURY_VERIFY_BUFFER(buffer);
        -:  351:    
        -:  352:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  353:    size_t current_count, new_count;
        -:  354:    do {
     3122:  355:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
     3122:  356:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  357:            return false;  // Buffer is empty
        -:  358:        }
     3105:  359:        new_count = current_count - 1;
     3105:  360:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -:  361:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  362:    
        -:  363:    // Now we have successfully reserved a slot, get our position
     3105:  364:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
     3105:  365:    tail = tail % buffer->capacity;  // Wrap around
        -:  366:    
        -:  367:    // Copy data from reserved slot
     3105:  368:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  369:    
        -:  370:    // Prefetch source for read
     3105:  371:    MERCURY_PREFETCH_READ(src);
call    0 returned 100%
        -:  372:    
        -:  373:    // Prefetch next few slots for sequential reads (cache warming)
     3105:  374:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     3102:  375:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 returned 100%
        -:  376:    }
     3105:  377:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
     3099:  378:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 returned 100%
        -:  379:    }
        -:  380:    
        -:  381:    // Optimized copy based on element size
        -:  382:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  383:    // to prevent compiler warnings about buffer overflows
     3105:  384:    if (buffer->element_size <= 16) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  385:        // Fast path for small and medium elements (most common case)
        -:  386:        memcpy(element, src, buffer->element_size);
        -:  387:    } else {
        -:  388:        // For very large elements, still use regular memcpy for ring buffers
        -:  389:        // SIMD is not beneficial for the typical ring buffer use case
        -:  390:        memcpy(element, src, buffer->element_size);
        -:  391:    }
        -:  392:    
        -:  393:    // Count was already updated atomically in the CAS loop above
        -:  394:    
        -:  395:    return true;
        -:  396:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 0 returned 0% blocks executed 0%
    #####:  344:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    #####:  345:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  346:        return false;
        -:  347:    }
        -:  348:    
        -:  349:    // Debug: verify buffer integrity
        -:  350:    MERCURY_VERIFY_BUFFER(buffer);
        -:  351:    
        -:  352:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  353:    size_t current_count, new_count;
        -:  354:    do {
    #####:  355:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  356:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 never executed
branch  1 never executed
        -:  357:            return false;  // Buffer is empty
        -:  358:        }
    #####:  359:        new_count = current_count - 1;
    #####:  360:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  361:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  362:    
        -:  363:    // Now we have successfully reserved a slot, get our position
    #####:  364:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    #####:  365:    tail = tail % buffer->capacity;  // Wrap around
        -:  366:    
        -:  367:    // Copy data from reserved slot
    #####:  368:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  369:    
        -:  370:    // Prefetch source for read
    #####:  371:    MERCURY_PREFETCH_READ(src);
call    0 never executed
        -:  372:    
        -:  373:    // Prefetch next few slots for sequential reads (cache warming)
    #####:  374:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  375:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 never executed
        -:  376:    }
    #####:  377:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  378:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 never executed
        -:  379:    }
        -:  380:    
        -:  381:    // Optimized copy based on element size
        -:  382:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  383:    // to prevent compiler warnings about buffer overflows
    #####:  384:    if (buffer->element_size <= 16) {
branch  0 never executed
branch  1 never executed
        -:  385:        // Fast path for small and medium elements (most common case)
        -:  386:        memcpy(element, src, buffer->element_size);
        -:  387:    } else {
        -:  388:        // For very large elements, still use regular memcpy for ring buffers
        -:  389:        // SIMD is not beneficial for the typical ring buffer use case
        -:  390:        memcpy(element, src, buffer->element_size);
        -:  391:    }
        -:  392:    
        -:  393:    // Count was already updated atomically in the CAS loop above
        -:  394:    
        -:  395:    return true;
        -:  396:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 0 returned 0% blocks executed 0%
    #####:  344:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    #####:  345:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  346:        return false;
        -:  347:    }
        -:  348:    
        -:  349:    // Debug: verify buffer integrity
        -:  350:    MERCURY_VERIFY_BUFFER(buffer);
        -:  351:    
        -:  352:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  353:    size_t current_count, new_count;
        -:  354:    do {
    #####:  355:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  356:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 never executed
branch  1 never executed
        -:  357:            return false;  // Buffer is empty
        -:  358:        }
    #####:  359:        new_count = current_count - 1;
    #####:  360:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  361:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  362:    
        -:  363:    // Now we have successfully reserved a slot, get our position
    #####:  364:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    #####:  365:    tail = tail % buffer->capacity;  // Wrap around
        -:  366:    
        -:  367:    // Copy data from reserved slot
    #####:  368:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  369:    
        -:  370:    // Prefetch source for read
    #####:  371:    MERCURY_PREFETCH_READ(src);
call    0 never executed
        -:  372:    
        -:  373:    // Prefetch next few slots for sequential reads (cache warming)
    #####:  374:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  375:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 never executed
        -:  376:    }
    #####:  377:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  378:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 never executed
        -:  379:    }
        -:  380:    
        -:  381:    // Optimized copy based on element size
        -:  382:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  383:    // to prevent compiler warnings about buffer overflows
    #####:  384:    if (buffer->element_size <= 16) {
branch  0 never executed
branch  1 never executed
        -:  385:        // Fast path for small and medium elements (most common case)
        -:  386:        memcpy(element, src, buffer->element_size);
        -:  387:    } else {
        -:  388:        // For very large elements, still use regular memcpy for ring buffers
        -:  389:        // SIMD is not beneficial for the typical ring buffer use case
        -:  390:        memcpy(element, src, buffer->element_size);
        -:  391:    }
        -:  392:    
        -:  393:    // Count was already updated atomically in the CAS loop above
        -:  394:    
        -:  395:    return true;
        -:  396:}
------------------
mercury_ring_buffer_pop:
function mercury_ring_buffer_pop called 0 returned 0% blocks executed 0%
    #####:  344:bool mercury_ring_buffer_pop(MercuryRingBuffer* buffer, void* element) {
    #####:  345:    if (MERCURY_UNLIKELY(!buffer || !element)) {
branch  0 never executed
branch  1 never executed
        -:  346:        return false;
        -:  347:    }
        -:  348:    
        -:  349:    // Debug: verify buffer integrity
        -:  350:    MERCURY_VERIFY_BUFFER(buffer);
        -:  351:    
        -:  352:    // Atomic CAS loop to ensure we don't pop from empty buffer
        -:  353:    size_t current_count, new_count;
        -:  354:    do {
    #####:  355:        current_count = atomic_load_explicit(&buffer->count, memory_order_acquire);
    #####:  356:        if (MERCURY_UNLIKELY(current_count == 0)) {
branch  0 never executed
branch  1 never executed
        -:  357:            return false;  // Buffer is empty
        -:  358:        }
    #####:  359:        new_count = current_count - 1;
    #####:  360:    } while (!atomic_compare_exchange_weak_explicit(&buffer->count, &current_count, new_count,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  361:                                                    memory_order_acq_rel, memory_order_acquire));
        -:  362:    
        -:  363:    // Now we have successfully reserved a slot, get our position
    #####:  364:    size_t tail = atomic_fetch_add_explicit(&buffer->tail, 1, memory_order_acq_rel);
    #####:  365:    tail = tail % buffer->capacity;  // Wrap around
        -:  366:    
        -:  367:    // Copy data from reserved slot
    #####:  368:    const char* src = (const char*)buffer->data + (tail * buffer->element_size);
        -:  369:    
        -:  370:    // Prefetch source for read
    #####:  371:    MERCURY_PREFETCH_READ(src);
call    0 never executed
        -:  372:    
        -:  373:    // Prefetch next few slots for sequential reads (cache warming)
    #####:  374:    if (MERCURY_LIKELY(tail + 1 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  375:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 1) * buffer->element_size));
call    0 never executed
        -:  376:    }
    #####:  377:    if (MERCURY_LIKELY(tail + 2 < buffer->capacity)) {
branch  0 never executed
branch  1 never executed
    #####:  378:        MERCURY_PREFETCH_READ_LOW((const char*)buffer->data + ((tail + 2) * buffer->element_size));
call    0 never executed
        -:  379:    }
        -:  380:    
        -:  381:    // Optimized copy based on element size
        -:  382:    // NOTE: Ring buffers typically handle small elements, so we avoid SIMD
        -:  383:    // to prevent compiler warnings about buffer overflows
    #####:  384:    if (buffer->element_size <= 16) {
branch  0 never executed
branch  1 never executed
        -:  385:        // Fast path for small and medium elements (most common case)
        -:  386:        memcpy(element, src, buffer->element_size);
        -:  387:    } else {
        -:  388:        // For very large elements, still use regular memcpy for ring buffers
        -:  389:        // SIMD is not beneficial for the typical ring buffer use case
        -:  390:        memcpy(element, src, buffer->element_size);
        -:  391:    }
        -:  392:    
        -:  393:    // Count was already updated atomically in the CAS loop above
        -:  394:    
        -:  395:    return true;
        -:  396:}
------------------
        -:  397:
       2*:  398:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
       2*:  399:    if (!buffer) return 0;
       2*:  400:    return atomic_load(&buffer->count);
        -:  401:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  398:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  399:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  400:    return atomic_load(&buffer->count);
        -:  401:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 2 returned 100% blocks executed 100%
        2:  398:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
        2:  399:    if (!buffer) return 0;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  400:    return atomic_load(&buffer->count);
        -:  401:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  398:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  399:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  400:    return atomic_load(&buffer->count);
        -:  401:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  398:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  399:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  400:    return atomic_load(&buffer->count);
        -:  401:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  398:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  399:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  400:    return atomic_load(&buffer->count);
        -:  401:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  398:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  399:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  400:    return atomic_load(&buffer->count);
        -:  401:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  398:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  399:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  400:    return atomic_load(&buffer->count);
        -:  401:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  398:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  399:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  400:    return atomic_load(&buffer->count);
        -:  401:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  398:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  399:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  400:    return atomic_load(&buffer->count);
        -:  401:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  398:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  399:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  400:    return atomic_load(&buffer->count);
        -:  401:}
------------------
mercury_ring_buffer_size:
function mercury_ring_buffer_size called 0 returned 0% blocks executed 0%
    #####:  398:size_t mercury_ring_buffer_size(const MercuryRingBuffer* buffer) {
    #####:  399:    if (!buffer) return 0;
branch  0 never executed
branch  1 never executed
    #####:  400:    return atomic_load(&buffer->count);
        -:  401:}
------------------
        -:  402:
       4*:  403:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
       4*:  404:    if (!buffer) return true;
       4*:  405:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  406:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  403:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  404:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  405:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  406:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 4 returned 100% blocks executed 100%
        4:  403:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
        4:  404:    if (!buffer) return true;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4:  405:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  406:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  403:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  404:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  405:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  406:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  403:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  404:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  405:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  406:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  403:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  404:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  405:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  406:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  403:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  404:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  405:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  406:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  403:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  404:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  405:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  406:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  403:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  404:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  405:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  406:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  403:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  404:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  405:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  406:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  403:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  404:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  405:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  406:}
------------------
mercury_ring_buffer_is_full:
function mercury_ring_buffer_is_full called 0 returned 0% blocks executed 0%
    #####:  403:bool mercury_ring_buffer_is_full(const MercuryRingBuffer* buffer) {
    #####:  404:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  405:    return atomic_load(&buffer->count) >= buffer->capacity;
        -:  406:}
------------------
        -:  407:
       5*:  408:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
       5*:  409:    if (!buffer) return true;
       5*:  410:    return atomic_load(&buffer->count) == 0;
        -:  411:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 1 returned 100% blocks executed 100%
        1:  408:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
        1:  409:    if (!buffer) return true;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  410:    return atomic_load(&buffer->count) == 0;
        -:  411:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 4 returned 100% blocks executed 100%
        4:  408:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
        4:  409:    if (!buffer) return true;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4:  410:    return atomic_load(&buffer->count) == 0;
        -:  411:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  408:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  409:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  410:    return atomic_load(&buffer->count) == 0;
        -:  411:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  408:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  409:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  410:    return atomic_load(&buffer->count) == 0;
        -:  411:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  408:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  409:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  410:    return atomic_load(&buffer->count) == 0;
        -:  411:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  408:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  409:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  410:    return atomic_load(&buffer->count) == 0;
        -:  411:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  408:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  409:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  410:    return atomic_load(&buffer->count) == 0;
        -:  411:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  408:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  409:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  410:    return atomic_load(&buffer->count) == 0;
        -:  411:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  408:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  409:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  410:    return atomic_load(&buffer->count) == 0;
        -:  411:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  408:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  409:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  410:    return atomic_load(&buffer->count) == 0;
        -:  411:}
------------------
mercury_ring_buffer_is_empty:
function mercury_ring_buffer_is_empty called 0 returned 0% blocks executed 0%
    #####:  408:bool mercury_ring_buffer_is_empty(const MercuryRingBuffer* buffer) {
    #####:  409:    if (!buffer) return true;
branch  0 never executed
branch  1 never executed
    #####:  410:    return atomic_load(&buffer->count) == 0;
        -:  411:}
------------------
        -:  412:
        -:  413:// === STRING UTILITIES ===
        -:  414:
        -:  415:/**
        -:  416: * @brief Create a dynamic string with automatic resizing
        -:  417: * 
        -:  418: * @param initial_capacity Initial buffer size (0 for default of 256)
        -:  419: * @return Pointer to string structure or NULL on failure
        -:  420: * 
        -:  421: * @post String is initialized with empty content
        -:  422: * 
        -:  423: * @warning Caller must call mercury_string_destroy() to free
        -:  424: * @note Automatically grows as needed during append operations
        -:  425: */
      11*:  426:MercuryString* mercury_string_create(size_t initial_capacity) {
      11*:  427:    if (initial_capacity == 0) {
        -:  428:        initial_capacity = 256;  // Default capacity
        -:  429:    }
        -:  430:    
      11*:  431:    MercuryString* str = malloc(sizeof(MercuryString));
      11*:  432:    if (!str) {
    #####:  433:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  434:        return NULL;
        -:  435:    }
        -:  436:    
      11*:  437:    str->data = malloc(initial_capacity);
      11*:  438:    if (!str->data) {
    #####:  439:        free(str);
    #####:  440:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  441:        return NULL;
        -:  442:    }
        -:  443:    
      11*:  444:    str->data[0] = '\0';
      11*:  445:    str->length = 0;
      11*:  446:    str->capacity = initial_capacity;
        -:  447:    
      11*:  448:    return str;
        -:  449:}
------------------
mercury_string_create:
function mercury_string_create called 1 returned 100% blocks executed 62%
        1:  426:MercuryString* mercury_string_create(size_t initial_capacity) {
        1:  427:    if (initial_capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  428:        initial_capacity = 256;  // Default capacity
        -:  429:    }
        -:  430:    
        1:  431:    MercuryString* str = malloc(sizeof(MercuryString));
        1:  432:    if (!str) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  433:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  434:        return NULL;
        -:  435:    }
        -:  436:    
        1:  437:    str->data = malloc(initial_capacity);
        1:  438:    if (!str->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  439:        free(str);
    #####:  440:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  441:        return NULL;
        -:  442:    }
        -:  443:    
        1:  444:    str->data[0] = '\0';
        1:  445:    str->length = 0;
        1:  446:    str->capacity = initial_capacity;
        -:  447:    
        1:  448:    return str;
        -:  449:}
------------------
mercury_string_create:
function mercury_string_create called 5 returned 100% blocks executed 75%
        5:  426:MercuryString* mercury_string_create(size_t initial_capacity) {
        5:  427:    if (initial_capacity == 0) {
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        -:  428:        initial_capacity = 256;  // Default capacity
        -:  429:    }
        -:  430:    
        5:  431:    MercuryString* str = malloc(sizeof(MercuryString));
        5:  432:    if (!str) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  433:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  434:        return NULL;
        -:  435:    }
        -:  436:    
        5:  437:    str->data = malloc(initial_capacity);
        5:  438:    if (!str->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  439:        free(str);
    #####:  440:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  441:        return NULL;
        -:  442:    }
        -:  443:    
        5:  444:    str->data[0] = '\0';
        5:  445:    str->length = 0;
        5:  446:    str->capacity = initial_capacity;
        -:  447:    
        5:  448:    return str;
        -:  449:}
------------------
mercury_string_create:
function mercury_string_create called 1 returned 100% blocks executed 62%
        1:  426:MercuryString* mercury_string_create(size_t initial_capacity) {
        1:  427:    if (initial_capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  428:        initial_capacity = 256;  // Default capacity
        -:  429:    }
        -:  430:    
        1:  431:    MercuryString* str = malloc(sizeof(MercuryString));
        1:  432:    if (!str) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  433:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  434:        return NULL;
        -:  435:    }
        -:  436:    
        1:  437:    str->data = malloc(initial_capacity);
        1:  438:    if (!str->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  439:        free(str);
    #####:  440:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  441:        return NULL;
        -:  442:    }
        -:  443:    
        1:  444:    str->data[0] = '\0';
        1:  445:    str->length = 0;
        1:  446:    str->capacity = initial_capacity;
        -:  447:    
        1:  448:    return str;
        -:  449:}
------------------
mercury_string_create:
function mercury_string_create called 1 returned 100% blocks executed 62%
        1:  426:MercuryString* mercury_string_create(size_t initial_capacity) {
        1:  427:    if (initial_capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  428:        initial_capacity = 256;  // Default capacity
        -:  429:    }
        -:  430:    
        1:  431:    MercuryString* str = malloc(sizeof(MercuryString));
        1:  432:    if (!str) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  433:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  434:        return NULL;
        -:  435:    }
        -:  436:    
        1:  437:    str->data = malloc(initial_capacity);
        1:  438:    if (!str->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  439:        free(str);
    #####:  440:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  441:        return NULL;
        -:  442:    }
        -:  443:    
        1:  444:    str->data[0] = '\0';
        1:  445:    str->length = 0;
        1:  446:    str->capacity = initial_capacity;
        -:  447:    
        1:  448:    return str;
        -:  449:}
------------------
mercury_string_create:
function mercury_string_create called 0 returned 0% blocks executed 0%
    #####:  426:MercuryString* mercury_string_create(size_t initial_capacity) {
    #####:  427:    if (initial_capacity == 0) {
branch  0 never executed
branch  1 never executed
        -:  428:        initial_capacity = 256;  // Default capacity
        -:  429:    }
        -:  430:    
    #####:  431:    MercuryString* str = malloc(sizeof(MercuryString));
    #####:  432:    if (!str) {
branch  0 never executed
branch  1 never executed
    #####:  433:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  434:        return NULL;
        -:  435:    }
        -:  436:    
    #####:  437:    str->data = malloc(initial_capacity);
    #####:  438:    if (!str->data) {
branch  0 never executed
branch  1 never executed
    #####:  439:        free(str);
    #####:  440:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  441:        return NULL;
        -:  442:    }
        -:  443:    
    #####:  444:    str->data[0] = '\0';
    #####:  445:    str->length = 0;
    #####:  446:    str->capacity = initial_capacity;
        -:  447:    
    #####:  448:    return str;
        -:  449:}
------------------
mercury_string_create:
function mercury_string_create called 0 returned 0% blocks executed 0%
    #####:  426:MercuryString* mercury_string_create(size_t initial_capacity) {
    #####:  427:    if (initial_capacity == 0) {
branch  0 never executed
branch  1 never executed
        -:  428:        initial_capacity = 256;  // Default capacity
        -:  429:    }
        -:  430:    
    #####:  431:    MercuryString* str = malloc(sizeof(MercuryString));
    #####:  432:    if (!str) {
branch  0 never executed
branch  1 never executed
    #####:  433:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  434:        return NULL;
        -:  435:    }
        -:  436:    
    #####:  437:    str->data = malloc(initial_capacity);
    #####:  438:    if (!str->data) {
branch  0 never executed
branch  1 never executed
    #####:  439:        free(str);
    #####:  440:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  441:        return NULL;
        -:  442:    }
        -:  443:    
    #####:  444:    str->data[0] = '\0';
    #####:  445:    str->length = 0;
    #####:  446:    str->capacity = initial_capacity;
        -:  447:    
    #####:  448:    return str;
        -:  449:}
------------------
mercury_string_create:
function mercury_string_create called 1 returned 100% blocks executed 62%
        1:  426:MercuryString* mercury_string_create(size_t initial_capacity) {
        1:  427:    if (initial_capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  428:        initial_capacity = 256;  // Default capacity
        -:  429:    }
        -:  430:    
        1:  431:    MercuryString* str = malloc(sizeof(MercuryString));
        1:  432:    if (!str) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  433:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  434:        return NULL;
        -:  435:    }
        -:  436:    
        1:  437:    str->data = malloc(initial_capacity);
        1:  438:    if (!str->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  439:        free(str);
    #####:  440:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  441:        return NULL;
        -:  442:    }
        -:  443:    
        1:  444:    str->data[0] = '\0';
        1:  445:    str->length = 0;
        1:  446:    str->capacity = initial_capacity;
        -:  447:    
        1:  448:    return str;
        -:  449:}
------------------
mercury_string_create:
function mercury_string_create called 2 returned 100% blocks executed 62%
        2:  426:MercuryString* mercury_string_create(size_t initial_capacity) {
        2:  427:    if (initial_capacity == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  428:        initial_capacity = 256;  // Default capacity
        -:  429:    }
        -:  430:    
        2:  431:    MercuryString* str = malloc(sizeof(MercuryString));
        2:  432:    if (!str) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  433:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  434:        return NULL;
        -:  435:    }
        -:  436:    
        2:  437:    str->data = malloc(initial_capacity);
        2:  438:    if (!str->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  439:        free(str);
    #####:  440:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  441:        return NULL;
        -:  442:    }
        -:  443:    
        2:  444:    str->data[0] = '\0';
        2:  445:    str->length = 0;
        2:  446:    str->capacity = initial_capacity;
        -:  447:    
        2:  448:    return str;
        -:  449:}
------------------
mercury_string_create:
function mercury_string_create called 0 returned 0% blocks executed 0%
    #####:  426:MercuryString* mercury_string_create(size_t initial_capacity) {
    #####:  427:    if (initial_capacity == 0) {
branch  0 never executed
branch  1 never executed
        -:  428:        initial_capacity = 256;  // Default capacity
        -:  429:    }
        -:  430:    
    #####:  431:    MercuryString* str = malloc(sizeof(MercuryString));
    #####:  432:    if (!str) {
branch  0 never executed
branch  1 never executed
    #####:  433:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  434:        return NULL;
        -:  435:    }
        -:  436:    
    #####:  437:    str->data = malloc(initial_capacity);
    #####:  438:    if (!str->data) {
branch  0 never executed
branch  1 never executed
    #####:  439:        free(str);
    #####:  440:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  441:        return NULL;
        -:  442:    }
        -:  443:    
    #####:  444:    str->data[0] = '\0';
    #####:  445:    str->length = 0;
    #####:  446:    str->capacity = initial_capacity;
        -:  447:    
    #####:  448:    return str;
        -:  449:}
------------------
mercury_string_create:
function mercury_string_create called 0 returned 0% blocks executed 0%
    #####:  426:MercuryString* mercury_string_create(size_t initial_capacity) {
    #####:  427:    if (initial_capacity == 0) {
branch  0 never executed
branch  1 never executed
        -:  428:        initial_capacity = 256;  // Default capacity
        -:  429:    }
        -:  430:    
    #####:  431:    MercuryString* str = malloc(sizeof(MercuryString));
    #####:  432:    if (!str) {
branch  0 never executed
branch  1 never executed
    #####:  433:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  434:        return NULL;
        -:  435:    }
        -:  436:    
    #####:  437:    str->data = malloc(initial_capacity);
    #####:  438:    if (!str->data) {
branch  0 never executed
branch  1 never executed
    #####:  439:        free(str);
    #####:  440:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  441:        return NULL;
        -:  442:    }
        -:  443:    
    #####:  444:    str->data[0] = '\0';
    #####:  445:    str->length = 0;
    #####:  446:    str->capacity = initial_capacity;
        -:  447:    
    #####:  448:    return str;
        -:  449:}
------------------
mercury_string_create:
function mercury_string_create called 0 returned 0% blocks executed 0%
    #####:  426:MercuryString* mercury_string_create(size_t initial_capacity) {
    #####:  427:    if (initial_capacity == 0) {
branch  0 never executed
branch  1 never executed
        -:  428:        initial_capacity = 256;  // Default capacity
        -:  429:    }
        -:  430:    
    #####:  431:    MercuryString* str = malloc(sizeof(MercuryString));
    #####:  432:    if (!str) {
branch  0 never executed
branch  1 never executed
    #####:  433:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string structure");
    #####:  434:        return NULL;
        -:  435:    }
        -:  436:    
    #####:  437:    str->data = malloc(initial_capacity);
    #####:  438:    if (!str->data) {
branch  0 never executed
branch  1 never executed
    #####:  439:        free(str);
    #####:  440:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate string buffer");
    #####:  441:        return NULL;
        -:  442:    }
        -:  443:    
    #####:  444:    str->data[0] = '\0';
    #####:  445:    str->length = 0;
    #####:  446:    str->capacity = initial_capacity;
        -:  447:    
    #####:  448:    return str;
        -:  449:}
------------------
        -:  450:
      11*:  451:void mercury_string_destroy(MercuryString* str) {
      11*:  452:    if (!str) return;
        -:  453:    
      11*:  454:    free(str->data);
      11*:  455:    free(str);
        -:  456:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 1 returned 100% blocks executed 100%
        1:  451:void mercury_string_destroy(MercuryString* str) {
        1:  452:    if (!str) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  453:    
        1:  454:    free(str->data);
        1:  455:    free(str);
        -:  456:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 5 returned 100% blocks executed 100%
        5:  451:void mercury_string_destroy(MercuryString* str) {
        5:  452:    if (!str) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  453:    
        5:  454:    free(str->data);
        5:  455:    free(str);
        -:  456:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 1 returned 100% blocks executed 100%
        1:  451:void mercury_string_destroy(MercuryString* str) {
        1:  452:    if (!str) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  453:    
        1:  454:    free(str->data);
        1:  455:    free(str);
        -:  456:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 1 returned 100% blocks executed 100%
        1:  451:void mercury_string_destroy(MercuryString* str) {
        1:  452:    if (!str) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  453:    
        1:  454:    free(str->data);
        1:  455:    free(str);
        -:  456:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 0 returned 0% blocks executed 0%
    #####:  451:void mercury_string_destroy(MercuryString* str) {
    #####:  452:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  453:    
    #####:  454:    free(str->data);
    #####:  455:    free(str);
        -:  456:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 0 returned 0% blocks executed 0%
    #####:  451:void mercury_string_destroy(MercuryString* str) {
    #####:  452:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  453:    
    #####:  454:    free(str->data);
    #####:  455:    free(str);
        -:  456:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 1 returned 100% blocks executed 100%
        1:  451:void mercury_string_destroy(MercuryString* str) {
        1:  452:    if (!str) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  453:    
        1:  454:    free(str->data);
        1:  455:    free(str);
        -:  456:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 2 returned 100% blocks executed 100%
        2:  451:void mercury_string_destroy(MercuryString* str) {
        2:  452:    if (!str) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  453:    
        2:  454:    free(str->data);
        2:  455:    free(str);
        -:  456:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 0 returned 0% blocks executed 0%
    #####:  451:void mercury_string_destroy(MercuryString* str) {
    #####:  452:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  453:    
    #####:  454:    free(str->data);
    #####:  455:    free(str);
        -:  456:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 0 returned 0% blocks executed 0%
    #####:  451:void mercury_string_destroy(MercuryString* str) {
    #####:  452:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  453:    
    #####:  454:    free(str->data);
    #####:  455:    free(str);
        -:  456:}
------------------
mercury_string_destroy:
function mercury_string_destroy called 0 returned 0% blocks executed 0%
    #####:  451:void mercury_string_destroy(MercuryString* str) {
    #####:  452:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  453:    
    #####:  454:    free(str->data);
    #####:  455:    free(str);
        -:  456:}
------------------
        -:  457:
    1073*:  458:MercuryError mercury_string_append(MercuryString* str, const char* text) {
    1073*:  459:    if (MERCURY_UNLIKELY(!str || !text)) {
        -:  460:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  461:    }
        -:  462:    
    1070*:  463:    size_t text_len = strlen(text);
    1070*:  464:    if (MERCURY_UNLIKELY(text_len == 0)) {
        -:  465:        return MERCURY_SUCCESS;  // Nothing to append
        -:  466:    }
        -:  467:    
    1069*:  468:    size_t new_length = str->length + text_len;
        -:  469:    
        -:  470:    // Resize buffer if necessary with better growth strategy
    1069*:  471:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
        -:  472:        // Growth strategy: for small strings double, for large strings add 50%
        -:  473:        size_t new_capacity;
      30*:  474:        if (str->capacity < 4096) {
      21*:  475:            new_capacity = str->capacity * 2;
        -:  476:        } else {
       9*:  477:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  478:        }
        -:  479:        
        -:  480:        // Ensure we have enough space
      30*:  481:        if (new_capacity <= new_length) {
       3*:  482:            new_capacity = new_length + 256;  // Add some padding
        -:  483:        }
        -:  484:        
      30*:  485:        char* new_data = realloc(str->data, new_capacity);
      30*:  486:        if (MERCURY_UNLIKELY(!new_data)) {
    #####:  487:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  488:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  489:        }
        -:  490:        
      30*:  491:        str->data = new_data;
      30*:  492:        str->capacity = new_capacity;
        -:  493:    }
        -:  494:    
        -:  495:    // Use optimized copy based on text length
    1069*:  496:    char* dest = str->data + str->length;
        -:  497:    
        -:  498:    // Prefetch destination for write operations
    1069*:  499:    MERCURY_PREFETCH_WRITE(dest);
        -:  500:    
        -:  501:    // For larger strings, prefetch additional cache lines
    1069*:  502:    if (text_len >= 64) {
      18*:  503:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
        -:  504:    }
    1069*:  505:    if (text_len >= 128) {
      15*:  506:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
        -:  507:    }
        -:  508:    
    1069*:  509:    if (text_len >= 32) {
        -:  510:        // SIMD path for large appends
      19*:  511:        mercury_memcpy_simd(dest, text, text_len);
    1050*:  512:    } else if (text_len >= 8) {
        -:  513:        // Use 64-bit copies for medium strings
        -:  514:        const uint64_t* src64 = (const uint64_t*)text;
        -:  515:        uint64_t* dest64 = (uint64_t*)dest;
     993*:  516:        size_t chunks = text_len / 8;
     993*:  517:        size_t remainder = text_len % 8;
        -:  518:        
    1987*:  519:        for (size_t i = 0; i < chunks; i++) {
     994*:  520:            dest64[i] = src64[i];
        -:  521:        }
        -:  522:        
        -:  523:        // Handle remainder
     993*:  524:        if (remainder > 0) {
     901*:  525:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  526:        }
        -:  527:    } else {
        -:  528:        // Fast path for small strings
        -:  529:        memcpy(dest, text, text_len);
        -:  530:    }
        -:  531:    
    1069*:  532:    str->length = new_length;
    1069*:  533:    str->data[str->length] = '\0';
        -:  534:    
    1069*:  535:    return MERCURY_SUCCESS;
        -:  536:}
------------------
mercury_string_append:
function mercury_string_append called 1000 returned 100% blocks executed 81%
     1000:  458:MercuryError mercury_string_append(MercuryString* str, const char* text) {
     1000:  459:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  460:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  461:    }
        -:  462:    
     1000:  463:    size_t text_len = strlen(text);
     1000:  464:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  465:        return MERCURY_SUCCESS;  // Nothing to append
        -:  466:    }
        -:  467:    
     1000:  468:    size_t new_length = str->length + text_len;
        -:  469:    
        -:  470:    // Resize buffer if necessary with better growth strategy
     1000:  471:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  472:        // Growth strategy: for small strings double, for large strings add 50%
        -:  473:        size_t new_capacity;
       10:  474:        if (str->capacity < 4096) {
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        8:  475:            new_capacity = str->capacity * 2;
        -:  476:        } else {
        2:  477:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  478:        }
        -:  479:        
        -:  480:        // Ensure we have enough space
       10:  481:        if (new_capacity <= new_length) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  482:            new_capacity = new_length + 256;  // Add some padding
        -:  483:        }
        -:  484:        
       10:  485:        char* new_data = realloc(str->data, new_capacity);
       10:  486:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  487:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  488:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  489:        }
        -:  490:        
       10:  491:        str->data = new_data;
       10:  492:        str->capacity = new_capacity;
        -:  493:    }
        -:  494:    
        -:  495:    // Use optimized copy based on text length
     1000:  496:    char* dest = str->data + str->length;
        -:  497:    
        -:  498:    // Prefetch destination for write operations
     1000:  499:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  500:    
        -:  501:    // For larger strings, prefetch additional cache lines
     1000:  502:    if (text_len >= 64) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  503:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  504:    }
     1000:  505:    if (text_len >= 128) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  506:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  507:    }
        -:  508:    
     1000:  509:    if (text_len >= 32) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  510:        // SIMD path for large appends
    #####:  511:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
     1000:  512:    } else if (text_len >= 8) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -:  513:        // Use 64-bit copies for medium strings
        -:  514:        const uint64_t* src64 = (const uint64_t*)text;
        -:  515:        uint64_t* dest64 = (uint64_t*)dest;
      990:  516:        size_t chunks = text_len / 8;
      990:  517:        size_t remainder = text_len % 8;
        -:  518:        
     1980:  519:        for (size_t i = 0; i < chunks; i++) {
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
      990:  520:            dest64[i] = src64[i];
        -:  521:        }
        -:  522:        
        -:  523:        // Handle remainder
      990:  524:        if (remainder > 0) {
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
      900:  525:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  526:        }
        -:  527:    } else {
        -:  528:        // Fast path for small strings
        -:  529:        memcpy(dest, text, text_len);
        -:  530:    }
        -:  531:    
     1000:  532:    str->length = new_length;
     1000:  533:    str->data[str->length] = '\0';
        -:  534:    
     1000:  535:    return MERCURY_SUCCESS;
        -:  536:}
------------------
mercury_string_append:
function mercury_string_append called 26 returned 100% blocks executed 78%
       26:  458:MercuryError mercury_string_append(MercuryString* str, const char* text) {
       26:  459:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
        -:  460:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  461:    }
        -:  462:    
       23:  463:    size_t text_len = strlen(text);
       23:  464:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  465:        return MERCURY_SUCCESS;  // Nothing to append
        -:  466:    }
        -:  467:    
       23:  468:    size_t new_length = str->length + text_len;
        -:  469:    
        -:  470:    // Resize buffer if necessary with better growth strategy
       23:  471:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 taken 52% (fallthrough)
branch  1 taken 48%
        -:  472:        // Growth strategy: for small strings double, for large strings add 50%
        -:  473:        size_t new_capacity;
       12:  474:        if (str->capacity < 4096) {
branch  0 taken 42% (fallthrough)
branch  1 taken 58%
        5:  475:            new_capacity = str->capacity * 2;
        -:  476:        } else {
        7:  477:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  478:        }
        -:  479:        
        -:  480:        // Ensure we have enough space
       12:  481:        if (new_capacity <= new_length) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        3:  482:            new_capacity = new_length + 256;  // Add some padding
        -:  483:        }
        -:  484:        
       12:  485:        char* new_data = realloc(str->data, new_capacity);
       12:  486:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  487:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  488:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  489:        }
        -:  490:        
       12:  491:        str->data = new_data;
       12:  492:        str->capacity = new_capacity;
        -:  493:    }
        -:  494:    
        -:  495:    // Use optimized copy based on text length
       23:  496:    char* dest = str->data + str->length;
        -:  497:    
        -:  498:    // Prefetch destination for write operations
       23:  499:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  500:    
        -:  501:    // For larger strings, prefetch additional cache lines
       23:  502:    if (text_len >= 64) {
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
       15:  503:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 returned 100%
        -:  504:    }
       23:  505:    if (text_len >= 128) {
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
       15:  506:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 returned 100%
        -:  507:    }
        -:  508:    
       23:  509:    if (text_len >= 32) {
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
        -:  510:        // SIMD path for large appends
       15:  511:        mercury_memcpy_simd(dest, text, text_len);
call    0 returned 100%
        8:  512:    } else if (text_len >= 8) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  513:        // Use 64-bit copies for medium strings
        -:  514:        const uint64_t* src64 = (const uint64_t*)text;
        -:  515:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  516:        size_t chunks = text_len / 8;
    #####:  517:        size_t remainder = text_len % 8;
        -:  518:        
    #####:  519:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  520:            dest64[i] = src64[i];
        -:  521:        }
        -:  522:        
        -:  523:        // Handle remainder
    #####:  524:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  526:        }
        -:  527:    } else {
        -:  528:        // Fast path for small strings
        -:  529:        memcpy(dest, text, text_len);
        -:  530:    }
        -:  531:    
       23:  532:    str->length = new_length;
       23:  533:    str->data[str->length] = '\0';
        -:  534:    
       23:  535:    return MERCURY_SUCCESS;
        -:  536:}
------------------
mercury_string_append:
function mercury_string_append called 11 returned 100% blocks executed 59%
       11:  458:MercuryError mercury_string_append(MercuryString* str, const char* text) {
       11:  459:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  460:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  461:    }
        -:  462:    
       11:  463:    size_t text_len = strlen(text);
       11:  464:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 taken 91% (fallthrough)
branch  1 taken 9%
        -:  465:        return MERCURY_SUCCESS;  // Nothing to append
        -:  466:    }
        -:  467:    
       10:  468:    size_t new_length = str->length + text_len;
        -:  469:    
        -:  470:    // Resize buffer if necessary with better growth strategy
       10:  471:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
        -:  472:        // Growth strategy: for small strings double, for large strings add 50%
        -:  473:        size_t new_capacity;
        1:  474:        if (str->capacity < 4096) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  475:            new_capacity = str->capacity * 2;
        -:  476:        } else {
    #####:  477:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  478:        }
        -:  479:        
        -:  480:        // Ensure we have enough space
        1:  481:        if (new_capacity <= new_length) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  482:            new_capacity = new_length + 256;  // Add some padding
        -:  483:        }
        -:  484:        
        1:  485:        char* new_data = realloc(str->data, new_capacity);
        1:  486:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  487:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  488:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  489:        }
        -:  490:        
        1:  491:        str->data = new_data;
        1:  492:        str->capacity = new_capacity;
        -:  493:    }
        -:  494:    
        -:  495:    // Use optimized copy based on text length
       10:  496:    char* dest = str->data + str->length;
        -:  497:    
        -:  498:    // Prefetch destination for write operations
       10:  499:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  500:    
        -:  501:    // For larger strings, prefetch additional cache lines
       10:  502:    if (text_len >= 64) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  503:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  504:    }
       10:  505:    if (text_len >= 128) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  506:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  507:    }
        -:  508:    
       10:  509:    if (text_len >= 32) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  510:        // SIMD path for large appends
    #####:  511:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
       10:  512:    } else if (text_len >= 8) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  513:        // Use 64-bit copies for medium strings
        -:  514:        const uint64_t* src64 = (const uint64_t*)text;
        -:  515:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  516:        size_t chunks = text_len / 8;
    #####:  517:        size_t remainder = text_len % 8;
        -:  518:        
    #####:  519:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  520:            dest64[i] = src64[i];
        -:  521:        }
        -:  522:        
        -:  523:        // Handle remainder
    #####:  524:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  526:        }
        -:  527:    } else {
        -:  528:        // Fast path for small strings
        -:  529:        memcpy(dest, text, text_len);
        -:  530:    }
        -:  531:    
       10:  532:    str->length = new_length;
       10:  533:    str->data[str->length] = '\0';
        -:  534:    
       10:  535:    return MERCURY_SUCCESS;
        -:  536:}
------------------
mercury_string_append:
function mercury_string_append called 33 returned 100% blocks executed 81%
       33:  458:MercuryError mercury_string_append(MercuryString* str, const char* text) {
       33:  459:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  460:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  461:    }
        -:  462:    
       33:  463:    size_t text_len = strlen(text);
       33:  464:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  465:        return MERCURY_SUCCESS;  // Nothing to append
        -:  466:    }
        -:  467:    
       33:  468:    size_t new_length = str->length + text_len;
        -:  469:    
        -:  470:    // Resize buffer if necessary with better growth strategy
       33:  471:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
        -:  472:        // Growth strategy: for small strings double, for large strings add 50%
        -:  473:        size_t new_capacity;
        7:  474:        if (str->capacity < 4096) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        7:  475:            new_capacity = str->capacity * 2;
        -:  476:        } else {
    #####:  477:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  478:        }
        -:  479:        
        -:  480:        // Ensure we have enough space
        7:  481:        if (new_capacity <= new_length) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  482:            new_capacity = new_length + 256;  // Add some padding
        -:  483:        }
        -:  484:        
        7:  485:        char* new_data = realloc(str->data, new_capacity);
        7:  486:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  487:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  488:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  489:        }
        -:  490:        
        7:  491:        str->data = new_data;
        7:  492:        str->capacity = new_capacity;
        -:  493:    }
        -:  494:    
        -:  495:    // Use optimized copy based on text length
       33:  496:    char* dest = str->data + str->length;
        -:  497:    
        -:  498:    // Prefetch destination for write operations
       33:  499:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  500:    
        -:  501:    // For larger strings, prefetch additional cache lines
       33:  502:    if (text_len >= 64) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  503:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  504:    }
       33:  505:    if (text_len >= 128) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  506:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  507:    }
        -:  508:    
       33:  509:    if (text_len >= 32) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -:  510:        // SIMD path for large appends
        1:  511:        mercury_memcpy_simd(dest, text, text_len);
call    0 returned 100%
       32:  512:    } else if (text_len >= 8) {
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
        -:  513:        // Use 64-bit copies for medium strings
        -:  514:        const uint64_t* src64 = (const uint64_t*)text;
        -:  515:        uint64_t* dest64 = (uint64_t*)dest;
        3:  516:        size_t chunks = text_len / 8;
        3:  517:        size_t remainder = text_len % 8;
        -:  518:        
        7:  519:        for (size_t i = 0; i < chunks; i++) {
branch  0 taken 57%
branch  1 taken 43% (fallthrough)
        4:  520:            dest64[i] = src64[i];
        -:  521:        }
        -:  522:        
        -:  523:        // Handle remainder
        3:  524:        if (remainder > 0) {
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        1:  525:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  526:        }
        -:  527:    } else {
        -:  528:        // Fast path for small strings
        -:  529:        memcpy(dest, text, text_len);
        -:  530:    }
        -:  531:    
       33:  532:    str->length = new_length;
       33:  533:    str->data[str->length] = '\0';
        -:  534:    
       33:  535:    return MERCURY_SUCCESS;
        -:  536:}
------------------
mercury_string_append:
function mercury_string_append called 0 returned 0% blocks executed 0%
    #####:  458:MercuryError mercury_string_append(MercuryString* str, const char* text) {
    #####:  459:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 never executed
branch  1 never executed
        -:  460:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  461:    }
        -:  462:    
    #####:  463:    size_t text_len = strlen(text);
    #####:  464:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 never executed
branch  1 never executed
        -:  465:        return MERCURY_SUCCESS;  // Nothing to append
        -:  466:    }
        -:  467:    
    #####:  468:    size_t new_length = str->length + text_len;
        -:  469:    
        -:  470:    // Resize buffer if necessary with better growth strategy
    #####:  471:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  472:        // Growth strategy: for small strings double, for large strings add 50%
        -:  473:        size_t new_capacity;
    #####:  474:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  475:            new_capacity = str->capacity * 2;
        -:  476:        } else {
    #####:  477:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  478:        }
        -:  479:        
        -:  480:        // Ensure we have enough space
    #####:  481:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  482:            new_capacity = new_length + 256;  // Add some padding
        -:  483:        }
        -:  484:        
    #####:  485:        char* new_data = realloc(str->data, new_capacity);
    #####:  486:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  487:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  488:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  489:        }
        -:  490:        
    #####:  491:        str->data = new_data;
    #####:  492:        str->capacity = new_capacity;
        -:  493:    }
        -:  494:    
        -:  495:    // Use optimized copy based on text length
    #####:  496:    char* dest = str->data + str->length;
        -:  497:    
        -:  498:    // Prefetch destination for write operations
    #####:  499:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  500:    
        -:  501:    // For larger strings, prefetch additional cache lines
    #####:  502:    if (text_len >= 64) {
branch  0 never executed
branch  1 never executed
    #####:  503:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  504:    }
    #####:  505:    if (text_len >= 128) {
branch  0 never executed
branch  1 never executed
    #####:  506:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  507:    }
        -:  508:    
    #####:  509:    if (text_len >= 32) {
branch  0 never executed
branch  1 never executed
        -:  510:        // SIMD path for large appends
    #####:  511:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
    #####:  512:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  513:        // Use 64-bit copies for medium strings
        -:  514:        const uint64_t* src64 = (const uint64_t*)text;
        -:  515:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  516:        size_t chunks = text_len / 8;
    #####:  517:        size_t remainder = text_len % 8;
        -:  518:        
    #####:  519:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  520:            dest64[i] = src64[i];
        -:  521:        }
        -:  522:        
        -:  523:        // Handle remainder
    #####:  524:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  526:        }
        -:  527:    } else {
        -:  528:        // Fast path for small strings
        -:  529:        memcpy(dest, text, text_len);
        -:  530:    }
        -:  531:    
    #####:  532:    str->length = new_length;
    #####:  533:    str->data[str->length] = '\0';
        -:  534:    
    #####:  535:    return MERCURY_SUCCESS;
        -:  536:}
------------------
mercury_string_append:
function mercury_string_append called 0 returned 0% blocks executed 0%
    #####:  458:MercuryError mercury_string_append(MercuryString* str, const char* text) {
    #####:  459:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 never executed
branch  1 never executed
        -:  460:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  461:    }
        -:  462:    
    #####:  463:    size_t text_len = strlen(text);
    #####:  464:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 never executed
branch  1 never executed
        -:  465:        return MERCURY_SUCCESS;  // Nothing to append
        -:  466:    }
        -:  467:    
    #####:  468:    size_t new_length = str->length + text_len;
        -:  469:    
        -:  470:    // Resize buffer if necessary with better growth strategy
    #####:  471:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  472:        // Growth strategy: for small strings double, for large strings add 50%
        -:  473:        size_t new_capacity;
    #####:  474:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  475:            new_capacity = str->capacity * 2;
        -:  476:        } else {
    #####:  477:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  478:        }
        -:  479:        
        -:  480:        // Ensure we have enough space
    #####:  481:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  482:            new_capacity = new_length + 256;  // Add some padding
        -:  483:        }
        -:  484:        
    #####:  485:        char* new_data = realloc(str->data, new_capacity);
    #####:  486:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  487:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  488:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  489:        }
        -:  490:        
    #####:  491:        str->data = new_data;
    #####:  492:        str->capacity = new_capacity;
        -:  493:    }
        -:  494:    
        -:  495:    // Use optimized copy based on text length
    #####:  496:    char* dest = str->data + str->length;
        -:  497:    
        -:  498:    // Prefetch destination for write operations
    #####:  499:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  500:    
        -:  501:    // For larger strings, prefetch additional cache lines
    #####:  502:    if (text_len >= 64) {
branch  0 never executed
branch  1 never executed
    #####:  503:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  504:    }
    #####:  505:    if (text_len >= 128) {
branch  0 never executed
branch  1 never executed
    #####:  506:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  507:    }
        -:  508:    
    #####:  509:    if (text_len >= 32) {
branch  0 never executed
branch  1 never executed
        -:  510:        // SIMD path for large appends
    #####:  511:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
    #####:  512:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  513:        // Use 64-bit copies for medium strings
        -:  514:        const uint64_t* src64 = (const uint64_t*)text;
        -:  515:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  516:        size_t chunks = text_len / 8;
    #####:  517:        size_t remainder = text_len % 8;
        -:  518:        
    #####:  519:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  520:            dest64[i] = src64[i];
        -:  521:        }
        -:  522:        
        -:  523:        // Handle remainder
    #####:  524:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  526:        }
        -:  527:    } else {
        -:  528:        // Fast path for small strings
        -:  529:        memcpy(dest, text, text_len);
        -:  530:    }
        -:  531:    
    #####:  532:    str->length = new_length;
    #####:  533:    str->data[str->length] = '\0';
        -:  534:    
    #####:  535:    return MERCURY_SUCCESS;
        -:  536:}
------------------
mercury_string_append:
function mercury_string_append called 1 returned 100% blocks executed 41%
        1:  458:MercuryError mercury_string_append(MercuryString* str, const char* text) {
        1:  459:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  460:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  461:    }
        -:  462:    
        1:  463:    size_t text_len = strlen(text);
        1:  464:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  465:        return MERCURY_SUCCESS;  // Nothing to append
        -:  466:    }
        -:  467:    
        1:  468:    size_t new_length = str->length + text_len;
        -:  469:    
        -:  470:    // Resize buffer if necessary with better growth strategy
        1:  471:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  472:        // Growth strategy: for small strings double, for large strings add 50%
        -:  473:        size_t new_capacity;
    #####:  474:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  475:            new_capacity = str->capacity * 2;
        -:  476:        } else {
    #####:  477:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  478:        }
        -:  479:        
        -:  480:        // Ensure we have enough space
    #####:  481:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  482:            new_capacity = new_length + 256;  // Add some padding
        -:  483:        }
        -:  484:        
    #####:  485:        char* new_data = realloc(str->data, new_capacity);
    #####:  486:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  487:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  488:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  489:        }
        -:  490:        
    #####:  491:        str->data = new_data;
    #####:  492:        str->capacity = new_capacity;
        -:  493:    }
        -:  494:    
        -:  495:    // Use optimized copy based on text length
        1:  496:    char* dest = str->data + str->length;
        -:  497:    
        -:  498:    // Prefetch destination for write operations
        1:  499:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  500:    
        -:  501:    // For larger strings, prefetch additional cache lines
        1:  502:    if (text_len >= 64) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  503:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 returned 100%
        -:  504:    }
        1:  505:    if (text_len >= 128) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  506:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  507:    }
        -:  508:    
        1:  509:    if (text_len >= 32) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  510:        // SIMD path for large appends
        1:  511:        mercury_memcpy_simd(dest, text, text_len);
call    0 returned 100%
    #####:  512:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  513:        // Use 64-bit copies for medium strings
        -:  514:        const uint64_t* src64 = (const uint64_t*)text;
        -:  515:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  516:        size_t chunks = text_len / 8;
    #####:  517:        size_t remainder = text_len % 8;
        -:  518:        
    #####:  519:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  520:            dest64[i] = src64[i];
        -:  521:        }
        -:  522:        
        -:  523:        // Handle remainder
    #####:  524:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  526:        }
        -:  527:    } else {
        -:  528:        // Fast path for small strings
        -:  529:        memcpy(dest, text, text_len);
        -:  530:    }
        -:  531:    
        1:  532:    str->length = new_length;
        1:  533:    str->data[str->length] = '\0';
        -:  534:    
        1:  535:    return MERCURY_SUCCESS;
        -:  536:}
------------------
mercury_string_append:
function mercury_string_append called 2 returned 100% blocks executed 41%
        2:  458:MercuryError mercury_string_append(MercuryString* str, const char* text) {
        2:  459:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  460:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  461:    }
        -:  462:    
        2:  463:    size_t text_len = strlen(text);
        2:  464:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  465:        return MERCURY_SUCCESS;  // Nothing to append
        -:  466:    }
        -:  467:    
        2:  468:    size_t new_length = str->length + text_len;
        -:  469:    
        -:  470:    // Resize buffer if necessary with better growth strategy
        2:  471:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  472:        // Growth strategy: for small strings double, for large strings add 50%
        -:  473:        size_t new_capacity;
    #####:  474:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  475:            new_capacity = str->capacity * 2;
        -:  476:        } else {
    #####:  477:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  478:        }
        -:  479:        
        -:  480:        // Ensure we have enough space
    #####:  481:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  482:            new_capacity = new_length + 256;  // Add some padding
        -:  483:        }
        -:  484:        
    #####:  485:        char* new_data = realloc(str->data, new_capacity);
    #####:  486:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  487:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  488:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  489:        }
        -:  490:        
    #####:  491:        str->data = new_data;
    #####:  492:        str->capacity = new_capacity;
        -:  493:    }
        -:  494:    
        -:  495:    // Use optimized copy based on text length
        2:  496:    char* dest = str->data + str->length;
        -:  497:    
        -:  498:    // Prefetch destination for write operations
        2:  499:    MERCURY_PREFETCH_WRITE(dest);
call    0 returned 100%
        -:  500:    
        -:  501:    // For larger strings, prefetch additional cache lines
        2:  502:    if (text_len >= 64) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  503:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 returned 100%
        -:  504:    }
        2:  505:    if (text_len >= 128) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  506:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  507:    }
        -:  508:    
        2:  509:    if (text_len >= 32) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  510:        // SIMD path for large appends
        2:  511:        mercury_memcpy_simd(dest, text, text_len);
call    0 returned 100%
    #####:  512:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  513:        // Use 64-bit copies for medium strings
        -:  514:        const uint64_t* src64 = (const uint64_t*)text;
        -:  515:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  516:        size_t chunks = text_len / 8;
    #####:  517:        size_t remainder = text_len % 8;
        -:  518:        
    #####:  519:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  520:            dest64[i] = src64[i];
        -:  521:        }
        -:  522:        
        -:  523:        // Handle remainder
    #####:  524:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  526:        }
        -:  527:    } else {
        -:  528:        // Fast path for small strings
        -:  529:        memcpy(dest, text, text_len);
        -:  530:    }
        -:  531:    
        2:  532:    str->length = new_length;
        2:  533:    str->data[str->length] = '\0';
        -:  534:    
        2:  535:    return MERCURY_SUCCESS;
        -:  536:}
------------------
mercury_string_append:
function mercury_string_append called 0 returned 0% blocks executed 0%
    #####:  458:MercuryError mercury_string_append(MercuryString* str, const char* text) {
    #####:  459:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 never executed
branch  1 never executed
        -:  460:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  461:    }
        -:  462:    
    #####:  463:    size_t text_len = strlen(text);
    #####:  464:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 never executed
branch  1 never executed
        -:  465:        return MERCURY_SUCCESS;  // Nothing to append
        -:  466:    }
        -:  467:    
    #####:  468:    size_t new_length = str->length + text_len;
        -:  469:    
        -:  470:    // Resize buffer if necessary with better growth strategy
    #####:  471:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  472:        // Growth strategy: for small strings double, for large strings add 50%
        -:  473:        size_t new_capacity;
    #####:  474:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  475:            new_capacity = str->capacity * 2;
        -:  476:        } else {
    #####:  477:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  478:        }
        -:  479:        
        -:  480:        // Ensure we have enough space
    #####:  481:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  482:            new_capacity = new_length + 256;  // Add some padding
        -:  483:        }
        -:  484:        
    #####:  485:        char* new_data = realloc(str->data, new_capacity);
    #####:  486:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  487:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  488:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  489:        }
        -:  490:        
    #####:  491:        str->data = new_data;
    #####:  492:        str->capacity = new_capacity;
        -:  493:    }
        -:  494:    
        -:  495:    // Use optimized copy based on text length
    #####:  496:    char* dest = str->data + str->length;
        -:  497:    
        -:  498:    // Prefetch destination for write operations
    #####:  499:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  500:    
        -:  501:    // For larger strings, prefetch additional cache lines
    #####:  502:    if (text_len >= 64) {
branch  0 never executed
branch  1 never executed
    #####:  503:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  504:    }
    #####:  505:    if (text_len >= 128) {
branch  0 never executed
branch  1 never executed
    #####:  506:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  507:    }
        -:  508:    
    #####:  509:    if (text_len >= 32) {
branch  0 never executed
branch  1 never executed
        -:  510:        // SIMD path for large appends
    #####:  511:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
    #####:  512:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  513:        // Use 64-bit copies for medium strings
        -:  514:        const uint64_t* src64 = (const uint64_t*)text;
        -:  515:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  516:        size_t chunks = text_len / 8;
    #####:  517:        size_t remainder = text_len % 8;
        -:  518:        
    #####:  519:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  520:            dest64[i] = src64[i];
        -:  521:        }
        -:  522:        
        -:  523:        // Handle remainder
    #####:  524:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  526:        }
        -:  527:    } else {
        -:  528:        // Fast path for small strings
        -:  529:        memcpy(dest, text, text_len);
        -:  530:    }
        -:  531:    
    #####:  532:    str->length = new_length;
    #####:  533:    str->data[str->length] = '\0';
        -:  534:    
    #####:  535:    return MERCURY_SUCCESS;
        -:  536:}
------------------
mercury_string_append:
function mercury_string_append called 0 returned 0% blocks executed 0%
    #####:  458:MercuryError mercury_string_append(MercuryString* str, const char* text) {
    #####:  459:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 never executed
branch  1 never executed
        -:  460:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  461:    }
        -:  462:    
    #####:  463:    size_t text_len = strlen(text);
    #####:  464:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 never executed
branch  1 never executed
        -:  465:        return MERCURY_SUCCESS;  // Nothing to append
        -:  466:    }
        -:  467:    
    #####:  468:    size_t new_length = str->length + text_len;
        -:  469:    
        -:  470:    // Resize buffer if necessary with better growth strategy
    #####:  471:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  472:        // Growth strategy: for small strings double, for large strings add 50%
        -:  473:        size_t new_capacity;
    #####:  474:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  475:            new_capacity = str->capacity * 2;
        -:  476:        } else {
    #####:  477:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  478:        }
        -:  479:        
        -:  480:        // Ensure we have enough space
    #####:  481:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  482:            new_capacity = new_length + 256;  // Add some padding
        -:  483:        }
        -:  484:        
    #####:  485:        char* new_data = realloc(str->data, new_capacity);
    #####:  486:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  487:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  488:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  489:        }
        -:  490:        
    #####:  491:        str->data = new_data;
    #####:  492:        str->capacity = new_capacity;
        -:  493:    }
        -:  494:    
        -:  495:    // Use optimized copy based on text length
    #####:  496:    char* dest = str->data + str->length;
        -:  497:    
        -:  498:    // Prefetch destination for write operations
    #####:  499:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  500:    
        -:  501:    // For larger strings, prefetch additional cache lines
    #####:  502:    if (text_len >= 64) {
branch  0 never executed
branch  1 never executed
    #####:  503:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  504:    }
    #####:  505:    if (text_len >= 128) {
branch  0 never executed
branch  1 never executed
    #####:  506:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  507:    }
        -:  508:    
    #####:  509:    if (text_len >= 32) {
branch  0 never executed
branch  1 never executed
        -:  510:        // SIMD path for large appends
    #####:  511:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
    #####:  512:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  513:        // Use 64-bit copies for medium strings
        -:  514:        const uint64_t* src64 = (const uint64_t*)text;
        -:  515:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  516:        size_t chunks = text_len / 8;
    #####:  517:        size_t remainder = text_len % 8;
        -:  518:        
    #####:  519:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  520:            dest64[i] = src64[i];
        -:  521:        }
        -:  522:        
        -:  523:        // Handle remainder
    #####:  524:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  526:        }
        -:  527:    } else {
        -:  528:        // Fast path for small strings
        -:  529:        memcpy(dest, text, text_len);
        -:  530:    }
        -:  531:    
    #####:  532:    str->length = new_length;
    #####:  533:    str->data[str->length] = '\0';
        -:  534:    
    #####:  535:    return MERCURY_SUCCESS;
        -:  536:}
------------------
mercury_string_append:
function mercury_string_append called 0 returned 0% blocks executed 0%
    #####:  458:MercuryError mercury_string_append(MercuryString* str, const char* text) {
    #####:  459:    if (MERCURY_UNLIKELY(!str || !text)) {
branch  0 never executed
branch  1 never executed
        -:  460:        return MERCURY_ERROR_INVALID_ARGUMENT;
        -:  461:    }
        -:  462:    
    #####:  463:    size_t text_len = strlen(text);
    #####:  464:    if (MERCURY_UNLIKELY(text_len == 0)) {
branch  0 never executed
branch  1 never executed
        -:  465:        return MERCURY_SUCCESS;  // Nothing to append
        -:  466:    }
        -:  467:    
    #####:  468:    size_t new_length = str->length + text_len;
        -:  469:    
        -:  470:    // Resize buffer if necessary with better growth strategy
    #####:  471:    if (MERCURY_UNLIKELY(new_length + 1 > str->capacity)) {
branch  0 never executed
branch  1 never executed
        -:  472:        // Growth strategy: for small strings double, for large strings add 50%
        -:  473:        size_t new_capacity;
    #####:  474:        if (str->capacity < 4096) {
branch  0 never executed
branch  1 never executed
    #####:  475:            new_capacity = str->capacity * 2;
        -:  476:        } else {
    #####:  477:            new_capacity = str->capacity + (str->capacity >> 1);  // +50%
        -:  478:        }
        -:  479:        
        -:  480:        // Ensure we have enough space
    #####:  481:        if (new_capacity <= new_length) {
branch  0 never executed
branch  1 never executed
    #####:  482:            new_capacity = new_length + 256;  // Add some padding
        -:  483:        }
        -:  484:        
    #####:  485:        char* new_data = realloc(str->data, new_capacity);
    #####:  486:        if (MERCURY_UNLIKELY(!new_data)) {
branch  0 never executed
branch  1 never executed
    #####:  487:            MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to resize string buffer");
    #####:  488:            return MERCURY_ERROR_OUT_OF_MEMORY;
        -:  489:        }
        -:  490:        
    #####:  491:        str->data = new_data;
    #####:  492:        str->capacity = new_capacity;
        -:  493:    }
        -:  494:    
        -:  495:    // Use optimized copy based on text length
    #####:  496:    char* dest = str->data + str->length;
        -:  497:    
        -:  498:    // Prefetch destination for write operations
    #####:  499:    MERCURY_PREFETCH_WRITE(dest);
call    0 never executed
        -:  500:    
        -:  501:    // For larger strings, prefetch additional cache lines
    #####:  502:    if (text_len >= 64) {
branch  0 never executed
branch  1 never executed
    #####:  503:        MERCURY_PREFETCH_WRITE_LOW(dest + 64);
call    0 never executed
        -:  504:    }
    #####:  505:    if (text_len >= 128) {
branch  0 never executed
branch  1 never executed
    #####:  506:        MERCURY_PREFETCH_WRITE_LOW(dest + 128);
call    0 never executed
        -:  507:    }
        -:  508:    
    #####:  509:    if (text_len >= 32) {
branch  0 never executed
branch  1 never executed
        -:  510:        // SIMD path for large appends
    #####:  511:        mercury_memcpy_simd(dest, text, text_len);
call    0 never executed
    #####:  512:    } else if (text_len >= 8) {
branch  0 never executed
branch  1 never executed
        -:  513:        // Use 64-bit copies for medium strings
        -:  514:        const uint64_t* src64 = (const uint64_t*)text;
        -:  515:        uint64_t* dest64 = (uint64_t*)dest;
    #####:  516:        size_t chunks = text_len / 8;
    #####:  517:        size_t remainder = text_len % 8;
        -:  518:        
    #####:  519:        for (size_t i = 0; i < chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  520:            dest64[i] = src64[i];
        -:  521:        }
        -:  522:        
        -:  523:        // Handle remainder
    #####:  524:        if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  525:            memcpy(dest + chunks * 8, text + chunks * 8, remainder);
        -:  526:        }
        -:  527:    } else {
        -:  528:        // Fast path for small strings
        -:  529:        memcpy(dest, text, text_len);
        -:  530:    }
        -:  531:    
    #####:  532:    str->length = new_length;
    #####:  533:    str->data[str->length] = '\0';
        -:  534:    
    #####:  535:    return MERCURY_SUCCESS;
        -:  536:}
------------------
        -:  537:
      39*:  538:MercuryError mercury_string_append_char(MercuryString* str, char c) {
      39*:  539:    char temp[2] = {c, '\0'};
      39*:  540:    return mercury_string_append(str, temp);
        -:  541:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  538:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  539:    char temp[2] = {c, '\0'};
    #####:  540:    return mercury_string_append(str, temp);
call    0 never executed
        -:  541:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 2 returned 100% blocks executed 100%
        2:  538:MercuryError mercury_string_append_char(MercuryString* str, char c) {
        2:  539:    char temp[2] = {c, '\0'};
        2:  540:    return mercury_string_append(str, temp);
call    0 returned 100%
        -:  541:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 11 returned 100% blocks executed 100%
       11:  538:MercuryError mercury_string_append_char(MercuryString* str, char c) {
       11:  539:    char temp[2] = {c, '\0'};
       11:  540:    return mercury_string_append(str, temp);
call    0 returned 100%
        -:  541:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 26 returned 100% blocks executed 100%
       26:  538:MercuryError mercury_string_append_char(MercuryString* str, char c) {
       26:  539:    char temp[2] = {c, '\0'};
       26:  540:    return mercury_string_append(str, temp);
call    0 returned 100%
        -:  541:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  538:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  539:    char temp[2] = {c, '\0'};
    #####:  540:    return mercury_string_append(str, temp);
call    0 never executed
        -:  541:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  538:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  539:    char temp[2] = {c, '\0'};
    #####:  540:    return mercury_string_append(str, temp);
call    0 never executed
        -:  541:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  538:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  539:    char temp[2] = {c, '\0'};
    #####:  540:    return mercury_string_append(str, temp);
call    0 never executed
        -:  541:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  538:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  539:    char temp[2] = {c, '\0'};
    #####:  540:    return mercury_string_append(str, temp);
call    0 never executed
        -:  541:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  538:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  539:    char temp[2] = {c, '\0'};
    #####:  540:    return mercury_string_append(str, temp);
call    0 never executed
        -:  541:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  538:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  539:    char temp[2] = {c, '\0'};
    #####:  540:    return mercury_string_append(str, temp);
call    0 never executed
        -:  541:}
------------------
mercury_string_append_char:
function mercury_string_append_char called 0 returned 0% blocks executed 0%
    #####:  538:MercuryError mercury_string_append_char(MercuryString* str, char c) {
    #####:  539:    char temp[2] = {c, '\0'};
    #####:  540:    return mercury_string_append(str, temp);
call    0 never executed
        -:  541:}
------------------
        -:  542:
       3*:  543:void mercury_string_clear(MercuryString* str) {
       3*:  544:    if (!str) return;
        -:  545:    
       3*:  546:    str->length = 0;
       3*:  547:    if (str->data) {
       3*:  548:        str->data[0] = '\0';
        -:  549:    }
        -:  550:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  543:void mercury_string_clear(MercuryString* str) {
    #####:  544:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  545:    
    #####:  546:    str->length = 0;
    #####:  547:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  548:        str->data[0] = '\0';
        -:  549:    }
        -:  550:}
------------------
mercury_string_clear:
function mercury_string_clear called 2 returned 100% blocks executed 100%
        2:  543:void mercury_string_clear(MercuryString* str) {
        2:  544:    if (!str) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  545:    
        2:  546:    str->length = 0;
        2:  547:    if (str->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  548:        str->data[0] = '\0';
        -:  549:    }
        -:  550:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  543:void mercury_string_clear(MercuryString* str) {
    #####:  544:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  545:    
    #####:  546:    str->length = 0;
    #####:  547:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  548:        str->data[0] = '\0';
        -:  549:    }
        -:  550:}
------------------
mercury_string_clear:
function mercury_string_clear called 1 returned 100% blocks executed 100%
        1:  543:void mercury_string_clear(MercuryString* str) {
        1:  544:    if (!str) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  545:    
        1:  546:    str->length = 0;
        1:  547:    if (str->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  548:        str->data[0] = '\0';
        -:  549:    }
        -:  550:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  543:void mercury_string_clear(MercuryString* str) {
    #####:  544:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  545:    
    #####:  546:    str->length = 0;
    #####:  547:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  548:        str->data[0] = '\0';
        -:  549:    }
        -:  550:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  543:void mercury_string_clear(MercuryString* str) {
    #####:  544:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  545:    
    #####:  546:    str->length = 0;
    #####:  547:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  548:        str->data[0] = '\0';
        -:  549:    }
        -:  550:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  543:void mercury_string_clear(MercuryString* str) {
    #####:  544:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  545:    
    #####:  546:    str->length = 0;
    #####:  547:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  548:        str->data[0] = '\0';
        -:  549:    }
        -:  550:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  543:void mercury_string_clear(MercuryString* str) {
    #####:  544:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  545:    
    #####:  546:    str->length = 0;
    #####:  547:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  548:        str->data[0] = '\0';
        -:  549:    }
        -:  550:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  543:void mercury_string_clear(MercuryString* str) {
    #####:  544:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  545:    
    #####:  546:    str->length = 0;
    #####:  547:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  548:        str->data[0] = '\0';
        -:  549:    }
        -:  550:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  543:void mercury_string_clear(MercuryString* str) {
    #####:  544:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  545:    
    #####:  546:    str->length = 0;
    #####:  547:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  548:        str->data[0] = '\0';
        -:  549:    }
        -:  550:}
------------------
mercury_string_clear:
function mercury_string_clear called 0 returned 0% blocks executed 0%
    #####:  543:void mercury_string_clear(MercuryString* str) {
    #####:  544:    if (!str) return;
branch  0 never executed
branch  1 never executed
        -:  545:    
    #####:  546:    str->length = 0;
    #####:  547:    if (str->data) {
branch  0 never executed
branch  1 never executed
    #####:  548:        str->data[0] = '\0';
        -:  549:    }
        -:  550:}
------------------
        -:  551:
      11*:  552:const char* mercury_string_cstr(const MercuryString* str) {
      11*:  553:    if (!str || !str->data) {
    #####:  554:        return "";
        -:  555:    }
        -:  556:    return str->data;
        -:  557:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 1 returned 100% blocks executed 75%
        1:  552:const char* mercury_string_cstr(const MercuryString* str) {
        1:  553:    if (!str || !str->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  554:        return "";
        -:  555:    }
        -:  556:    return str->data;
        -:  557:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 6 returned 100% blocks executed 75%
        6:  552:const char* mercury_string_cstr(const MercuryString* str) {
        6:  553:    if (!str || !str->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  554:        return "";
        -:  555:    }
        -:  556:    return str->data;
        -:  557:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 1 returned 100% blocks executed 75%
        1:  552:const char* mercury_string_cstr(const MercuryString* str) {
        1:  553:    if (!str || !str->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  554:        return "";
        -:  555:    }
        -:  556:    return str->data;
        -:  557:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 0 returned 0% blocks executed 0%
    #####:  552:const char* mercury_string_cstr(const MercuryString* str) {
    #####:  553:    if (!str || !str->data) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  554:        return "";
        -:  555:    }
        -:  556:    return str->data;
        -:  557:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 0 returned 0% blocks executed 0%
    #####:  552:const char* mercury_string_cstr(const MercuryString* str) {
    #####:  553:    if (!str || !str->data) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  554:        return "";
        -:  555:    }
        -:  556:    return str->data;
        -:  557:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 0 returned 0% blocks executed 0%
    #####:  552:const char* mercury_string_cstr(const MercuryString* str) {
    #####:  553:    if (!str || !str->data) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  554:        return "";
        -:  555:    }
        -:  556:    return str->data;
        -:  557:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 1 returned 100% blocks executed 75%
        1:  552:const char* mercury_string_cstr(const MercuryString* str) {
        1:  553:    if (!str || !str->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  554:        return "";
        -:  555:    }
        -:  556:    return str->data;
        -:  557:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 2 returned 100% blocks executed 75%
        2:  552:const char* mercury_string_cstr(const MercuryString* str) {
        2:  553:    if (!str || !str->data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####:  554:        return "";
        -:  555:    }
        -:  556:    return str->data;
        -:  557:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 0 returned 0% blocks executed 0%
    #####:  552:const char* mercury_string_cstr(const MercuryString* str) {
    #####:  553:    if (!str || !str->data) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  554:        return "";
        -:  555:    }
        -:  556:    return str->data;
        -:  557:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 0 returned 0% blocks executed 0%
    #####:  552:const char* mercury_string_cstr(const MercuryString* str) {
    #####:  553:    if (!str || !str->data) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  554:        return "";
        -:  555:    }
        -:  556:    return str->data;
        -:  557:}
------------------
mercury_string_cstr:
function mercury_string_cstr called 0 returned 0% blocks executed 0%
    #####:  552:const char* mercury_string_cstr(const MercuryString* str) {
    #####:  553:    if (!str || !str->data) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  554:        return "";
        -:  555:    }
        -:  556:    return str->data;
        -:  557:}
------------------
        -:  558:
        -:  559:// === BOYER-MOORE IMPLEMENTATION ===
        -:  560:
        -:  561:static void compute_bad_char_table(const char* pattern, size_t pattern_len, int* bad_char_table) {
        -:  562:    // Initialize all entries to -1
   15420*:  563:    for (int i = 0; i < 256; i++) {
branch  0 taken 100%
branch  1 taken 1%
branch  2 taken 100%
branch  3 taken 1%
branch  4 taken 100%
branch  5 taken 1%
branch  6 taken 100%
branch  7 taken 1%
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 taken 100%
branch 13 taken 1%
branch 14 taken 100%
branch 15 taken 1%
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
   15360*:  564:        bad_char_table[i] = -1;
        -:  565:    }
        -:  566:    
        -:  567:    // Fill the actual positions of characters in pattern
    1450*:  568:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 taken 89%
branch  1 taken 11% (fallthrough)
branch  2 taken 95%
branch  3 taken 5% (fallthrough)
branch  4 taken 90%
branch  5 taken 10% (fallthrough)
branch  6 taken 97%
branch  7 taken 3% (fallthrough)
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 taken 96%
branch 13 taken 4% (fallthrough)
branch 14 taken 96%
branch 15 taken 4% (fallthrough)
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
    1390*:  569:        bad_char_table[(unsigned char)pattern[i]] = (int)i;
        -:  570:    }
        -:  571:}
        -:  572:
      60*:  573:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
      60*:  574:    int* suffix = malloc(pattern_len * sizeof(int));
      60*:  575:    if (!suffix) return;
        -:  576:    
        -:  577:    // Compute suffix array
      60*:  578:    suffix[pattern_len - 1] = (int)pattern_len;
      60*:  579:    int g = (int)pattern_len - 1;
        -:  580:    int f = 0;
        -:  581:    
    1390*:  582:    for (int i = (int)pattern_len - 2; i >= 0; i--) {
    1330*:  583:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
      16*:  584:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  585:        } else {
        -:  586:            if (i < g) g = i;
        -:  587:            f = i;
    1437*:  588:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
     123*:  589:                g--;
        -:  590:            }
    1314*:  591:            suffix[i] = f - g;
        -:  592:        }
        -:  593:    }
        -:  594:    
        -:  595:    // Compute good suffix table
    1450*:  596:    for (size_t i = 0; i < pattern_len; i++) {
    1390*:  597:        good_suffix_table[i] = (int)pattern_len;
        -:  598:    }
        -:  599:    
        -:  600:    int j = 0;
    1450*:  601:    for (int i = (int)pattern_len - 1; i >= 0; i--) {
    1390*:  602:        if (suffix[i] == i + 1) {
     106*:  603:            for (; j < (int)(pattern_len - 1 - i); j++) {
      35*:  604:                if (good_suffix_table[j] == (int)pattern_len) {
      35*:  605:                    good_suffix_table[j] = (int)pattern_len - 1 - i;
        -:  606:                }
        -:  607:            }
        -:  608:        }
        -:  609:    }
        -:  610:    
    1390*:  611:    for (size_t i = 0; i <= pattern_len - 2; i++) {
    1330*:  612:        good_suffix_table[pattern_len - 1 - suffix[i]] = (int)(pattern_len - 1 - i);
        -:  613:    }
        -:  614:    
      60*:  615:    free(suffix);
        -:  616:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 1 returned 100% blocks executed 76%
        1:  573:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
        1:  574:    int* suffix = malloc(pattern_len * sizeof(int));
        1:  575:    if (!suffix) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  576:    
        -:  577:    // Compute suffix array
        1:  578:    suffix[pattern_len - 1] = (int)pattern_len;
        1:  579:    int g = (int)pattern_len - 1;
        -:  580:    int f = 0;
        -:  581:    
        8:  582:    for (int i = (int)pattern_len - 2; i >= 0; i--) {
branch  0 taken 88%
branch  1 taken 12%
       7*:  583:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  584:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  585:        } else {
        -:  586:            if (i < g) g = i;
        -:  587:            f = i;
        7:  588:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 100% (fallthrough)
    #####:  589:                g--;
        -:  590:            }
        7:  591:            suffix[i] = f - g;
        -:  592:        }
        -:  593:    }
        -:  594:    
        -:  595:    // Compute good suffix table
        9:  596:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 taken 89%
branch  1 taken 11%
        8:  597:        good_suffix_table[i] = (int)pattern_len;
        -:  598:    }
        -:  599:    
        -:  600:    int j = 0;
        9:  601:    for (int i = (int)pattern_len - 1; i >= 0; i--) {
branch  0 taken 89%
branch  1 taken 11%
        8:  602:        if (suffix[i] == i + 1) {
branch  0 taken 12%
branch  1 taken 88%
       1*:  603:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  604:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  605:                    good_suffix_table[j] = (int)pattern_len - 1 - i;
        -:  606:                }
        -:  607:            }
        -:  608:        }
        -:  609:    }
        -:  610:    
        8:  611:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
        7:  612:        good_suffix_table[pattern_len - 1 - suffix[i]] = (int)(pattern_len - 1 - i);
        -:  613:    }
        -:  614:    
        1:  615:    free(suffix);
        -:  616:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 13 returned 100% blocks executed 100%
       13:  573:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
       13:  574:    int* suffix = malloc(pattern_len * sizeof(int));
       13:  575:    if (!suffix) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  576:    
        -:  577:    // Compute suffix array
       13:  578:    suffix[pattern_len - 1] = (int)pattern_len;
       13:  579:    int g = (int)pattern_len - 1;
        -:  580:    int f = 0;
        -:  581:    
      241:  582:    for (int i = (int)pattern_len - 2; i >= 0; i--) {
branch  0 taken 95%
branch  1 taken 5%
      228:  583:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        1:  584:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  585:        } else {
        -:  586:            if (i < g) g = i;
        -:  587:            f = i;
      246:  588:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
branch  2 taken 8%
branch  3 taken 92% (fallthrough)
       19:  589:                g--;
        -:  590:            }
      227:  591:            suffix[i] = f - g;
        -:  592:        }
        -:  593:    }
        -:  594:    
        -:  595:    // Compute good suffix table
      254:  596:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 taken 95%
branch  1 taken 5%
      241:  597:        good_suffix_table[i] = (int)pattern_len;
        -:  598:    }
        -:  599:    
        -:  600:    int j = 0;
      254:  601:    for (int i = (int)pattern_len - 1; i >= 0; i--) {
branch  0 taken 95%
branch  1 taken 5%
      241:  602:        if (suffix[i] == i + 1) {
branch  0 taken 6%
branch  1 taken 94%
       21:  603:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 taken 29%
branch  1 taken 71% (fallthrough)
        6:  604:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6:  605:                    good_suffix_table[j] = (int)pattern_len - 1 - i;
        -:  606:                }
        -:  607:            }
        -:  608:        }
        -:  609:    }
        -:  610:    
      241:  611:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
      228:  612:        good_suffix_table[pattern_len - 1 - suffix[i]] = (int)(pattern_len - 1 - i);
        -:  613:    }
        -:  614:    
       13:  615:    free(suffix);
        -:  616:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 5 returned 100% blocks executed 100%
        5:  573:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
        5:  574:    int* suffix = malloc(pattern_len * sizeof(int));
        5:  575:    if (!suffix) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  576:    
        -:  577:    // Compute suffix array
        5:  578:    suffix[pattern_len - 1] = (int)pattern_len;
        5:  579:    int g = (int)pattern_len - 1;
        -:  580:    int f = 0;
        -:  581:    
       44:  582:    for (int i = (int)pattern_len - 2; i >= 0; i--) {
branch  0 taken 89%
branch  1 taken 11%
       39:  583:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
branch  2 taken 79% (fallthrough)
branch  3 taken 21%
       15:  584:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  585:        } else {
        -:  586:            if (i < g) g = i;
        -:  587:            f = i;
       48:  588:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
branch  2 taken 62%
branch  3 taken 38% (fallthrough)
       24:  589:                g--;
        -:  590:            }
       24:  591:            suffix[i] = f - g;
        -:  592:        }
        -:  593:    }
        -:  594:    
        -:  595:    // Compute good suffix table
       49:  596:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 taken 90%
branch  1 taken 10%
       44:  597:        good_suffix_table[i] = (int)pattern_len;
        -:  598:    }
        -:  599:    
        -:  600:    int j = 0;
       49:  601:    for (int i = (int)pattern_len - 1; i >= 0; i--) {
branch  0 taken 90%
branch  1 taken 10%
       44:  602:        if (suffix[i] == i + 1) {
branch  0 taken 32%
branch  1 taken 68%
       43:  603:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
       29:  604:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       29:  605:                    good_suffix_table[j] = (int)pattern_len - 1 - i;
        -:  606:                }
        -:  607:            }
        -:  608:        }
        -:  609:    }
        -:  610:    
       44:  611:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 taken 89%
branch  1 taken 11% (fallthrough)
       39:  612:        good_suffix_table[pattern_len - 1 - suffix[i]] = (int)(pattern_len - 1 - i);
        -:  613:    }
        -:  614:    
        5:  615:    free(suffix);
        -:  616:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 3 returned 100% blocks executed 80%
        3:  573:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
        3:  574:    int* suffix = malloc(pattern_len * sizeof(int));
        3:  575:    if (!suffix) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  576:    
        -:  577:    // Compute suffix array
        3:  578:    suffix[pattern_len - 1] = (int)pattern_len;
        3:  579:    int g = (int)pattern_len - 1;
        -:  580:    int f = 0;
        -:  581:    
       95:  582:    for (int i = (int)pattern_len - 2; i >= 0; i--) {
branch  0 taken 97%
branch  1 taken 3%
      92*:  583:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  584:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  585:        } else {
        -:  586:            if (i < g) g = i;
        -:  587:            f = i;
       94:  588:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 2%
branch  3 taken 98% (fallthrough)
        2:  589:                g--;
        -:  590:            }
       92:  591:            suffix[i] = f - g;
        -:  592:        }
        -:  593:    }
        -:  594:    
        -:  595:    // Compute good suffix table
       98:  596:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 taken 97%
branch  1 taken 3%
       95:  597:        good_suffix_table[i] = (int)pattern_len;
        -:  598:    }
        -:  599:    
        -:  600:    int j = 0;
       98:  601:    for (int i = (int)pattern_len - 1; i >= 0; i--) {
branch  0 taken 97%
branch  1 taken 3%
       95:  602:        if (suffix[i] == i + 1) {
branch  0 taken 3%
branch  1 taken 97%
       3*:  603:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  604:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  605:                    good_suffix_table[j] = (int)pattern_len - 1 - i;
        -:  606:                }
        -:  607:            }
        -:  608:        }
        -:  609:    }
        -:  610:    
       95:  611:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
       92:  612:        good_suffix_table[pattern_len - 1 - suffix[i]] = (int)(pattern_len - 1 - i);
        -:  613:    }
        -:  614:    
        3:  615:    free(suffix);
        -:  616:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 0 returned 0% blocks executed 0%
    #####:  573:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
    #####:  574:    int* suffix = malloc(pattern_len * sizeof(int));
    #####:  575:    if (!suffix) return;
branch  0 never executed
branch  1 never executed
        -:  576:    
        -:  577:    // Compute suffix array
    #####:  578:    suffix[pattern_len - 1] = (int)pattern_len;
    #####:  579:    int g = (int)pattern_len - 1;
        -:  580:    int f = 0;
        -:  581:    
    #####:  582:    for (int i = (int)pattern_len - 2; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  583:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  584:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  585:        } else {
        -:  586:            if (i < g) g = i;
        -:  587:            f = i;
    #####:  588:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  589:                g--;
        -:  590:            }
    #####:  591:            suffix[i] = f - g;
        -:  592:        }
        -:  593:    }
        -:  594:    
        -:  595:    // Compute good suffix table
    #####:  596:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 never executed
branch  1 never executed
    #####:  597:        good_suffix_table[i] = (int)pattern_len;
        -:  598:    }
        -:  599:    
        -:  600:    int j = 0;
    #####:  601:    for (int i = (int)pattern_len - 1; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  602:        if (suffix[i] == i + 1) {
branch  0 never executed
branch  1 never executed
    #####:  603:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 never executed
branch  1 never executed
    #####:  604:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  605:                    good_suffix_table[j] = (int)pattern_len - 1 - i;
        -:  606:                }
        -:  607:            }
        -:  608:        }
        -:  609:    }
        -:  610:    
    #####:  611:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 never executed
branch  1 never executed
    #####:  612:        good_suffix_table[pattern_len - 1 - suffix[i]] = (int)(pattern_len - 1 - i);
        -:  613:    }
        -:  614:    
    #####:  615:    free(suffix);
        -:  616:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 0 returned 0% blocks executed 0%
    #####:  573:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
    #####:  574:    int* suffix = malloc(pattern_len * sizeof(int));
    #####:  575:    if (!suffix) return;
branch  0 never executed
branch  1 never executed
        -:  576:    
        -:  577:    // Compute suffix array
    #####:  578:    suffix[pattern_len - 1] = (int)pattern_len;
    #####:  579:    int g = (int)pattern_len - 1;
        -:  580:    int f = 0;
        -:  581:    
    #####:  582:    for (int i = (int)pattern_len - 2; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  583:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  584:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  585:        } else {
        -:  586:            if (i < g) g = i;
        -:  587:            f = i;
    #####:  588:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  589:                g--;
        -:  590:            }
    #####:  591:            suffix[i] = f - g;
        -:  592:        }
        -:  593:    }
        -:  594:    
        -:  595:    // Compute good suffix table
    #####:  596:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 never executed
branch  1 never executed
    #####:  597:        good_suffix_table[i] = (int)pattern_len;
        -:  598:    }
        -:  599:    
        -:  600:    int j = 0;
    #####:  601:    for (int i = (int)pattern_len - 1; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  602:        if (suffix[i] == i + 1) {
branch  0 never executed
branch  1 never executed
    #####:  603:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 never executed
branch  1 never executed
    #####:  604:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  605:                    good_suffix_table[j] = (int)pattern_len - 1 - i;
        -:  606:                }
        -:  607:            }
        -:  608:        }
        -:  609:    }
        -:  610:    
    #####:  611:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 never executed
branch  1 never executed
    #####:  612:        good_suffix_table[pattern_len - 1 - suffix[i]] = (int)(pattern_len - 1 - i);
        -:  613:    }
        -:  614:    
    #####:  615:    free(suffix);
        -:  616:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 19 returned 100% blocks executed 80%
       19:  573:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
       19:  574:    int* suffix = malloc(pattern_len * sizeof(int));
       19:  575:    if (!suffix) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  576:    
        -:  577:    // Compute suffix array
       19:  578:    suffix[pattern_len - 1] = (int)pattern_len;
       19:  579:    int g = (int)pattern_len - 1;
        -:  580:    int f = 0;
        -:  581:    
      501:  582:    for (int i = (int)pattern_len - 2; i >= 0; i--) {
branch  0 taken 96%
branch  1 taken 4%
     482*:  583:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  584:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  585:        } else {
        -:  586:            if (i < g) g = i;
        -:  587:            f = i;
      521:  588:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 7%
branch  3 taken 93% (fallthrough)
       39:  589:                g--;
        -:  590:            }
      482:  591:            suffix[i] = f - g;
        -:  592:        }
        -:  593:    }
        -:  594:    
        -:  595:    // Compute good suffix table
      520:  596:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 taken 96%
branch  1 taken 4%
      501:  597:        good_suffix_table[i] = (int)pattern_len;
        -:  598:    }
        -:  599:    
        -:  600:    int j = 0;
      520:  601:    for (int i = (int)pattern_len - 1; i >= 0; i--) {
branch  0 taken 96%
branch  1 taken 4%
      501:  602:        if (suffix[i] == i + 1) {
branch  0 taken 4%
branch  1 taken 96%
      19*:  603:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  604:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  605:                    good_suffix_table[j] = (int)pattern_len - 1 - i;
        -:  606:                }
        -:  607:            }
        -:  608:        }
        -:  609:    }
        -:  610:    
      501:  611:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
      482:  612:        good_suffix_table[pattern_len - 1 - suffix[i]] = (int)(pattern_len - 1 - i);
        -:  613:    }
        -:  614:    
       19:  615:    free(suffix);
        -:  616:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 19 returned 100% blocks executed 80%
       19:  573:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
       19:  574:    int* suffix = malloc(pattern_len * sizeof(int));
       19:  575:    if (!suffix) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  576:    
        -:  577:    // Compute suffix array
       19:  578:    suffix[pattern_len - 1] = (int)pattern_len;
       19:  579:    int g = (int)pattern_len - 1;
        -:  580:    int f = 0;
        -:  581:    
      501:  582:    for (int i = (int)pattern_len - 2; i >= 0; i--) {
branch  0 taken 96%
branch  1 taken 4%
     482*:  583:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  584:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  585:        } else {
        -:  586:            if (i < g) g = i;
        -:  587:            f = i;
      521:  588:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 7%
branch  3 taken 93% (fallthrough)
       39:  589:                g--;
        -:  590:            }
      482:  591:            suffix[i] = f - g;
        -:  592:        }
        -:  593:    }
        -:  594:    
        -:  595:    // Compute good suffix table
      520:  596:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 taken 96%
branch  1 taken 4%
      501:  597:        good_suffix_table[i] = (int)pattern_len;
        -:  598:    }
        -:  599:    
        -:  600:    int j = 0;
      520:  601:    for (int i = (int)pattern_len - 1; i >= 0; i--) {
branch  0 taken 96%
branch  1 taken 4%
      501:  602:        if (suffix[i] == i + 1) {
branch  0 taken 4%
branch  1 taken 96%
      19*:  603:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
    #####:  604:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  605:                    good_suffix_table[j] = (int)pattern_len - 1 - i;
        -:  606:                }
        -:  607:            }
        -:  608:        }
        -:  609:    }
        -:  610:    
      501:  611:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
      482:  612:        good_suffix_table[pattern_len - 1 - suffix[i]] = (int)(pattern_len - 1 - i);
        -:  613:    }
        -:  614:    
       19:  615:    free(suffix);
        -:  616:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 0 returned 0% blocks executed 0%
    #####:  573:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
    #####:  574:    int* suffix = malloc(pattern_len * sizeof(int));
    #####:  575:    if (!suffix) return;
branch  0 never executed
branch  1 never executed
        -:  576:    
        -:  577:    // Compute suffix array
    #####:  578:    suffix[pattern_len - 1] = (int)pattern_len;
    #####:  579:    int g = (int)pattern_len - 1;
        -:  580:    int f = 0;
        -:  581:    
    #####:  582:    for (int i = (int)pattern_len - 2; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  583:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  584:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  585:        } else {
        -:  586:            if (i < g) g = i;
        -:  587:            f = i;
    #####:  588:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  589:                g--;
        -:  590:            }
    #####:  591:            suffix[i] = f - g;
        -:  592:        }
        -:  593:    }
        -:  594:    
        -:  595:    // Compute good suffix table
    #####:  596:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 never executed
branch  1 never executed
    #####:  597:        good_suffix_table[i] = (int)pattern_len;
        -:  598:    }
        -:  599:    
        -:  600:    int j = 0;
    #####:  601:    for (int i = (int)pattern_len - 1; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  602:        if (suffix[i] == i + 1) {
branch  0 never executed
branch  1 never executed
    #####:  603:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 never executed
branch  1 never executed
    #####:  604:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  605:                    good_suffix_table[j] = (int)pattern_len - 1 - i;
        -:  606:                }
        -:  607:            }
        -:  608:        }
        -:  609:    }
        -:  610:    
    #####:  611:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 never executed
branch  1 never executed
    #####:  612:        good_suffix_table[pattern_len - 1 - suffix[i]] = (int)(pattern_len - 1 - i);
        -:  613:    }
        -:  614:    
    #####:  615:    free(suffix);
        -:  616:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 0 returned 0% blocks executed 0%
    #####:  573:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
    #####:  574:    int* suffix = malloc(pattern_len * sizeof(int));
    #####:  575:    if (!suffix) return;
branch  0 never executed
branch  1 never executed
        -:  576:    
        -:  577:    // Compute suffix array
    #####:  578:    suffix[pattern_len - 1] = (int)pattern_len;
    #####:  579:    int g = (int)pattern_len - 1;
        -:  580:    int f = 0;
        -:  581:    
    #####:  582:    for (int i = (int)pattern_len - 2; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  583:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  584:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  585:        } else {
        -:  586:            if (i < g) g = i;
        -:  587:            f = i;
    #####:  588:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  589:                g--;
        -:  590:            }
    #####:  591:            suffix[i] = f - g;
        -:  592:        }
        -:  593:    }
        -:  594:    
        -:  595:    // Compute good suffix table
    #####:  596:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 never executed
branch  1 never executed
    #####:  597:        good_suffix_table[i] = (int)pattern_len;
        -:  598:    }
        -:  599:    
        -:  600:    int j = 0;
    #####:  601:    for (int i = (int)pattern_len - 1; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  602:        if (suffix[i] == i + 1) {
branch  0 never executed
branch  1 never executed
    #####:  603:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 never executed
branch  1 never executed
    #####:  604:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  605:                    good_suffix_table[j] = (int)pattern_len - 1 - i;
        -:  606:                }
        -:  607:            }
        -:  608:        }
        -:  609:    }
        -:  610:    
    #####:  611:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 never executed
branch  1 never executed
    #####:  612:        good_suffix_table[pattern_len - 1 - suffix[i]] = (int)(pattern_len - 1 - i);
        -:  613:    }
        -:  614:    
    #####:  615:    free(suffix);
        -:  616:}
------------------
compute_good_suffix_table:
function compute_good_suffix_table called 0 returned 0% blocks executed 0%
    #####:  573:static void compute_good_suffix_table(const char* pattern, size_t pattern_len, int* good_suffix_table) {
    #####:  574:    int* suffix = malloc(pattern_len * sizeof(int));
    #####:  575:    if (!suffix) return;
branch  0 never executed
branch  1 never executed
        -:  576:    
        -:  577:    // Compute suffix array
    #####:  578:    suffix[pattern_len - 1] = (int)pattern_len;
    #####:  579:    int g = (int)pattern_len - 1;
        -:  580:    int f = 0;
        -:  581:    
    #####:  582:    for (int i = (int)pattern_len - 2; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  583:        if (i > g && suffix[i + pattern_len - 1 - f] < i - g) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  584:            suffix[i] = suffix[i + pattern_len - 1 - f];
        -:  585:        } else {
        -:  586:            if (i < g) g = i;
        -:  587:            f = i;
    #####:  588:            while (g >= 0 && pattern[g] == pattern[g + pattern_len - 1 - f]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  589:                g--;
        -:  590:            }
    #####:  591:            suffix[i] = f - g;
        -:  592:        }
        -:  593:    }
        -:  594:    
        -:  595:    // Compute good suffix table
    #####:  596:    for (size_t i = 0; i < pattern_len; i++) {
branch  0 never executed
branch  1 never executed
    #####:  597:        good_suffix_table[i] = (int)pattern_len;
        -:  598:    }
        -:  599:    
        -:  600:    int j = 0;
    #####:  601:    for (int i = (int)pattern_len - 1; i >= 0; i--) {
branch  0 never executed
branch  1 never executed
    #####:  602:        if (suffix[i] == i + 1) {
branch  0 never executed
branch  1 never executed
    #####:  603:            for (; j < (int)(pattern_len - 1 - i); j++) {
branch  0 never executed
branch  1 never executed
    #####:  604:                if (good_suffix_table[j] == (int)pattern_len) {
branch  0 never executed
branch  1 never executed
    #####:  605:                    good_suffix_table[j] = (int)pattern_len - 1 - i;
        -:  606:                }
        -:  607:            }
        -:  608:        }
        -:  609:    }
        -:  610:    
    #####:  611:    for (size_t i = 0; i <= pattern_len - 2; i++) {
branch  0 never executed
branch  1 never executed
    #####:  612:        good_suffix_table[pattern_len - 1 - suffix[i]] = (int)(pattern_len - 1 - i);
        -:  613:    }
        -:  614:    
    #####:  615:    free(suffix);
        -:  616:}
------------------
        -:  617:
        -:  618:/**
        -:  619: * @brief Create Boyer-Moore pattern matcher for fast string searching
        -:  620: * 
        -:  621: * @details Builds bad character and good suffix tables for O(n/m) average
        -:  622: * case string searching performance.
        -:  623: * 
        -:  624: * @param pattern Pattern string to search for
        -:  625: * @return Pointer to Boyer-Moore structure or NULL on failure
        -:  626: * 
        -:  627: * @pre pattern must be non-NULL and non-empty
        -:  628: * @post Boyer-Moore tables are initialized
        -:  629: * 
        -:  630: * @warning Caller must call mercury_boyer_moore_destroy() to free
        -:  631: * @note Optimized for patterns longer than 3 characters
        -:  632: */
      62*:  633:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
      62*:  634:    if (!pattern) {
       1*:  635:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
       1*:  636:        return NULL;
        -:  637:    }
        -:  638:    
      61*:  639:    size_t pattern_len = strlen(pattern);
      61*:  640:    if (pattern_len == 0) {
       1*:  641:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
       1*:  642:        return NULL;
        -:  643:    }
        -:  644:    
      60*:  645:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
      60*:  646:    if (!bm) {
    #####:  647:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  648:        return NULL;
        -:  649:    }
        -:  650:    
      60*:  651:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
      60*:  652:    if (!bm->good_suffix_table) {
    #####:  653:        free(bm);
    #####:  654:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  655:        return NULL;
        -:  656:    }
        -:  657:    
      60*:  658:    bm->pattern_length = pattern_len;
        -:  659:    
      60*:  660:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
      60*:  661:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
        -:  662:    
      60*:  663:    return bm;
        -:  664:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 1 returned 100% blocks executed 75%
        1:  633:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
        1:  634:    if (!pattern) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  635:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  636:        return NULL;
        -:  637:    }
        -:  638:    
        1:  639:    size_t pattern_len = strlen(pattern);
        1:  640:    if (pattern_len == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  641:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  642:        return NULL;
        -:  643:    }
        -:  644:    
        1:  645:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
        1:  646:    if (!bm) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  647:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  648:        return NULL;
        -:  649:    }
        -:  650:    
        1:  651:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
        1:  652:    if (!bm->good_suffix_table) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  653:        free(bm);
    #####:  654:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  655:        return NULL;
        -:  656:    }
        -:  657:    
        1:  658:    bm->pattern_length = pattern_len;
        -:  659:    
        1:  660:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
        1:  661:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 returned 100%
        -:  662:    
        1:  663:    return bm;
        -:  664:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 15 returned 100% blocks executed 88%
       15:  633:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
       15:  634:    if (!pattern) {
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        1:  635:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
        1:  636:        return NULL;
        -:  637:    }
        -:  638:    
       14:  639:    size_t pattern_len = strlen(pattern);
       14:  640:    if (pattern_len == 0) {
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        1:  641:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
        1:  642:        return NULL;
        -:  643:    }
        -:  644:    
       13:  645:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
       13:  646:    if (!bm) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  647:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  648:        return NULL;
        -:  649:    }
        -:  650:    
       13:  651:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
       13:  652:    if (!bm->good_suffix_table) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  653:        free(bm);
    #####:  654:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  655:        return NULL;
        -:  656:    }
        -:  657:    
       13:  658:    bm->pattern_length = pattern_len;
        -:  659:    
       13:  660:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
       13:  661:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 returned 100%
        -:  662:    
       13:  663:    return bm;
        -:  664:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 5 returned 100% blocks executed 75%
        5:  633:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
        5:  634:    if (!pattern) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  635:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  636:        return NULL;
        -:  637:    }
        -:  638:    
        5:  639:    size_t pattern_len = strlen(pattern);
        5:  640:    if (pattern_len == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  641:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  642:        return NULL;
        -:  643:    }
        -:  644:    
        5:  645:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
        5:  646:    if (!bm) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  647:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  648:        return NULL;
        -:  649:    }
        -:  650:    
        5:  651:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
        5:  652:    if (!bm->good_suffix_table) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  653:        free(bm);
    #####:  654:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  655:        return NULL;
        -:  656:    }
        -:  657:    
        5:  658:    bm->pattern_length = pattern_len;
        -:  659:    
        5:  660:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
        5:  661:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 returned 100%
        -:  662:    
        5:  663:    return bm;
        -:  664:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 3 returned 100% blocks executed 75%
        3:  633:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
        3:  634:    if (!pattern) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  635:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  636:        return NULL;
        -:  637:    }
        -:  638:    
        3:  639:    size_t pattern_len = strlen(pattern);
        3:  640:    if (pattern_len == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  641:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  642:        return NULL;
        -:  643:    }
        -:  644:    
        3:  645:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
        3:  646:    if (!bm) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  647:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  648:        return NULL;
        -:  649:    }
        -:  650:    
        3:  651:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
        3:  652:    if (!bm->good_suffix_table) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  653:        free(bm);
    #####:  654:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  655:        return NULL;
        -:  656:    }
        -:  657:    
        3:  658:    bm->pattern_length = pattern_len;
        -:  659:    
        3:  660:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
        3:  661:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 returned 100%
        -:  662:    
        3:  663:    return bm;
        -:  664:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 0 returned 0% blocks executed 0%
    #####:  633:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
    #####:  634:    if (!pattern) {
branch  0 never executed
branch  1 never executed
    #####:  635:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  636:        return NULL;
        -:  637:    }
        -:  638:    
    #####:  639:    size_t pattern_len = strlen(pattern);
    #####:  640:    if (pattern_len == 0) {
branch  0 never executed
branch  1 never executed
    #####:  641:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  642:        return NULL;
        -:  643:    }
        -:  644:    
    #####:  645:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
    #####:  646:    if (!bm) {
branch  0 never executed
branch  1 never executed
    #####:  647:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  648:        return NULL;
        -:  649:    }
        -:  650:    
    #####:  651:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
    #####:  652:    if (!bm->good_suffix_table) {
branch  0 never executed
branch  1 never executed
    #####:  653:        free(bm);
    #####:  654:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  655:        return NULL;
        -:  656:    }
        -:  657:    
    #####:  658:    bm->pattern_length = pattern_len;
        -:  659:    
    #####:  660:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
    #####:  661:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 never executed
        -:  662:    
    #####:  663:    return bm;
        -:  664:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 0 returned 0% blocks executed 0%
    #####:  633:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
    #####:  634:    if (!pattern) {
branch  0 never executed
branch  1 never executed
    #####:  635:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  636:        return NULL;
        -:  637:    }
        -:  638:    
    #####:  639:    size_t pattern_len = strlen(pattern);
    #####:  640:    if (pattern_len == 0) {
branch  0 never executed
branch  1 never executed
    #####:  641:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  642:        return NULL;
        -:  643:    }
        -:  644:    
    #####:  645:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
    #####:  646:    if (!bm) {
branch  0 never executed
branch  1 never executed
    #####:  647:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  648:        return NULL;
        -:  649:    }
        -:  650:    
    #####:  651:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
    #####:  652:    if (!bm->good_suffix_table) {
branch  0 never executed
branch  1 never executed
    #####:  653:        free(bm);
    #####:  654:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  655:        return NULL;
        -:  656:    }
        -:  657:    
    #####:  658:    bm->pattern_length = pattern_len;
        -:  659:    
    #####:  660:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
    #####:  661:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 never executed
        -:  662:    
    #####:  663:    return bm;
        -:  664:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 19 returned 100% blocks executed 75%
       19:  633:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
       19:  634:    if (!pattern) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  635:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  636:        return NULL;
        -:  637:    }
        -:  638:    
       19:  639:    size_t pattern_len = strlen(pattern);
       19:  640:    if (pattern_len == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  641:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  642:        return NULL;
        -:  643:    }
        -:  644:    
       19:  645:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
       19:  646:    if (!bm) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  647:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  648:        return NULL;
        -:  649:    }
        -:  650:    
       19:  651:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
       19:  652:    if (!bm->good_suffix_table) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  653:        free(bm);
    #####:  654:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  655:        return NULL;
        -:  656:    }
        -:  657:    
       19:  658:    bm->pattern_length = pattern_len;
        -:  659:    
       19:  660:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
       19:  661:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 returned 100%
        -:  662:    
       19:  663:    return bm;
        -:  664:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 19 returned 100% blocks executed 75%
       19:  633:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
       19:  634:    if (!pattern) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  635:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  636:        return NULL;
        -:  637:    }
        -:  638:    
       19:  639:    size_t pattern_len = strlen(pattern);
       19:  640:    if (pattern_len == 0) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  641:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  642:        return NULL;
        -:  643:    }
        -:  644:    
       19:  645:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
       19:  646:    if (!bm) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  647:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  648:        return NULL;
        -:  649:    }
        -:  650:    
       19:  651:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
       19:  652:    if (!bm->good_suffix_table) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  653:        free(bm);
    #####:  654:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  655:        return NULL;
        -:  656:    }
        -:  657:    
       19:  658:    bm->pattern_length = pattern_len;
        -:  659:    
       19:  660:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
       19:  661:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 returned 100%
        -:  662:    
       19:  663:    return bm;
        -:  664:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 0 returned 0% blocks executed 0%
    #####:  633:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
    #####:  634:    if (!pattern) {
branch  0 never executed
branch  1 never executed
    #####:  635:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  636:        return NULL;
        -:  637:    }
        -:  638:    
    #####:  639:    size_t pattern_len = strlen(pattern);
    #####:  640:    if (pattern_len == 0) {
branch  0 never executed
branch  1 never executed
    #####:  641:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  642:        return NULL;
        -:  643:    }
        -:  644:    
    #####:  645:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
    #####:  646:    if (!bm) {
branch  0 never executed
branch  1 never executed
    #####:  647:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  648:        return NULL;
        -:  649:    }
        -:  650:    
    #####:  651:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
    #####:  652:    if (!bm->good_suffix_table) {
branch  0 never executed
branch  1 never executed
    #####:  653:        free(bm);
    #####:  654:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  655:        return NULL;
        -:  656:    }
        -:  657:    
    #####:  658:    bm->pattern_length = pattern_len;
        -:  659:    
    #####:  660:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
    #####:  661:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 never executed
        -:  662:    
    #####:  663:    return bm;
        -:  664:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 0 returned 0% blocks executed 0%
    #####:  633:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
    #####:  634:    if (!pattern) {
branch  0 never executed
branch  1 never executed
    #####:  635:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  636:        return NULL;
        -:  637:    }
        -:  638:    
    #####:  639:    size_t pattern_len = strlen(pattern);
    #####:  640:    if (pattern_len == 0) {
branch  0 never executed
branch  1 never executed
    #####:  641:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  642:        return NULL;
        -:  643:    }
        -:  644:    
    #####:  645:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
    #####:  646:    if (!bm) {
branch  0 never executed
branch  1 never executed
    #####:  647:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  648:        return NULL;
        -:  649:    }
        -:  650:    
    #####:  651:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
    #####:  652:    if (!bm->good_suffix_table) {
branch  0 never executed
branch  1 never executed
    #####:  653:        free(bm);
    #####:  654:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  655:        return NULL;
        -:  656:    }
        -:  657:    
    #####:  658:    bm->pattern_length = pattern_len;
        -:  659:    
    #####:  660:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
    #####:  661:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 never executed
        -:  662:    
    #####:  663:    return bm;
        -:  664:}
------------------
mercury_boyer_moore_create:
function mercury_boyer_moore_create called 0 returned 0% blocks executed 0%
    #####:  633:MercuryBoyerMoore* mercury_boyer_moore_create(const char* pattern) {
    #####:  634:    if (!pattern) {
branch  0 never executed
branch  1 never executed
    #####:  635:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be NULL");
    #####:  636:        return NULL;
        -:  637:    }
        -:  638:    
    #####:  639:    size_t pattern_len = strlen(pattern);
    #####:  640:    if (pattern_len == 0) {
branch  0 never executed
branch  1 never executed
    #####:  641:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern cannot be empty");
    #####:  642:        return NULL;
        -:  643:    }
        -:  644:    
    #####:  645:    MercuryBoyerMoore* bm = malloc(sizeof(MercuryBoyerMoore));
    #####:  646:    if (!bm) {
branch  0 never executed
branch  1 never executed
    #####:  647:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate Boyer-Moore structure");
    #####:  648:        return NULL;
        -:  649:    }
        -:  650:    
    #####:  651:    bm->good_suffix_table = malloc(pattern_len * sizeof(int));
    #####:  652:    if (!bm->good_suffix_table) {
branch  0 never executed
branch  1 never executed
    #####:  653:        free(bm);
    #####:  654:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate good suffix table");
    #####:  655:        return NULL;
        -:  656:    }
        -:  657:    
    #####:  658:    bm->pattern_length = pattern_len;
        -:  659:    
    #####:  660:    compute_bad_char_table(pattern, pattern_len, bm->bad_char_table);
    #####:  661:    compute_good_suffix_table(pattern, pattern_len, bm->good_suffix_table);
call    0 never executed
        -:  662:    
    #####:  663:    return bm;
        -:  664:}
------------------
        -:  665:
      60*:  666:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
      60*:  667:    if (!bm) return;
        -:  668:    
      60*:  669:    free(bm->good_suffix_table);
      60*:  670:    free(bm);
        -:  671:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 1 returned 100% blocks executed 100%
        1:  666:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
        1:  667:    if (!bm) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  668:    
        1:  669:    free(bm->good_suffix_table);
        1:  670:    free(bm);
        -:  671:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 13 returned 100% blocks executed 100%
       13:  666:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
       13:  667:    if (!bm) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  668:    
       13:  669:    free(bm->good_suffix_table);
       13:  670:    free(bm);
        -:  671:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 5 returned 100% blocks executed 100%
        5:  666:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
        5:  667:    if (!bm) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  668:    
        5:  669:    free(bm->good_suffix_table);
        5:  670:    free(bm);
        -:  671:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 3 returned 100% blocks executed 100%
        3:  666:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
        3:  667:    if (!bm) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  668:    
        3:  669:    free(bm->good_suffix_table);
        3:  670:    free(bm);
        -:  671:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 0 returned 0% blocks executed 0%
    #####:  666:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
    #####:  667:    if (!bm) return;
branch  0 never executed
branch  1 never executed
        -:  668:    
    #####:  669:    free(bm->good_suffix_table);
    #####:  670:    free(bm);
        -:  671:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 0 returned 0% blocks executed 0%
    #####:  666:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
    #####:  667:    if (!bm) return;
branch  0 never executed
branch  1 never executed
        -:  668:    
    #####:  669:    free(bm->good_suffix_table);
    #####:  670:    free(bm);
        -:  671:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 19 returned 100% blocks executed 100%
       19:  666:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
       19:  667:    if (!bm) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  668:    
       19:  669:    free(bm->good_suffix_table);
       19:  670:    free(bm);
        -:  671:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 19 returned 100% blocks executed 100%
       19:  666:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
       19:  667:    if (!bm) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  668:    
       19:  669:    free(bm->good_suffix_table);
       19:  670:    free(bm);
        -:  671:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 0 returned 0% blocks executed 0%
    #####:  666:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
    #####:  667:    if (!bm) return;
branch  0 never executed
branch  1 never executed
        -:  668:    
    #####:  669:    free(bm->good_suffix_table);
    #####:  670:    free(bm);
        -:  671:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 0 returned 0% blocks executed 0%
    #####:  666:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
    #####:  667:    if (!bm) return;
branch  0 never executed
branch  1 never executed
        -:  668:    
    #####:  669:    free(bm->good_suffix_table);
    #####:  670:    free(bm);
        -:  671:}
------------------
mercury_boyer_moore_destroy:
function mercury_boyer_moore_destroy called 0 returned 0% blocks executed 0%
    #####:  666:void mercury_boyer_moore_destroy(MercuryBoyerMoore* bm) {
    #####:  667:    if (!bm) return;
branch  0 never executed
branch  1 never executed
        -:  668:    
    #####:  669:    free(bm->good_suffix_table);
    #####:  670:    free(bm);
        -:  671:}
------------------
        -:  672:
        -:  673:/**
        -:  674: * @brief Search for pattern in text using Boyer-Moore algorithm
        -:  675: * 
        -:  676: * @details Uses precomputed tables for fast searching with SIMD acceleration
        -:  677: * for patterns >= 16 bytes.
        -:  678: * 
        -:  679: * @param bm Boyer-Moore structure with precomputed tables
        -:  680: * @param text Text to search in
        -:  681: * @param text_length Length of text in bytes
        -:  682: * @param pattern Pattern to search for (must match bm creation pattern)
        -:  683: * @return Index of first match or -1 if not found
        -:  684: * 
        -:  685: * @warning pattern must be the same as used in mercury_boyer_moore_create
        -:  686: * @note Thread-safe for concurrent searches with same bm structure
        -:  687: */
     244*:  688:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  689:                              size_t text_length, const char* pattern) {
     244*:  690:    if (!bm || !text || !pattern) {
        -:  691:        return -1;
        -:  692:    }
        -:  693:    
     243*:  694:    size_t pattern_len = bm->pattern_length;
        -:  695:    
        -:  696:    // Defensive check to prevent integer underflow
     243*:  697:    if (text_length < pattern_len || pattern_len == 0) {
        -:  698:        return -1;
        -:  699:    }
        -:  700:    
        -:  701:    size_t shift = 0;
     241*:  702:    size_t max_shift = text_length - pattern_len;
        -:  703:    
    1445*:  704:    while (shift <= max_shift) {
        -:  705:        // Prefetch ahead for better cache performance
    1439*:  706:        if (shift + pattern_len + 64 <= text_length) {
    1352*:  707:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
        -:  708:        }
        -:  709:        
        -:  710:        // SIMD-accelerated pattern comparison for longer patterns
    1439*:  711:        if (pattern_len >= 16) {
        -:  712:            // For patterns >= 16 bytes, use SIMD for initial comparison
      48*:  713:            const char* text_pos = text + shift;
        -:  714:            
        -:  715:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
      48*:  716:            size_t chunks = pattern_len / 16;
      48*:  717:            size_t remainder = pattern_len % 16;
        -:  718:            bool match = true;
        -:  719:            
        -:  720:            // Check from right to left in 16-byte chunks
     100*:  721:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
      52*:  722:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  723:                
        -:  724:                #ifdef USE_SIMD
      52*:  725:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
      52*:  726:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
        -:  727:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  728:                
      52*:  729:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
        -:  730:                    match = false;
        -:  731:                }
        -:  732:                #else
        -:  733:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  734:                    match = false;
        -:  735:                }
        -:  736:                #endif
        -:  737:            }
        -:  738:            
        -:  739:            // Check remainder bytes
      48*:  740:            if (match && remainder > 0) {
       3*:  741:                if (memcmp(pattern, text_pos, remainder) != 0) {
        -:  742:                    match = false;
        -:  743:                }
        -:  744:            }
        -:  745:            
      48*:  746:            if (match) {
       3*:  747:                return (int)shift;  // Match found
        -:  748:            }
        -:  749:            
        -:  750:            // Calculate shift using bad character heuristic
        -:  751:            // Use the rightmost character that didn't match
      45*:  752:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
      45*:  753:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  754:            
        -:  755:            // Use good suffix table for better shift
      45*:  756:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  757:            
      45*:  758:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  759:            if (shift == 0) shift = 1;  // Ensure progress
        -:  760:            
        -:  761:        } else {
        -:  762:            // Original Boyer-Moore for shorter patterns
    1391*:  763:            int j = (int)pattern_len - 1;
        -:  764:            
        -:  765:            // Compare from right to left
    3235*:  766:            while (j >= 0 && pattern[j] == text[shift + j]) {
    1844*:  767:                j--;
        -:  768:            }
        -:  769:            
    1391*:  770:            if (j < 0) {
     232*:  771:                return (int)shift;  // Match found
        -:  772:            } else {
        -:  773:                // Calculate shift using bad character and good suffix heuristics
    1159*:  774:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    1159*:  775:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  776:                
    1159*:  777:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  778:                if (shift == 0) shift = 1;  // Ensure progress
        -:  779:            }
        -:  780:        }
        -:  781:    }
        -:  782:    
        -:  783:    return -1;  // No match found
        -:  784:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 223 returned 100% blocks executed 63%
      223:  688:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  689:                              size_t text_length, const char* pattern) {
      223:  690:    if (!bm || !text || !pattern) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  691:        return -1;
        -:  692:    }
        -:  693:    
      223:  694:    size_t pattern_len = bm->pattern_length;
        -:  695:    
        -:  696:    // Defensive check to prevent integer underflow
      223:  697:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  698:        return -1;
        -:  699:    }
        -:  700:    
        -:  701:    size_t shift = 0;
      223:  702:    size_t max_shift = text_length - pattern_len;
        -:  703:    
     1335:  704:    while (shift <= max_shift) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
        -:  705:        // Prefetch ahead for better cache performance
     1334:  706:        if (shift + pattern_len + 64 <= text_length) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
     1325:  707:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 returned 100%
        -:  708:        }
        -:  709:        
        -:  710:        // SIMD-accelerated pattern comparison for longer patterns
     1334:  711:        if (pattern_len >= 16) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  712:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  713:            const char* text_pos = text + shift;
        -:  714:            
        -:  715:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  716:            size_t chunks = pattern_len / 16;
    #####:  717:            size_t remainder = pattern_len % 16;
        -:  718:            bool match = true;
        -:  719:            
        -:  720:            // Check from right to left in 16-byte chunks
    #####:  721:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  722:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  723:                
        -:  724:                #ifdef USE_SIMD
    #####:  725:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  726:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  727:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  728:                
    #####:  729:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  730:                    match = false;
        -:  731:                }
        -:  732:                #else
        -:  733:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  734:                    match = false;
        -:  735:                }
        -:  736:                #endif
        -:  737:            }
        -:  738:            
        -:  739:            // Check remainder bytes
    #####:  740:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  741:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  742:                    match = false;
        -:  743:                }
        -:  744:            }
        -:  745:            
    #####:  746:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  747:                return (int)shift;  // Match found
        -:  748:            }
        -:  749:            
        -:  750:            // Calculate shift using bad character heuristic
        -:  751:            // Use the rightmost character that didn't match
    #####:  752:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  753:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  754:            
        -:  755:            // Use good suffix table for better shift
    #####:  756:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  757:            
    #####:  758:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  759:            if (shift == 0) shift = 1;  // Ensure progress
        -:  760:            
        -:  761:        } else {
        -:  762:            // Original Boyer-Moore for shorter patterns
     1334:  763:            int j = (int)pattern_len - 1;
        -:  764:            
        -:  765:            // Compare from right to left
     3110:  766:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 taken 93% (fallthrough)
branch  1 taken 7%
branch  2 taken 61%
branch  3 taken 39% (fallthrough)
     1776:  767:                j--;
        -:  768:            }
        -:  769:            
     1334:  770:            if (j < 0) {
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
      222:  771:                return (int)shift;  // Match found
        -:  772:            } else {
        -:  773:                // Calculate shift using bad character and good suffix heuristics
     1112:  774:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
     1112:  775:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  776:                
     1112:  777:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  778:                if (shift == 0) shift = 1;  // Ensure progress
        -:  779:            }
        -:  780:        }
        -:  781:    }
        -:  782:    
        -:  783:    return -1;  // No match found
        -:  784:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 13 returned 100% blocks executed 100%
       13:  688:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  689:                              size_t text_length, const char* pattern) {
       13:  690:    if (!bm || !text || !pattern) {
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  691:        return -1;
        -:  692:    }
        -:  693:    
       12:  694:    size_t pattern_len = bm->pattern_length;
        -:  695:    
        -:  696:    // Defensive check to prevent integer underflow
       12:  697:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
        -:  698:        return -1;
        -:  699:    }
        -:  700:    
        -:  701:    size_t shift = 0;
       10:  702:    size_t max_shift = text_length - pattern_len;
        -:  703:    
       69:  704:    while (shift <= max_shift) {
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  705:        // Prefetch ahead for better cache performance
       66:  706:        if (shift + pattern_len + 64 <= text_length) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        7:  707:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 returned 100%
        -:  708:        }
        -:  709:        
        -:  710:        // SIMD-accelerated pattern comparison for longer patterns
       66:  711:        if (pattern_len >= 16) {
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
        -:  712:            // For patterns >= 16 bytes, use SIMD for initial comparison
       18:  713:            const char* text_pos = text + shift;
        -:  714:            
        -:  715:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
       18:  716:            size_t chunks = pattern_len / 16;
       18:  717:            size_t remainder = pattern_len % 16;
        -:  718:            bool match = true;
        -:  719:            
        -:  720:            // Check from right to left in 16-byte chunks
       39:  721:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 taken 54%
branch  1 taken 46% (fallthrough)
       21:  722:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  723:                
        -:  724:                #ifdef USE_SIMD
       21:  725:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
       21:  726:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
        -:  727:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  728:                
       21:  729:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 taken 76% (fallthrough)
branch  1 taken 24%
        -:  730:                    match = false;
        -:  731:                }
        -:  732:                #else
        -:  733:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  734:                    match = false;
        -:  735:                }
        -:  736:                #endif
        -:  737:            }
        -:  738:            
        -:  739:            // Check remainder bytes
       18:  740:            if (match && remainder > 0) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        2:  741:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  742:                    match = false;
        -:  743:                }
        -:  744:            }
        -:  745:            
       18:  746:            if (match) {
branch  0 taken 11% (fallthrough)
branch  1 taken 89%
        2:  747:                return (int)shift;  // Match found
        -:  748:            }
        -:  749:            
        -:  750:            // Calculate shift using bad character heuristic
        -:  751:            // Use the rightmost character that didn't match
       16:  752:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
       16:  753:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  754:            
        -:  755:            // Use good suffix table for better shift
       16:  756:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  757:            
       16:  758:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  759:            if (shift == 0) shift = 1;  // Ensure progress
        -:  760:            
        -:  761:        } else {
        -:  762:            // Original Boyer-Moore for shorter patterns
       48:  763:            int j = (int)pattern_len - 1;
        -:  764:            
        -:  765:            // Compare from right to left
       66:  766:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
branch  2 taken 30%
branch  3 taken 70% (fallthrough)
       18:  767:                j--;
        -:  768:            }
        -:  769:            
       48:  770:            if (j < 0) {
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
        5:  771:                return (int)shift;  // Match found
        -:  772:            } else {
        -:  773:                // Calculate shift using bad character and good suffix heuristics
       43:  774:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
       43:  775:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  776:                
       43:  777:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  778:                if (shift == 0) shift = 1;  // Ensure progress
        -:  779:            }
        -:  780:        }
        -:  781:    }
        -:  782:    
        -:  783:    return -1;  // No match found
        -:  784:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 5 returned 100% blocks executed 59%
        5:  688:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  689:                              size_t text_length, const char* pattern) {
        5:  690:    if (!bm || !text || !pattern) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  691:        return -1;
        -:  692:    }
        -:  693:    
        5:  694:    size_t pattern_len = bm->pattern_length;
        -:  695:    
        -:  696:    // Defensive check to prevent integer underflow
        5:  697:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  698:        return -1;
        -:  699:    }
        -:  700:    
        -:  701:    size_t shift = 0;
        5:  702:    size_t max_shift = text_length - pattern_len;
        -:  703:    
        9:  704:    while (shift <= max_shift) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -:  705:        // Prefetch ahead for better cache performance
        9:  706:        if (shift + pattern_len + 64 <= text_length) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  707:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  708:        }
        -:  709:        
        -:  710:        // SIMD-accelerated pattern comparison for longer patterns
        9:  711:        if (pattern_len >= 16) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  712:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  713:            const char* text_pos = text + shift;
        -:  714:            
        -:  715:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  716:            size_t chunks = pattern_len / 16;
    #####:  717:            size_t remainder = pattern_len % 16;
        -:  718:            bool match = true;
        -:  719:            
        -:  720:            // Check from right to left in 16-byte chunks
    #####:  721:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  722:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  723:                
        -:  724:                #ifdef USE_SIMD
    #####:  725:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  726:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  727:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  728:                
    #####:  729:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  730:                    match = false;
        -:  731:                }
        -:  732:                #else
        -:  733:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  734:                    match = false;
        -:  735:                }
        -:  736:                #endif
        -:  737:            }
        -:  738:            
        -:  739:            // Check remainder bytes
    #####:  740:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  741:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  742:                    match = false;
        -:  743:                }
        -:  744:            }
        -:  745:            
    #####:  746:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  747:                return (int)shift;  // Match found
        -:  748:            }
        -:  749:            
        -:  750:            // Calculate shift using bad character heuristic
        -:  751:            // Use the rightmost character that didn't match
    #####:  752:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  753:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  754:            
        -:  755:            // Use good suffix table for better shift
    #####:  756:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  757:            
    #####:  758:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  759:            if (shift == 0) shift = 1;  // Ensure progress
        -:  760:            
        -:  761:        } else {
        -:  762:            // Original Boyer-Moore for shorter patterns
        9:  763:            int j = (int)pattern_len - 1;
        -:  764:            
        -:  765:            // Compare from right to left
       59:  766:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
branch  2 taken 93%
branch  3 taken 7% (fallthrough)
       50:  767:                j--;
        -:  768:            }
        -:  769:            
        9:  770:            if (j < 0) {
branch  0 taken 56% (fallthrough)
branch  1 taken 44%
        5:  771:                return (int)shift;  // Match found
        -:  772:            } else {
        -:  773:                // Calculate shift using bad character and good suffix heuristics
        4:  774:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
        4:  775:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  776:                
        4:  777:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  778:                if (shift == 0) shift = 1;  // Ensure progress
        -:  779:            }
        -:  780:        }
        -:  781:    }
        -:  782:    
        -:  783:    return -1;  // No match found
        -:  784:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 3 returned 100% blocks executed 74%
        3:  688:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  689:                              size_t text_length, const char* pattern) {
        3:  690:    if (!bm || !text || !pattern) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -:  691:        return -1;
        -:  692:    }
        -:  693:    
        3:  694:    size_t pattern_len = bm->pattern_length;
        -:  695:    
        -:  696:    // Defensive check to prevent integer underflow
        3:  697:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  698:        return -1;
        -:  699:    }
        -:  700:    
        -:  701:    size_t shift = 0;
        3:  702:    size_t max_shift = text_length - pattern_len;
        -:  703:    
       32:  704:    while (shift <= max_shift) {
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  705:        // Prefetch ahead for better cache performance
       30:  706:        if (shift + pattern_len + 64 <= text_length) {
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
       20:  707:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 returned 100%
        -:  708:        }
        -:  709:        
        -:  710:        // SIMD-accelerated pattern comparison for longer patterns
       30:  711:        if (pattern_len >= 16) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  712:            // For patterns >= 16 bytes, use SIMD for initial comparison
       30:  713:            const char* text_pos = text + shift;
        -:  714:            
        -:  715:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
       30:  716:            size_t chunks = pattern_len / 16;
       30:  717:            size_t remainder = pattern_len % 16;
        -:  718:            bool match = true;
        -:  719:            
        -:  720:            // Check from right to left in 16-byte chunks
       61:  721:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 taken 51%
branch  1 taken 49% (fallthrough)
       31:  722:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  723:                
        -:  724:                #ifdef USE_SIMD
       31:  725:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
       31:  726:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        -:  727:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  728:                
       31:  729:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 taken 94% (fallthrough)
branch  1 taken 6%
        -:  730:                    match = false;
        -:  731:                }
        -:  732:                #else
        -:  733:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  734:                    match = false;
        -:  735:                }
        -:  736:                #endif
        -:  737:            }
        -:  738:            
        -:  739:            // Check remainder bytes
       30:  740:            if (match && remainder > 0) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        1:  741:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  742:                    match = false;
        -:  743:                }
        -:  744:            }
        -:  745:            
       30:  746:            if (match) {
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        1:  747:                return (int)shift;  // Match found
        -:  748:            }
        -:  749:            
        -:  750:            // Calculate shift using bad character heuristic
        -:  751:            // Use the rightmost character that didn't match
       29:  752:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
       29:  753:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  754:            
        -:  755:            // Use good suffix table for better shift
       29:  756:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  757:            
       29:  758:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  759:            if (shift == 0) shift = 1;  // Ensure progress
        -:  760:            
        -:  761:        } else {
        -:  762:            // Original Boyer-Moore for shorter patterns
    #####:  763:            int j = (int)pattern_len - 1;
        -:  764:            
        -:  765:            // Compare from right to left
    #####:  766:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  767:                j--;
        -:  768:            }
        -:  769:            
    #####:  770:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  771:                return (int)shift;  // Match found
        -:  772:            } else {
        -:  773:                // Calculate shift using bad character and good suffix heuristics
    #####:  774:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  775:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  776:                
    #####:  777:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  778:                if (shift == 0) shift = 1;  // Ensure progress
        -:  779:            }
        -:  780:        }
        -:  781:    }
        -:  782:    
        -:  783:    return -1;  // No match found
        -:  784:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  688:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  689:                              size_t text_length, const char* pattern) {
    #####:  690:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  691:        return -1;
        -:  692:    }
        -:  693:    
    #####:  694:    size_t pattern_len = bm->pattern_length;
        -:  695:    
        -:  696:    // Defensive check to prevent integer underflow
    #####:  697:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  698:        return -1;
        -:  699:    }
        -:  700:    
        -:  701:    size_t shift = 0;
    #####:  702:    size_t max_shift = text_length - pattern_len;
        -:  703:    
    #####:  704:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  705:        // Prefetch ahead for better cache performance
    #####:  706:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  707:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  708:        }
        -:  709:        
        -:  710:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  711:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  712:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  713:            const char* text_pos = text + shift;
        -:  714:            
        -:  715:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  716:            size_t chunks = pattern_len / 16;
    #####:  717:            size_t remainder = pattern_len % 16;
        -:  718:            bool match = true;
        -:  719:            
        -:  720:            // Check from right to left in 16-byte chunks
    #####:  721:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  722:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  723:                
        -:  724:                #ifdef USE_SIMD
    #####:  725:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  726:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  727:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  728:                
    #####:  729:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  730:                    match = false;
        -:  731:                }
        -:  732:                #else
        -:  733:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  734:                    match = false;
        -:  735:                }
        -:  736:                #endif
        -:  737:            }
        -:  738:            
        -:  739:            // Check remainder bytes
    #####:  740:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  741:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  742:                    match = false;
        -:  743:                }
        -:  744:            }
        -:  745:            
    #####:  746:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  747:                return (int)shift;  // Match found
        -:  748:            }
        -:  749:            
        -:  750:            // Calculate shift using bad character heuristic
        -:  751:            // Use the rightmost character that didn't match
    #####:  752:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  753:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  754:            
        -:  755:            // Use good suffix table for better shift
    #####:  756:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  757:            
    #####:  758:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  759:            if (shift == 0) shift = 1;  // Ensure progress
        -:  760:            
        -:  761:        } else {
        -:  762:            // Original Boyer-Moore for shorter patterns
    #####:  763:            int j = (int)pattern_len - 1;
        -:  764:            
        -:  765:            // Compare from right to left
    #####:  766:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  767:                j--;
        -:  768:            }
        -:  769:            
    #####:  770:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  771:                return (int)shift;  // Match found
        -:  772:            } else {
        -:  773:                // Calculate shift using bad character and good suffix heuristics
    #####:  774:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  775:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  776:                
    #####:  777:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  778:                if (shift == 0) shift = 1;  // Ensure progress
        -:  779:            }
        -:  780:        }
        -:  781:    }
        -:  782:    
        -:  783:    return -1;  // No match found
        -:  784:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  688:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  689:                              size_t text_length, const char* pattern) {
    #####:  690:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  691:        return -1;
        -:  692:    }
        -:  693:    
    #####:  694:    size_t pattern_len = bm->pattern_length;
        -:  695:    
        -:  696:    // Defensive check to prevent integer underflow
    #####:  697:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  698:        return -1;
        -:  699:    }
        -:  700:    
        -:  701:    size_t shift = 0;
    #####:  702:    size_t max_shift = text_length - pattern_len;
        -:  703:    
    #####:  704:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  705:        // Prefetch ahead for better cache performance
    #####:  706:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  707:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  708:        }
        -:  709:        
        -:  710:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  711:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  712:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  713:            const char* text_pos = text + shift;
        -:  714:            
        -:  715:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  716:            size_t chunks = pattern_len / 16;
    #####:  717:            size_t remainder = pattern_len % 16;
        -:  718:            bool match = true;
        -:  719:            
        -:  720:            // Check from right to left in 16-byte chunks
    #####:  721:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  722:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  723:                
        -:  724:                #ifdef USE_SIMD
    #####:  725:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  726:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  727:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  728:                
    #####:  729:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  730:                    match = false;
        -:  731:                }
        -:  732:                #else
        -:  733:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  734:                    match = false;
        -:  735:                }
        -:  736:                #endif
        -:  737:            }
        -:  738:            
        -:  739:            // Check remainder bytes
    #####:  740:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  741:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  742:                    match = false;
        -:  743:                }
        -:  744:            }
        -:  745:            
    #####:  746:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  747:                return (int)shift;  // Match found
        -:  748:            }
        -:  749:            
        -:  750:            // Calculate shift using bad character heuristic
        -:  751:            // Use the rightmost character that didn't match
    #####:  752:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  753:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  754:            
        -:  755:            // Use good suffix table for better shift
    #####:  756:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  757:            
    #####:  758:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  759:            if (shift == 0) shift = 1;  // Ensure progress
        -:  760:            
        -:  761:        } else {
        -:  762:            // Original Boyer-Moore for shorter patterns
    #####:  763:            int j = (int)pattern_len - 1;
        -:  764:            
        -:  765:            // Compare from right to left
    #####:  766:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  767:                j--;
        -:  768:            }
        -:  769:            
    #####:  770:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  771:                return (int)shift;  // Match found
        -:  772:            } else {
        -:  773:                // Calculate shift using bad character and good suffix heuristics
    #####:  774:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  775:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  776:                
    #####:  777:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  778:                if (shift == 0) shift = 1;  // Ensure progress
        -:  779:            }
        -:  780:        }
        -:  781:    }
        -:  782:    
        -:  783:    return -1;  // No match found
        -:  784:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  688:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  689:                              size_t text_length, const char* pattern) {
    #####:  690:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  691:        return -1;
        -:  692:    }
        -:  693:    
    #####:  694:    size_t pattern_len = bm->pattern_length;
        -:  695:    
        -:  696:    // Defensive check to prevent integer underflow
    #####:  697:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  698:        return -1;
        -:  699:    }
        -:  700:    
        -:  701:    size_t shift = 0;
    #####:  702:    size_t max_shift = text_length - pattern_len;
        -:  703:    
    #####:  704:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  705:        // Prefetch ahead for better cache performance
    #####:  706:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  707:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  708:        }
        -:  709:        
        -:  710:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  711:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  712:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  713:            const char* text_pos = text + shift;
        -:  714:            
        -:  715:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  716:            size_t chunks = pattern_len / 16;
    #####:  717:            size_t remainder = pattern_len % 16;
        -:  718:            bool match = true;
        -:  719:            
        -:  720:            // Check from right to left in 16-byte chunks
    #####:  721:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  722:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  723:                
        -:  724:                #ifdef USE_SIMD
    #####:  725:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  726:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  727:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  728:                
    #####:  729:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  730:                    match = false;
        -:  731:                }
        -:  732:                #else
        -:  733:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  734:                    match = false;
        -:  735:                }
        -:  736:                #endif
        -:  737:            }
        -:  738:            
        -:  739:            // Check remainder bytes
    #####:  740:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  741:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  742:                    match = false;
        -:  743:                }
        -:  744:            }
        -:  745:            
    #####:  746:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  747:                return (int)shift;  // Match found
        -:  748:            }
        -:  749:            
        -:  750:            // Calculate shift using bad character heuristic
        -:  751:            // Use the rightmost character that didn't match
    #####:  752:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  753:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  754:            
        -:  755:            // Use good suffix table for better shift
    #####:  756:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  757:            
    #####:  758:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  759:            if (shift == 0) shift = 1;  // Ensure progress
        -:  760:            
        -:  761:        } else {
        -:  762:            // Original Boyer-Moore for shorter patterns
    #####:  763:            int j = (int)pattern_len - 1;
        -:  764:            
        -:  765:            // Compare from right to left
    #####:  766:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  767:                j--;
        -:  768:            }
        -:  769:            
    #####:  770:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  771:                return (int)shift;  // Match found
        -:  772:            } else {
        -:  773:                // Calculate shift using bad character and good suffix heuristics
    #####:  774:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  775:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  776:                
    #####:  777:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  778:                if (shift == 0) shift = 1;  // Ensure progress
        -:  779:            }
        -:  780:        }
        -:  781:    }
        -:  782:    
        -:  783:    return -1;  // No match found
        -:  784:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  688:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  689:                              size_t text_length, const char* pattern) {
    #####:  690:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  691:        return -1;
        -:  692:    }
        -:  693:    
    #####:  694:    size_t pattern_len = bm->pattern_length;
        -:  695:    
        -:  696:    // Defensive check to prevent integer underflow
    #####:  697:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  698:        return -1;
        -:  699:    }
        -:  700:    
        -:  701:    size_t shift = 0;
    #####:  702:    size_t max_shift = text_length - pattern_len;
        -:  703:    
    #####:  704:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  705:        // Prefetch ahead for better cache performance
    #####:  706:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  707:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  708:        }
        -:  709:        
        -:  710:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  711:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  712:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  713:            const char* text_pos = text + shift;
        -:  714:            
        -:  715:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  716:            size_t chunks = pattern_len / 16;
    #####:  717:            size_t remainder = pattern_len % 16;
        -:  718:            bool match = true;
        -:  719:            
        -:  720:            // Check from right to left in 16-byte chunks
    #####:  721:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  722:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  723:                
        -:  724:                #ifdef USE_SIMD
    #####:  725:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  726:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  727:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  728:                
    #####:  729:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  730:                    match = false;
        -:  731:                }
        -:  732:                #else
        -:  733:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  734:                    match = false;
        -:  735:                }
        -:  736:                #endif
        -:  737:            }
        -:  738:            
        -:  739:            // Check remainder bytes
    #####:  740:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  741:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  742:                    match = false;
        -:  743:                }
        -:  744:            }
        -:  745:            
    #####:  746:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  747:                return (int)shift;  // Match found
        -:  748:            }
        -:  749:            
        -:  750:            // Calculate shift using bad character heuristic
        -:  751:            // Use the rightmost character that didn't match
    #####:  752:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  753:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  754:            
        -:  755:            // Use good suffix table for better shift
    #####:  756:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  757:            
    #####:  758:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  759:            if (shift == 0) shift = 1;  // Ensure progress
        -:  760:            
        -:  761:        } else {
        -:  762:            // Original Boyer-Moore for shorter patterns
    #####:  763:            int j = (int)pattern_len - 1;
        -:  764:            
        -:  765:            // Compare from right to left
    #####:  766:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  767:                j--;
        -:  768:            }
        -:  769:            
    #####:  770:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  771:                return (int)shift;  // Match found
        -:  772:            } else {
        -:  773:                // Calculate shift using bad character and good suffix heuristics
    #####:  774:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  775:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  776:                
    #####:  777:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  778:                if (shift == 0) shift = 1;  // Ensure progress
        -:  779:            }
        -:  780:        }
        -:  781:    }
        -:  782:    
        -:  783:    return -1;  // No match found
        -:  784:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  688:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  689:                              size_t text_length, const char* pattern) {
    #####:  690:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  691:        return -1;
        -:  692:    }
        -:  693:    
    #####:  694:    size_t pattern_len = bm->pattern_length;
        -:  695:    
        -:  696:    // Defensive check to prevent integer underflow
    #####:  697:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  698:        return -1;
        -:  699:    }
        -:  700:    
        -:  701:    size_t shift = 0;
    #####:  702:    size_t max_shift = text_length - pattern_len;
        -:  703:    
    #####:  704:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  705:        // Prefetch ahead for better cache performance
    #####:  706:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  707:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  708:        }
        -:  709:        
        -:  710:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  711:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  712:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  713:            const char* text_pos = text + shift;
        -:  714:            
        -:  715:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  716:            size_t chunks = pattern_len / 16;
    #####:  717:            size_t remainder = pattern_len % 16;
        -:  718:            bool match = true;
        -:  719:            
        -:  720:            // Check from right to left in 16-byte chunks
    #####:  721:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  722:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  723:                
        -:  724:                #ifdef USE_SIMD
    #####:  725:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  726:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  727:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  728:                
    #####:  729:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  730:                    match = false;
        -:  731:                }
        -:  732:                #else
        -:  733:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  734:                    match = false;
        -:  735:                }
        -:  736:                #endif
        -:  737:            }
        -:  738:            
        -:  739:            // Check remainder bytes
    #####:  740:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  741:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  742:                    match = false;
        -:  743:                }
        -:  744:            }
        -:  745:            
    #####:  746:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  747:                return (int)shift;  // Match found
        -:  748:            }
        -:  749:            
        -:  750:            // Calculate shift using bad character heuristic
        -:  751:            // Use the rightmost character that didn't match
    #####:  752:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  753:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  754:            
        -:  755:            // Use good suffix table for better shift
    #####:  756:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  757:            
    #####:  758:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  759:            if (shift == 0) shift = 1;  // Ensure progress
        -:  760:            
        -:  761:        } else {
        -:  762:            // Original Boyer-Moore for shorter patterns
    #####:  763:            int j = (int)pattern_len - 1;
        -:  764:            
        -:  765:            // Compare from right to left
    #####:  766:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  767:                j--;
        -:  768:            }
        -:  769:            
    #####:  770:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  771:                return (int)shift;  // Match found
        -:  772:            } else {
        -:  773:                // Calculate shift using bad character and good suffix heuristics
    #####:  774:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  775:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  776:                
    #####:  777:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  778:                if (shift == 0) shift = 1;  // Ensure progress
        -:  779:            }
        -:  780:        }
        -:  781:    }
        -:  782:    
        -:  783:    return -1;  // No match found
        -:  784:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  688:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  689:                              size_t text_length, const char* pattern) {
    #####:  690:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  691:        return -1;
        -:  692:    }
        -:  693:    
    #####:  694:    size_t pattern_len = bm->pattern_length;
        -:  695:    
        -:  696:    // Defensive check to prevent integer underflow
    #####:  697:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  698:        return -1;
        -:  699:    }
        -:  700:    
        -:  701:    size_t shift = 0;
    #####:  702:    size_t max_shift = text_length - pattern_len;
        -:  703:    
    #####:  704:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  705:        // Prefetch ahead for better cache performance
    #####:  706:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  707:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  708:        }
        -:  709:        
        -:  710:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  711:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  712:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  713:            const char* text_pos = text + shift;
        -:  714:            
        -:  715:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  716:            size_t chunks = pattern_len / 16;
    #####:  717:            size_t remainder = pattern_len % 16;
        -:  718:            bool match = true;
        -:  719:            
        -:  720:            // Check from right to left in 16-byte chunks
    #####:  721:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  722:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  723:                
        -:  724:                #ifdef USE_SIMD
    #####:  725:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  726:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  727:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  728:                
    #####:  729:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  730:                    match = false;
        -:  731:                }
        -:  732:                #else
        -:  733:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  734:                    match = false;
        -:  735:                }
        -:  736:                #endif
        -:  737:            }
        -:  738:            
        -:  739:            // Check remainder bytes
    #####:  740:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  741:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  742:                    match = false;
        -:  743:                }
        -:  744:            }
        -:  745:            
    #####:  746:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  747:                return (int)shift;  // Match found
        -:  748:            }
        -:  749:            
        -:  750:            // Calculate shift using bad character heuristic
        -:  751:            // Use the rightmost character that didn't match
    #####:  752:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  753:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  754:            
        -:  755:            // Use good suffix table for better shift
    #####:  756:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  757:            
    #####:  758:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  759:            if (shift == 0) shift = 1;  // Ensure progress
        -:  760:            
        -:  761:        } else {
        -:  762:            // Original Boyer-Moore for shorter patterns
    #####:  763:            int j = (int)pattern_len - 1;
        -:  764:            
        -:  765:            // Compare from right to left
    #####:  766:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  767:                j--;
        -:  768:            }
        -:  769:            
    #####:  770:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  771:                return (int)shift;  // Match found
        -:  772:            } else {
        -:  773:                // Calculate shift using bad character and good suffix heuristics
    #####:  774:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  775:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  776:                
    #####:  777:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  778:                if (shift == 0) shift = 1;  // Ensure progress
        -:  779:            }
        -:  780:        }
        -:  781:    }
        -:  782:    
        -:  783:    return -1;  // No match found
        -:  784:}
------------------
mercury_boyer_moore_search:
function mercury_boyer_moore_search called 0 returned 0% blocks executed 0%
    #####:  688:int mercury_boyer_moore_search(const MercuryBoyerMoore* bm, const char* text, 
        -:  689:                              size_t text_length, const char* pattern) {
    #####:  690:    if (!bm || !text || !pattern) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  691:        return -1;
        -:  692:    }
        -:  693:    
    #####:  694:    size_t pattern_len = bm->pattern_length;
        -:  695:    
        -:  696:    // Defensive check to prevent integer underflow
    #####:  697:    if (text_length < pattern_len || pattern_len == 0) {
branch  0 never executed
branch  1 never executed
        -:  698:        return -1;
        -:  699:    }
        -:  700:    
        -:  701:    size_t shift = 0;
    #####:  702:    size_t max_shift = text_length - pattern_len;
        -:  703:    
    #####:  704:    while (shift <= max_shift) {
branch  0 never executed
branch  1 never executed
        -:  705:        // Prefetch ahead for better cache performance
    #####:  706:        if (shift + pattern_len + 64 <= text_length) {
branch  0 never executed
branch  1 never executed
    #####:  707:            MERCURY_PREFETCH_READ_LOW(text + shift + pattern_len + 64);
call    0 never executed
        -:  708:        }
        -:  709:        
        -:  710:        // SIMD-accelerated pattern comparison for longer patterns
    #####:  711:        if (pattern_len >= 16) {
branch  0 never executed
branch  1 never executed
        -:  712:            // For patterns >= 16 bytes, use SIMD for initial comparison
    #####:  713:            const char* text_pos = text + shift;
        -:  714:            
        -:  715:            // Compare in 16-byte chunks from the end (Boyer-Moore style)
    #####:  716:            size_t chunks = pattern_len / 16;
    #####:  717:            size_t remainder = pattern_len % 16;
        -:  718:            bool match = true;
        -:  719:            
        -:  720:            // Check from right to left in 16-byte chunks
    #####:  721:            for (size_t chunk = chunks; chunk > 0 && match; chunk--) {
branch  0 never executed
branch  1 never executed
    #####:  722:                size_t offset = (chunk - 1) * 16 + remainder;
        -:  723:                
        -:  724:                #ifdef USE_SIMD
    #####:  725:                __m128i pattern_chunk = _mm_loadu_si128((const __m128i*)(pattern + offset));
branch  0 never executed
branch  1 never executed
    #####:  726:                __m128i text_chunk = _mm_loadu_si128((const __m128i*)(text_pos + offset));
branch  0 never executed
branch  1 never executed
        -:  727:                __m128i cmp = _mm_cmpeq_epi8(pattern_chunk, text_chunk);
        -:  728:                
    #####:  729:                if (_mm_movemask_epi8(cmp) != 0xFFFF) {
branch  0 never executed
branch  1 never executed
        -:  730:                    match = false;
        -:  731:                }
        -:  732:                #else
        -:  733:                if (memcmp(pattern + offset, text_pos + offset, 16) != 0) {
        -:  734:                    match = false;
        -:  735:                }
        -:  736:                #endif
        -:  737:            }
        -:  738:            
        -:  739:            // Check remainder bytes
    #####:  740:            if (match && remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####:  741:                if (memcmp(pattern, text_pos, remainder) != 0) {
branch  0 never executed
branch  1 never executed
        -:  742:                    match = false;
        -:  743:                }
        -:  744:            }
        -:  745:            
    #####:  746:            if (match) {
branch  0 never executed
branch  1 never executed
    #####:  747:                return (int)shift;  // Match found
        -:  748:            }
        -:  749:            
        -:  750:            // Calculate shift using bad character heuristic
        -:  751:            // Use the rightmost character that didn't match
    #####:  752:            unsigned char bad_char = (unsigned char)text[shift + pattern_len - 1];
    #####:  753:            int bad_char_shift = (int)pattern_len - 1 - bm->bad_char_table[bad_char];
        -:  754:            
        -:  755:            // Use good suffix table for better shift
    #####:  756:            int good_suffix_shift = bm->good_suffix_table[pattern_len - 1];
        -:  757:            
    #####:  758:            shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  759:            if (shift == 0) shift = 1;  // Ensure progress
        -:  760:            
        -:  761:        } else {
        -:  762:            // Original Boyer-Moore for shorter patterns
    #####:  763:            int j = (int)pattern_len - 1;
        -:  764:            
        -:  765:            // Compare from right to left
    #####:  766:            while (j >= 0 && pattern[j] == text[shift + j]) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  767:                j--;
        -:  768:            }
        -:  769:            
    #####:  770:            if (j < 0) {
branch  0 never executed
branch  1 never executed
    #####:  771:                return (int)shift;  // Match found
        -:  772:            } else {
        -:  773:                // Calculate shift using bad character and good suffix heuristics
    #####:  774:                int bad_char_shift = j - bm->bad_char_table[(unsigned char)text[shift + j]];
    #####:  775:                int good_suffix_shift = bm->good_suffix_table[j];
        -:  776:                
    #####:  777:                shift += (bad_char_shift > good_suffix_shift) ? bad_char_shift : good_suffix_shift;
        -:  778:                if (shift == 0) shift = 1;  // Ensure progress
        -:  779:            }
        -:  780:        }
        -:  781:    }
        -:  782:    
        -:  783:    return -1;  // No match found
        -:  784:}
------------------
        -:  785:
        -:  786:// === SIMD UTILITIES ===
        -:  787:
        -:  788:#ifdef USE_SIMD
       3*:  789:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  790:                                  const double* thresholds, uint64_t* violations) {
        -:  791:    // SIMD implementation for x86_64
        -:  792:    #ifdef MERCURY_X86_64
        -:  793:        // Process 4 metrics at a time using AVX
       3*:  794:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  795:        
       4*:  796:        for (size_t i = 0; i < simd_count; i += 4) {
        -:  797:            // Load thresholds
       1*:  798:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  799:            
        -:  800:            // Compare with metrics (example for one field)
        -:  801:            // This would be expanded for all threshold types
       1*:  802:            __m256d response_times = _mm256_set_pd(
       1*:  803:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
       1*:  804:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
       1*:  805:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
       1*:  806:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  807:            );
        -:  808:            
        -:  809:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  810:            int mask = _mm256_movemask_pd(comparison);
        -:  811:            
        -:  812:            // Set violation flags based on comparison
       5*:  813:            for (int j = 0; j < 4; j++) {
       4*:  814:                if (mask & (1 << j)) {
       4*:  815:                    violations[i + j] |= 1;  // Response time violation
        -:  816:                }
        -:  817:            }
        -:  818:        }
        -:  819:        
        -:  820:        // Handle remaining metrics
      10*:  821:        for (size_t i = simd_count; i < count; i++) {
       7*:  822:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
       7*:  823:            if (response_time > thresholds[i]) {
       7*:  824:                violations[i] |= 1;
        -:  825:            }
        -:  826:        }
        -:  827:    #else
        -:  828:        // Fallback to scalar implementation
        -:  829:        for (size_t i = 0; i < count; i++) {
        -:  830:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  831:            if (response_time > thresholds[i]) {
        -:  832:                violations[i] |= 1;
        -:  833:            }
        -:  834:        }
        -:  835:    #endif
       3*:  836:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  789:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  790:                                  const double* thresholds, uint64_t* violations) {
        -:  791:    // SIMD implementation for x86_64
        -:  792:    #ifdef MERCURY_X86_64
        -:  793:        // Process 4 metrics at a time using AVX
    #####:  794:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  795:        
    #####:  796:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  797:            // Load thresholds
    #####:  798:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  799:            
        -:  800:            // Compare with metrics (example for one field)
        -:  801:            // This would be expanded for all threshold types
    #####:  802:            __m256d response_times = _mm256_set_pd(
    #####:  803:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  804:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  805:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  806:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  807:            );
        -:  808:            
        -:  809:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  810:            int mask = _mm256_movemask_pd(comparison);
        -:  811:            
        -:  812:            // Set violation flags based on comparison
    #####:  813:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  814:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  815:                    violations[i + j] |= 1;  // Response time violation
        -:  816:                }
        -:  817:            }
        -:  818:        }
        -:  819:        
        -:  820:        // Handle remaining metrics
    #####:  821:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  822:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  823:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  824:                violations[i] |= 1;
        -:  825:            }
        -:  826:        }
        -:  827:    #else
        -:  828:        // Fallback to scalar implementation
        -:  829:        for (size_t i = 0; i < count; i++) {
        -:  830:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  831:            if (response_time > thresholds[i]) {
        -:  832:                violations[i] |= 1;
        -:  833:            }
        -:  834:        }
        -:  835:    #endif
    #####:  836:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  789:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  790:                                  const double* thresholds, uint64_t* violations) {
        -:  791:    // SIMD implementation for x86_64
        -:  792:    #ifdef MERCURY_X86_64
        -:  793:        // Process 4 metrics at a time using AVX
    #####:  794:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  795:        
    #####:  796:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  797:            // Load thresholds
    #####:  798:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  799:            
        -:  800:            // Compare with metrics (example for one field)
        -:  801:            // This would be expanded for all threshold types
    #####:  802:            __m256d response_times = _mm256_set_pd(
    #####:  803:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  804:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  805:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  806:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  807:            );
        -:  808:            
        -:  809:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  810:            int mask = _mm256_movemask_pd(comparison);
        -:  811:            
        -:  812:            // Set violation flags based on comparison
    #####:  813:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  814:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  815:                    violations[i + j] |= 1;  // Response time violation
        -:  816:                }
        -:  817:            }
        -:  818:        }
        -:  819:        
        -:  820:        // Handle remaining metrics
    #####:  821:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  822:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  823:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  824:                violations[i] |= 1;
        -:  825:            }
        -:  826:        }
        -:  827:    #else
        -:  828:        // Fallback to scalar implementation
        -:  829:        for (size_t i = 0; i < count; i++) {
        -:  830:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  831:            if (response_time > thresholds[i]) {
        -:  832:                violations[i] |= 1;
        -:  833:            }
        -:  834:        }
        -:  835:    #endif
    #####:  836:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 3 returned 100% blocks executed 100%
        3:  789:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  790:                                  const double* thresholds, uint64_t* violations) {
        -:  791:    // SIMD implementation for x86_64
        -:  792:    #ifdef MERCURY_X86_64
        -:  793:        // Process 4 metrics at a time using AVX
        3:  794:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  795:        
        4:  796:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 taken 25%
branch  1 taken 75%
        -:  797:            // Load thresholds
        1:  798:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  799:            
        -:  800:            // Compare with metrics (example for one field)
        -:  801:            // This would be expanded for all threshold types
        1:  802:            __m256d response_times = _mm256_set_pd(
        1:  803:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
        1:  804:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
        1:  805:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
        1:  806:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  807:            );
        -:  808:            
        -:  809:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  810:            int mask = _mm256_movemask_pd(comparison);
        -:  811:            
        -:  812:            // Set violation flags based on comparison
        5:  813:            for (int j = 0; j < 4; j++) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        4:  814:                if (mask & (1 << j)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        4:  815:                    violations[i + j] |= 1;  // Response time violation
        -:  816:                }
        -:  817:            }
        -:  818:        }
        -:  819:        
        -:  820:        // Handle remaining metrics
       10:  821:        for (size_t i = simd_count; i < count; i++) {
branch  0 taken 70%
branch  1 taken 30% (fallthrough)
        7:  822:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        7:  823:            if (response_time > thresholds[i]) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        7:  824:                violations[i] |= 1;
        -:  825:            }
        -:  826:        }
        -:  827:    #else
        -:  828:        // Fallback to scalar implementation
        -:  829:        for (size_t i = 0; i < count; i++) {
        -:  830:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  831:            if (response_time > thresholds[i]) {
        -:  832:                violations[i] |= 1;
        -:  833:            }
        -:  834:        }
        -:  835:    #endif
        3:  836:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  789:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  790:                                  const double* thresholds, uint64_t* violations) {
        -:  791:    // SIMD implementation for x86_64
        -:  792:    #ifdef MERCURY_X86_64
        -:  793:        // Process 4 metrics at a time using AVX
    #####:  794:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  795:        
    #####:  796:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  797:            // Load thresholds
    #####:  798:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  799:            
        -:  800:            // Compare with metrics (example for one field)
        -:  801:            // This would be expanded for all threshold types
    #####:  802:            __m256d response_times = _mm256_set_pd(
    #####:  803:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  804:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  805:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  806:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  807:            );
        -:  808:            
        -:  809:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  810:            int mask = _mm256_movemask_pd(comparison);
        -:  811:            
        -:  812:            // Set violation flags based on comparison
    #####:  813:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  814:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  815:                    violations[i + j] |= 1;  // Response time violation
        -:  816:                }
        -:  817:            }
        -:  818:        }
        -:  819:        
        -:  820:        // Handle remaining metrics
    #####:  821:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  822:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  823:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  824:                violations[i] |= 1;
        -:  825:            }
        -:  826:        }
        -:  827:    #else
        -:  828:        // Fallback to scalar implementation
        -:  829:        for (size_t i = 0; i < count; i++) {
        -:  830:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  831:            if (response_time > thresholds[i]) {
        -:  832:                violations[i] |= 1;
        -:  833:            }
        -:  834:        }
        -:  835:    #endif
    #####:  836:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  789:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  790:                                  const double* thresholds, uint64_t* violations) {
        -:  791:    // SIMD implementation for x86_64
        -:  792:    #ifdef MERCURY_X86_64
        -:  793:        // Process 4 metrics at a time using AVX
    #####:  794:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  795:        
    #####:  796:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  797:            // Load thresholds
    #####:  798:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  799:            
        -:  800:            // Compare with metrics (example for one field)
        -:  801:            // This would be expanded for all threshold types
    #####:  802:            __m256d response_times = _mm256_set_pd(
    #####:  803:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  804:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  805:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  806:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  807:            );
        -:  808:            
        -:  809:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  810:            int mask = _mm256_movemask_pd(comparison);
        -:  811:            
        -:  812:            // Set violation flags based on comparison
    #####:  813:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  814:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  815:                    violations[i + j] |= 1;  // Response time violation
        -:  816:                }
        -:  817:            }
        -:  818:        }
        -:  819:        
        -:  820:        // Handle remaining metrics
    #####:  821:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  822:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  823:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  824:                violations[i] |= 1;
        -:  825:            }
        -:  826:        }
        -:  827:    #else
        -:  828:        // Fallback to scalar implementation
        -:  829:        for (size_t i = 0; i < count; i++) {
        -:  830:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  831:            if (response_time > thresholds[i]) {
        -:  832:                violations[i] |= 1;
        -:  833:            }
        -:  834:        }
        -:  835:    #endif
    #####:  836:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  789:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  790:                                  const double* thresholds, uint64_t* violations) {
        -:  791:    // SIMD implementation for x86_64
        -:  792:    #ifdef MERCURY_X86_64
        -:  793:        // Process 4 metrics at a time using AVX
    #####:  794:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  795:        
    #####:  796:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  797:            // Load thresholds
    #####:  798:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  799:            
        -:  800:            // Compare with metrics (example for one field)
        -:  801:            // This would be expanded for all threshold types
    #####:  802:            __m256d response_times = _mm256_set_pd(
    #####:  803:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  804:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  805:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  806:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  807:            );
        -:  808:            
        -:  809:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  810:            int mask = _mm256_movemask_pd(comparison);
        -:  811:            
        -:  812:            // Set violation flags based on comparison
    #####:  813:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  814:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  815:                    violations[i + j] |= 1;  // Response time violation
        -:  816:                }
        -:  817:            }
        -:  818:        }
        -:  819:        
        -:  820:        // Handle remaining metrics
    #####:  821:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  822:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  823:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  824:                violations[i] |= 1;
        -:  825:            }
        -:  826:        }
        -:  827:    #else
        -:  828:        // Fallback to scalar implementation
        -:  829:        for (size_t i = 0; i < count; i++) {
        -:  830:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  831:            if (response_time > thresholds[i]) {
        -:  832:                violations[i] |= 1;
        -:  833:            }
        -:  834:        }
        -:  835:    #endif
    #####:  836:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  789:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  790:                                  const double* thresholds, uint64_t* violations) {
        -:  791:    // SIMD implementation for x86_64
        -:  792:    #ifdef MERCURY_X86_64
        -:  793:        // Process 4 metrics at a time using AVX
    #####:  794:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  795:        
    #####:  796:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  797:            // Load thresholds
    #####:  798:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  799:            
        -:  800:            // Compare with metrics (example for one field)
        -:  801:            // This would be expanded for all threshold types
    #####:  802:            __m256d response_times = _mm256_set_pd(
    #####:  803:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  804:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  805:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  806:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  807:            );
        -:  808:            
        -:  809:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  810:            int mask = _mm256_movemask_pd(comparison);
        -:  811:            
        -:  812:            // Set violation flags based on comparison
    #####:  813:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  814:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  815:                    violations[i + j] |= 1;  // Response time violation
        -:  816:                }
        -:  817:            }
        -:  818:        }
        -:  819:        
        -:  820:        // Handle remaining metrics
    #####:  821:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  822:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  823:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  824:                violations[i] |= 1;
        -:  825:            }
        -:  826:        }
        -:  827:    #else
        -:  828:        // Fallback to scalar implementation
        -:  829:        for (size_t i = 0; i < count; i++) {
        -:  830:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  831:            if (response_time > thresholds[i]) {
        -:  832:                violations[i] |= 1;
        -:  833:            }
        -:  834:        }
        -:  835:    #endif
    #####:  836:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  789:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  790:                                  const double* thresholds, uint64_t* violations) {
        -:  791:    // SIMD implementation for x86_64
        -:  792:    #ifdef MERCURY_X86_64
        -:  793:        // Process 4 metrics at a time using AVX
    #####:  794:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  795:        
    #####:  796:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  797:            // Load thresholds
    #####:  798:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  799:            
        -:  800:            // Compare with metrics (example for one field)
        -:  801:            // This would be expanded for all threshold types
    #####:  802:            __m256d response_times = _mm256_set_pd(
    #####:  803:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  804:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  805:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  806:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  807:            );
        -:  808:            
        -:  809:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  810:            int mask = _mm256_movemask_pd(comparison);
        -:  811:            
        -:  812:            // Set violation flags based on comparison
    #####:  813:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  814:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  815:                    violations[i + j] |= 1;  // Response time violation
        -:  816:                }
        -:  817:            }
        -:  818:        }
        -:  819:        
        -:  820:        // Handle remaining metrics
    #####:  821:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  822:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  823:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  824:                violations[i] |= 1;
        -:  825:            }
        -:  826:        }
        -:  827:    #else
        -:  828:        // Fallback to scalar implementation
        -:  829:        for (size_t i = 0; i < count; i++) {
        -:  830:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  831:            if (response_time > thresholds[i]) {
        -:  832:                violations[i] |= 1;
        -:  833:            }
        -:  834:        }
        -:  835:    #endif
    #####:  836:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  789:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  790:                                  const double* thresholds, uint64_t* violations) {
        -:  791:    // SIMD implementation for x86_64
        -:  792:    #ifdef MERCURY_X86_64
        -:  793:        // Process 4 metrics at a time using AVX
    #####:  794:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  795:        
    #####:  796:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  797:            // Load thresholds
    #####:  798:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  799:            
        -:  800:            // Compare with metrics (example for one field)
        -:  801:            // This would be expanded for all threshold types
    #####:  802:            __m256d response_times = _mm256_set_pd(
    #####:  803:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  804:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  805:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  806:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  807:            );
        -:  808:            
        -:  809:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  810:            int mask = _mm256_movemask_pd(comparison);
        -:  811:            
        -:  812:            // Set violation flags based on comparison
    #####:  813:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  814:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  815:                    violations[i + j] |= 1;  // Response time violation
        -:  816:                }
        -:  817:            }
        -:  818:        }
        -:  819:        
        -:  820:        // Handle remaining metrics
    #####:  821:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  822:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  823:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  824:                violations[i] |= 1;
        -:  825:            }
        -:  826:        }
        -:  827:    #else
        -:  828:        // Fallback to scalar implementation
        -:  829:        for (size_t i = 0; i < count; i++) {
        -:  830:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  831:            if (response_time > thresholds[i]) {
        -:  832:                violations[i] |= 1;
        -:  833:            }
        -:  834:        }
        -:  835:    #endif
    #####:  836:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  789:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  790:                                  const double* thresholds, uint64_t* violations) {
        -:  791:    // SIMD implementation for x86_64
        -:  792:    #ifdef MERCURY_X86_64
        -:  793:        // Process 4 metrics at a time using AVX
    #####:  794:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  795:        
    #####:  796:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  797:            // Load thresholds
    #####:  798:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  799:            
        -:  800:            // Compare with metrics (example for one field)
        -:  801:            // This would be expanded for all threshold types
    #####:  802:            __m256d response_times = _mm256_set_pd(
    #####:  803:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  804:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  805:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  806:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  807:            );
        -:  808:            
        -:  809:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  810:            int mask = _mm256_movemask_pd(comparison);
        -:  811:            
        -:  812:            // Set violation flags based on comparison
    #####:  813:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  814:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  815:                    violations[i + j] |= 1;  // Response time violation
        -:  816:                }
        -:  817:            }
        -:  818:        }
        -:  819:        
        -:  820:        // Handle remaining metrics
    #####:  821:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  822:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  823:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  824:                violations[i] |= 1;
        -:  825:            }
        -:  826:        }
        -:  827:    #else
        -:  828:        // Fallback to scalar implementation
        -:  829:        for (size_t i = 0; i < count; i++) {
        -:  830:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  831:            if (response_time > thresholds[i]) {
        -:  832:                violations[i] |= 1;
        -:  833:            }
        -:  834:        }
        -:  835:    #endif
    #####:  836:}
------------------
mercury_check_thresholds_simd:
function mercury_check_thresholds_simd called 0 returned 0% blocks executed 0%
    #####:  789:void mercury_check_thresholds_simd(const MercuryMetrics* metrics, size_t count,
        -:  790:                                  const double* thresholds, uint64_t* violations) {
        -:  791:    // SIMD implementation for x86_64
        -:  792:    #ifdef MERCURY_X86_64
        -:  793:        // Process 4 metrics at a time using AVX
    #####:  794:        size_t simd_count = count & ~3;  // Round down to multiple of 4
        -:  795:        
    #####:  796:        for (size_t i = 0; i < simd_count; i += 4) {
branch  0 never executed
branch  1 never executed
        -:  797:            // Load thresholds
    #####:  798:            __m256d threshold_vec = _mm256_load_pd(&thresholds[i]);
        -:  799:            
        -:  800:            // Compare with metrics (example for one field)
        -:  801:            // This would be expanded for all threshold types
    #####:  802:            __m256d response_times = _mm256_set_pd(
    #####:  803:                mercury_ns_to_ms(metrics[i+3].end_time.nanoseconds - metrics[i+3].start_time.nanoseconds),
    #####:  804:                mercury_ns_to_ms(metrics[i+2].end_time.nanoseconds - metrics[i+2].start_time.nanoseconds),
    #####:  805:                mercury_ns_to_ms(metrics[i+1].end_time.nanoseconds - metrics[i+1].start_time.nanoseconds),
    #####:  806:                mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds)
        -:  807:            );
        -:  808:            
        -:  809:            __m256d comparison = _mm256_cmp_pd(response_times, threshold_vec, _CMP_GT_OQ);
        -:  810:            int mask = _mm256_movemask_pd(comparison);
        -:  811:            
        -:  812:            // Set violation flags based on comparison
    #####:  813:            for (int j = 0; j < 4; j++) {
branch  0 never executed
branch  1 never executed
    #####:  814:                if (mask & (1 << j)) {
branch  0 never executed
branch  1 never executed
    #####:  815:                    violations[i + j] |= 1;  // Response time violation
        -:  816:                }
        -:  817:            }
        -:  818:        }
        -:  819:        
        -:  820:        // Handle remaining metrics
    #####:  821:        for (size_t i = simd_count; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####:  822:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
branch  0 never executed
branch  1 never executed
    #####:  823:            if (response_time > thresholds[i]) {
branch  0 never executed
branch  1 never executed
    #####:  824:                violations[i] |= 1;
        -:  825:            }
        -:  826:        }
        -:  827:    #else
        -:  828:        // Fallback to scalar implementation
        -:  829:        for (size_t i = 0; i < count; i++) {
        -:  830:            double response_time = mercury_ns_to_ms(metrics[i].end_time.nanoseconds - metrics[i].start_time.nanoseconds);
        -:  831:            if (response_time > thresholds[i]) {
        -:  832:                violations[i] |= 1;
        -:  833:            }
        -:  834:        }
        -:  835:    #endif
    #####:  836:}
------------------
        -:  837:#endif
        -:  838:
        -:  839:// === ERROR HANDLING ===
        -:  840:
      12*:  841:const MercuryErrorContext* mercury_get_last_error(void) {
      12*:  842:    return &mercury_last_error;
        -:  843:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  841:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  842:    return &mercury_last_error;
        -:  843:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 7 returned 100% blocks executed 100%
        7:  841:const MercuryErrorContext* mercury_get_last_error(void) {
        7:  842:    return &mercury_last_error;
        -:  843:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  841:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  842:    return &mercury_last_error;
        -:  843:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 5 returned 100% blocks executed 100%
        5:  841:const MercuryErrorContext* mercury_get_last_error(void) {
        5:  842:    return &mercury_last_error;
        -:  843:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  841:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  842:    return &mercury_last_error;
        -:  843:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  841:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  842:    return &mercury_last_error;
        -:  843:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  841:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  842:    return &mercury_last_error;
        -:  843:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  841:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  842:    return &mercury_last_error;
        -:  843:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  841:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  842:    return &mercury_last_error;
        -:  843:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  841:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  842:    return &mercury_last_error;
        -:  843:}
------------------
mercury_get_last_error:
function mercury_get_last_error called 0 returned 0% blocks executed 0%
    #####:  841:const MercuryErrorContext* mercury_get_last_error(void) {
    #####:  842:    return &mercury_last_error;
        -:  843:}
------------------
        -:  844:
       9*:  845:void mercury_clear_error(void) {
       9*:  846:    mercury_last_error.code = MERCURY_SUCCESS;
       9*:  847:    mercury_last_error.message[0] = '\0';
       9*:  848:    mercury_last_error.function = NULL;
       9*:  849:    mercury_last_error.file = NULL;
       9*:  850:    mercury_last_error.line = 0;
       9*:  851:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  845:void mercury_clear_error(void) {
    #####:  846:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  847:    mercury_last_error.message[0] = '\0';
    #####:  848:    mercury_last_error.function = NULL;
    #####:  849:    mercury_last_error.file = NULL;
    #####:  850:    mercury_last_error.line = 0;
    #####:  851:}
------------------
mercury_clear_error:
function mercury_clear_error called 7 returned 100% blocks executed 100%
        7:  845:void mercury_clear_error(void) {
        7:  846:    mercury_last_error.code = MERCURY_SUCCESS;
        7:  847:    mercury_last_error.message[0] = '\0';
        7:  848:    mercury_last_error.function = NULL;
        7:  849:    mercury_last_error.file = NULL;
        7:  850:    mercury_last_error.line = 0;
        7:  851:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  845:void mercury_clear_error(void) {
    #####:  846:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  847:    mercury_last_error.message[0] = '\0';
    #####:  848:    mercury_last_error.function = NULL;
    #####:  849:    mercury_last_error.file = NULL;
    #####:  850:    mercury_last_error.line = 0;
    #####:  851:}
------------------
mercury_clear_error:
function mercury_clear_error called 2 returned 100% blocks executed 100%
        2:  845:void mercury_clear_error(void) {
        2:  846:    mercury_last_error.code = MERCURY_SUCCESS;
        2:  847:    mercury_last_error.message[0] = '\0';
        2:  848:    mercury_last_error.function = NULL;
        2:  849:    mercury_last_error.file = NULL;
        2:  850:    mercury_last_error.line = 0;
        2:  851:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  845:void mercury_clear_error(void) {
    #####:  846:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  847:    mercury_last_error.message[0] = '\0';
    #####:  848:    mercury_last_error.function = NULL;
    #####:  849:    mercury_last_error.file = NULL;
    #####:  850:    mercury_last_error.line = 0;
    #####:  851:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  845:void mercury_clear_error(void) {
    #####:  846:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  847:    mercury_last_error.message[0] = '\0';
    #####:  848:    mercury_last_error.function = NULL;
    #####:  849:    mercury_last_error.file = NULL;
    #####:  850:    mercury_last_error.line = 0;
    #####:  851:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  845:void mercury_clear_error(void) {
    #####:  846:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  847:    mercury_last_error.message[0] = '\0';
    #####:  848:    mercury_last_error.function = NULL;
    #####:  849:    mercury_last_error.file = NULL;
    #####:  850:    mercury_last_error.line = 0;
    #####:  851:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  845:void mercury_clear_error(void) {
    #####:  846:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  847:    mercury_last_error.message[0] = '\0';
    #####:  848:    mercury_last_error.function = NULL;
    #####:  849:    mercury_last_error.file = NULL;
    #####:  850:    mercury_last_error.line = 0;
    #####:  851:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  845:void mercury_clear_error(void) {
    #####:  846:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  847:    mercury_last_error.message[0] = '\0';
    #####:  848:    mercury_last_error.function = NULL;
    #####:  849:    mercury_last_error.file = NULL;
    #####:  850:    mercury_last_error.line = 0;
    #####:  851:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  845:void mercury_clear_error(void) {
    #####:  846:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  847:    mercury_last_error.message[0] = '\0';
    #####:  848:    mercury_last_error.function = NULL;
    #####:  849:    mercury_last_error.file = NULL;
    #####:  850:    mercury_last_error.line = 0;
    #####:  851:}
------------------
mercury_clear_error:
function mercury_clear_error called 0 returned 0% blocks executed 0%
    #####:  845:void mercury_clear_error(void) {
    #####:  846:    mercury_last_error.code = MERCURY_SUCCESS;
    #####:  847:    mercury_last_error.message[0] = '\0';
    #####:  848:    mercury_last_error.function = NULL;
    #####:  849:    mercury_last_error.file = NULL;
    #####:  850:    mercury_last_error.line = 0;
    #####:  851:}
------------------
        -:  852:
        -:  853:// === LOGGING ===
        -:  854:
     114*:  855:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
     114*:  856:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  857:    
     114*:  858:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
        -:  859:    
     114*:  860:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
        -:  861:    
        -:  862:    va_list args;
     114*:  863:    va_start(args, format);
        -:  864:    vfprintf(output, format, args);
     114*:  865:    va_end(args);
        -:  866:    
        -:  867:    fprintf(output, "\n");
     114*:  868:    fflush(output);
     114*:  869:}
------------------
mercury_default_logger:
function mercury_default_logger called 0 returned 0% blocks executed 0%
    #####:  855:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
    #####:  856:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  857:    
    #####:  858:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 never executed
branch  1 never executed
        -:  859:    
    #####:  860:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 never executed
        -:  861:    
        -:  862:    va_list args;
    #####:  863:    va_start(args, format);
call    0 never executed
        -:  864:    vfprintf(output, format, args);
    #####:  865:    va_end(args);
call    0 never executed
        -:  866:    
        -:  867:    fprintf(output, "\n");
    #####:  868:    fflush(output);
call    0 never executed
    #####:  869:}
------------------
mercury_default_logger:
function mercury_default_logger called 13 returned 100% blocks executed 100%
       13:  855:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
       13:  856:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  857:    
       13:  858:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
        -:  859:    
       13:  860:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 returned 100%
        -:  861:    
        -:  862:    va_list args;
       13:  863:    va_start(args, format);
call    0 returned 100%
        -:  864:    vfprintf(output, format, args);
       13:  865:    va_end(args);
call    0 returned 100%
        -:  866:    
        -:  867:    fprintf(output, "\n");
       13:  868:    fflush(output);
call    0 returned 100%
       13:  869:}
------------------
mercury_default_logger:
function mercury_default_logger called 22 returned 100% blocks executed 88%
       22:  855:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
       22:  856:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  857:    
      22*:  858:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  859:    
       22:  860:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 returned 100%
        -:  861:    
        -:  862:    va_list args;
       22:  863:    va_start(args, format);
call    0 returned 100%
        -:  864:    vfprintf(output, format, args);
       22:  865:    va_end(args);
call    0 returned 100%
        -:  866:    
        -:  867:    fprintf(output, "\n");
       22:  868:    fflush(output);
call    0 returned 100%
       22:  869:}
------------------
mercury_default_logger:
function mercury_default_logger called 0 returned 0% blocks executed 0%
    #####:  855:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
    #####:  856:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  857:    
    #####:  858:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 never executed
branch  1 never executed
        -:  859:    
    #####:  860:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 never executed
        -:  861:    
        -:  862:    va_list args;
    #####:  863:    va_start(args, format);
call    0 never executed
        -:  864:    vfprintf(output, format, args);
    #####:  865:    va_end(args);
call    0 never executed
        -:  866:    
        -:  867:    fprintf(output, "\n");
    #####:  868:    fflush(output);
call    0 never executed
    #####:  869:}
------------------
mercury_default_logger:
function mercury_default_logger called 0 returned 0% blocks executed 0%
    #####:  855:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
    #####:  856:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  857:    
    #####:  858:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 never executed
branch  1 never executed
        -:  859:    
    #####:  860:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 never executed
        -:  861:    
        -:  862:    va_list args;
    #####:  863:    va_start(args, format);
call    0 never executed
        -:  864:    vfprintf(output, format, args);
    #####:  865:    va_end(args);
call    0 never executed
        -:  866:    
        -:  867:    fprintf(output, "\n");
    #####:  868:    fflush(output);
call    0 never executed
    #####:  869:}
------------------
mercury_default_logger:
function mercury_default_logger called 3 returned 100% blocks executed 88%
        3:  855:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
        3:  856:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  857:    
       3*:  858:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  859:    
        3:  860:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 returned 100%
        -:  861:    
        -:  862:    va_list args;
        3:  863:    va_start(args, format);
call    0 returned 100%
        -:  864:    vfprintf(output, format, args);
        3:  865:    va_end(args);
call    0 returned 100%
        -:  866:    
        -:  867:    fprintf(output, "\n");
        3:  868:    fflush(output);
call    0 returned 100%
        3:  869:}
------------------
mercury_default_logger:
function mercury_default_logger called 0 returned 0% blocks executed 0%
    #####:  855:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
    #####:  856:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  857:    
    #####:  858:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 never executed
branch  1 never executed
        -:  859:    
    #####:  860:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 never executed
        -:  861:    
        -:  862:    va_list args;
    #####:  863:    va_start(args, format);
call    0 never executed
        -:  864:    vfprintf(output, format, args);
    #####:  865:    va_end(args);
call    0 never executed
        -:  866:    
        -:  867:    fprintf(output, "\n");
    #####:  868:    fflush(output);
call    0 never executed
    #####:  869:}
------------------
mercury_default_logger:
function mercury_default_logger called 2 returned 100% blocks executed 88%
        2:  855:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
        2:  856:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  857:    
       2*:  858:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  859:    
        2:  860:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 returned 100%
        -:  861:    
        -:  862:    va_list args;
        2:  863:    va_start(args, format);
call    0 returned 100%
        -:  864:    vfprintf(output, format, args);
        2:  865:    va_end(args);
call    0 returned 100%
        -:  866:    
        -:  867:    fprintf(output, "\n");
        2:  868:    fflush(output);
call    0 returned 100%
        2:  869:}
------------------
mercury_default_logger:
function mercury_default_logger called 16 returned 100% blocks executed 100%
       16:  855:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
       16:  856:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  857:    
       16:  858:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 taken 69% (fallthrough)
branch  1 taken 31%
        -:  859:    
       16:  860:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 returned 100%
        -:  861:    
        -:  862:    va_list args;
       16:  863:    va_start(args, format);
call    0 returned 100%
        -:  864:    vfprintf(output, format, args);
       16:  865:    va_end(args);
call    0 returned 100%
        -:  866:    
        -:  867:    fprintf(output, "\n");
       16:  868:    fflush(output);
call    0 returned 100%
       16:  869:}
------------------
mercury_default_logger:
function mercury_default_logger called 25 returned 100% blocks executed 100%
       25:  855:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
       25:  856:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  857:    
       25:  858:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
        -:  859:    
       25:  860:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 returned 100%
        -:  861:    
        -:  862:    va_list args;
       25:  863:    va_start(args, format);
call    0 returned 100%
        -:  864:    vfprintf(output, format, args);
       25:  865:    va_end(args);
call    0 returned 100%
        -:  866:    
        -:  867:    fprintf(output, "\n");
       25:  868:    fflush(output);
call    0 returned 100%
       25:  869:}
------------------
mercury_default_logger:
function mercury_default_logger called 33 returned 100% blocks executed 100%
       33:  855:void mercury_default_logger(MercuryLogLevel level, const char* format, ...) {
       33:  856:    const char* level_strings[] = {"DEBUG", "INFO", "WARN", "ERROR"};
        -:  857:    
       33:  858:    FILE* output = (level >= MERCURY_LOG_WARN) ? stderr : stdout;
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:  859:    
       33:  860:    fprintf(output, "[MERCURY %s] ", level_strings[level]);
call    0 returned 100%
        -:  861:    
        -:  862:    va_list args;
       33:  863:    va_start(args, format);
call    0 returned 100%
        -:  864:    vfprintf(output, format, args);
       33:  865:    va_end(args);
call    0 returned 100%
        -:  866:    
        -:  867:    fprintf(output, "\n");
       33:  868:    fflush(output);
call    0 returned 100%
       33:  869:}
------------------
        -:  870:
        -:  871:// === INITIALIZATION ===
        -:  872:
        -:  873:/**
        -:  874: * @brief Initialize Mercury Performance Testing Framework
        -:  875: * 
        -:  876: * @details Performs one-time initialization including RDTSC calibration
        -:  877: * and error state clearing.
        -:  878: * 
        -:  879: * @return MERCURY_SUCCESS on successful initialization
        -:  880: * 
        -:  881: * @warning Not thread-safe - call only once at program startup
        -:  882: * @note Logs initialization status
        -:  883: */
       3*:  884:MercuryError mercury_init(void) {
       3*:  885:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
        -:  886:    
        -:  887:    // Initialize RDTSC calibration
        -:  888:    #ifdef MERCURY_X86_64
       3*:  889:    mercury_calibrate_rdtsc();
        -:  890:    #endif
        -:  891:    
        -:  892:    // Clear error state
       3*:  893:    mercury_clear_error();
        -:  894:    
       3*:  895:    MERCURY_INFO("Mercury initialization complete");
       3*:  896:    return MERCURY_SUCCESS;
        -:  897:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  884:MercuryError mercury_init(void) {
    #####:  885:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  886:    
        -:  887:    // Initialize RDTSC calibration
        -:  888:    #ifdef MERCURY_X86_64
    #####:  889:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  890:    #endif
        -:  891:    
        -:  892:    // Clear error state
    #####:  893:    mercury_clear_error();
call    0 never executed
        -:  894:    
    #####:  895:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  896:    return MERCURY_SUCCESS;
        -:  897:}
------------------
mercury_init:
function mercury_init called 3 returned 100% blocks executed 100%
        3:  884:MercuryError mercury_init(void) {
        3:  885:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  886:    
        -:  887:    // Initialize RDTSC calibration
        -:  888:    #ifdef MERCURY_X86_64
        3:  889:    mercury_calibrate_rdtsc();
call    0 returned 100%
        -:  890:    #endif
        -:  891:    
        -:  892:    // Clear error state
        3:  893:    mercury_clear_error();
call    0 returned 100%
        -:  894:    
        3:  895:    MERCURY_INFO("Mercury initialization complete");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        3:  896:    return MERCURY_SUCCESS;
        -:  897:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  884:MercuryError mercury_init(void) {
    #####:  885:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  886:    
        -:  887:    // Initialize RDTSC calibration
        -:  888:    #ifdef MERCURY_X86_64
    #####:  889:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  890:    #endif
        -:  891:    
        -:  892:    // Clear error state
    #####:  893:    mercury_clear_error();
call    0 never executed
        -:  894:    
    #####:  895:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  896:    return MERCURY_SUCCESS;
        -:  897:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  884:MercuryError mercury_init(void) {
    #####:  885:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  886:    
        -:  887:    // Initialize RDTSC calibration
        -:  888:    #ifdef MERCURY_X86_64
    #####:  889:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  890:    #endif
        -:  891:    
        -:  892:    // Clear error state
    #####:  893:    mercury_clear_error();
call    0 never executed
        -:  894:    
    #####:  895:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  896:    return MERCURY_SUCCESS;
        -:  897:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  884:MercuryError mercury_init(void) {
    #####:  885:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  886:    
        -:  887:    // Initialize RDTSC calibration
        -:  888:    #ifdef MERCURY_X86_64
    #####:  889:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  890:    #endif
        -:  891:    
        -:  892:    // Clear error state
    #####:  893:    mercury_clear_error();
call    0 never executed
        -:  894:    
    #####:  895:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  896:    return MERCURY_SUCCESS;
        -:  897:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  884:MercuryError mercury_init(void) {
    #####:  885:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  886:    
        -:  887:    // Initialize RDTSC calibration
        -:  888:    #ifdef MERCURY_X86_64
    #####:  889:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  890:    #endif
        -:  891:    
        -:  892:    // Clear error state
    #####:  893:    mercury_clear_error();
call    0 never executed
        -:  894:    
    #####:  895:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  896:    return MERCURY_SUCCESS;
        -:  897:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  884:MercuryError mercury_init(void) {
    #####:  885:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  886:    
        -:  887:    // Initialize RDTSC calibration
        -:  888:    #ifdef MERCURY_X86_64
    #####:  889:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  890:    #endif
        -:  891:    
        -:  892:    // Clear error state
    #####:  893:    mercury_clear_error();
call    0 never executed
        -:  894:    
    #####:  895:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  896:    return MERCURY_SUCCESS;
        -:  897:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  884:MercuryError mercury_init(void) {
    #####:  885:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  886:    
        -:  887:    // Initialize RDTSC calibration
        -:  888:    #ifdef MERCURY_X86_64
    #####:  889:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  890:    #endif
        -:  891:    
        -:  892:    // Clear error state
    #####:  893:    mercury_clear_error();
call    0 never executed
        -:  894:    
    #####:  895:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  896:    return MERCURY_SUCCESS;
        -:  897:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  884:MercuryError mercury_init(void) {
    #####:  885:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  886:    
        -:  887:    // Initialize RDTSC calibration
        -:  888:    #ifdef MERCURY_X86_64
    #####:  889:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  890:    #endif
        -:  891:    
        -:  892:    // Clear error state
    #####:  893:    mercury_clear_error();
call    0 never executed
        -:  894:    
    #####:  895:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  896:    return MERCURY_SUCCESS;
        -:  897:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  884:MercuryError mercury_init(void) {
    #####:  885:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  886:    
        -:  887:    // Initialize RDTSC calibration
        -:  888:    #ifdef MERCURY_X86_64
    #####:  889:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  890:    #endif
        -:  891:    
        -:  892:    // Clear error state
    #####:  893:    mercury_clear_error();
call    0 never executed
        -:  894:    
    #####:  895:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  896:    return MERCURY_SUCCESS;
        -:  897:}
------------------
mercury_init:
function mercury_init called 0 returned 0% blocks executed 0%
    #####:  884:MercuryError mercury_init(void) {
    #####:  885:    MERCURY_INFO("Initializing Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  886:    
        -:  887:    // Initialize RDTSC calibration
        -:  888:    #ifdef MERCURY_X86_64
    #####:  889:    mercury_calibrate_rdtsc();
call    0 never executed
        -:  890:    #endif
        -:  891:    
        -:  892:    // Clear error state
    #####:  893:    mercury_clear_error();
call    0 never executed
        -:  894:    
    #####:  895:    MERCURY_INFO("Mercury initialization complete");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  896:    return MERCURY_SUCCESS;
        -:  897:}
------------------
        -:  898:
        -:  899:/**
        -:  900: * @brief Clean up Mercury Performance Testing Framework
        -:  901: * 
        -:  902: * @details Performs cleanup of global resources and clears error state.
        -:  903: * 
        -:  904: * @warning Should be called once at program termination
        -:  905: * @note Safe to call multiple times
        -:  906: */
       2*:  907:void mercury_cleanup(void) {
       2*:  908:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
       2*:  909:    mercury_clear_error();
       2*:  910:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  907:void mercury_cleanup(void) {
    #####:  908:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  909:    mercury_clear_error();
call    0 never executed
    #####:  910:}
------------------
mercury_cleanup:
function mercury_cleanup called 2 returned 100% blocks executed 100%
        2:  907:void mercury_cleanup(void) {
        2:  908:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        2:  909:    mercury_clear_error();
call    0 returned 100%
        2:  910:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  907:void mercury_cleanup(void) {
    #####:  908:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  909:    mercury_clear_error();
call    0 never executed
    #####:  910:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  907:void mercury_cleanup(void) {
    #####:  908:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  909:    mercury_clear_error();
call    0 never executed
    #####:  910:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  907:void mercury_cleanup(void) {
    #####:  908:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  909:    mercury_clear_error();
call    0 never executed
    #####:  910:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  907:void mercury_cleanup(void) {
    #####:  908:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  909:    mercury_clear_error();
call    0 never executed
    #####:  910:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  907:void mercury_cleanup(void) {
    #####:  908:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  909:    mercury_clear_error();
call    0 never executed
    #####:  910:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  907:void mercury_cleanup(void) {
    #####:  908:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  909:    mercury_clear_error();
call    0 never executed
    #####:  910:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  907:void mercury_cleanup(void) {
    #####:  908:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  909:    mercury_clear_error();
call    0 never executed
    #####:  910:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  907:void mercury_cleanup(void) {
    #####:  908:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  909:    mercury_clear_error();
call    0 never executed
    #####:  910:}
------------------
mercury_cleanup:
function mercury_cleanup called 0 returned 0% blocks executed 0%
    #####:  907:void mercury_cleanup(void) {
    #####:  908:    MERCURY_INFO("Cleaning up Mercury Performance Testing Framework");
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  909:    mercury_clear_error();
call    0 never executed
    #####:  910:}
------------------
        -:  911:
        -:  912:// === MEMORY POOL IMPLEMENTATION ===
        -:  913:
        -:  914:// Memory pool types now in common.h
        -:  915:
        -:  916:/**
        -:  917: * @brief Initialize a memory pool for fast allocation
        -:  918: * 
        -:  919: * @details Creates a lock-free memory pool with pre-allocated blocks
        -:  920: * for O(1) allocation and deallocation.
        -:  921: * 
        -:  922: * @param pool Pool structure to initialize
        -:  923: * @param block_size Size of each block in bytes
        -:  924: * @param num_blocks Number of blocks to pre-allocate
        -:  925: * 
        -:  926: * @pre pool must be non-NULL
        -:  927: * @post Pool is ready for allocation requests
        -:  928: * 
        -:  929: * @warning Not thread-safe during initialization
        -:  930: * @note Blocks are cache-line aligned for performance
        -:  931: */
       8*:  932:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
       8*:  933:    if (MERCURY_UNLIKELY(!pool)) return;
        -:  934:    
       8*:  935:    pool->block_size = block_size;
       8*:  936:    pool->num_blocks = num_blocks;
        -:  937:    
        -:  938:    // Initialize atomic variables
       8*:  939:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
       8*:  940:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  941:    
        -:  942:    // Pre-allocate all blocks in a contiguous array for better cache locality
       8*:  943:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
       8*:  944:    if (!pool->all_blocks) {
    #####:  945:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  946:        return;
        -:  947:    }
        -:  948:    
        -:  949:    // Initialize all blocks and build the lock-free stack
        -:  950:    memory_block_t* stack_head = NULL;
    5145*:  951:    for (size_t i = 0; i < num_blocks; i++) {
    5137*:  952:        memory_block_t* block = &pool->all_blocks[i];
        -:  953:        
    5137*:  954:        block->size = block_size;
    5137*:  955:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
    5137*:  956:        if (!block->data) {
        -:  957:            // Skip this block on allocation failure
    #####:  958:            continue;
        -:  959:        }
        -:  960:        
    5137*:  961:        block->in_use = false;
        -:  962:        // Build stack in reverse order for better locality
    5137*:  963:        block->next = stack_head;
        -:  964:        stack_head = block;
        -:  965:    }
        -:  966:    
        -:  967:    // Set the initial stack head atomically
       8*:  968:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  969:    
        -:  970:    // Count actual allocated blocks
        -:  971:    size_t count = 0;
        -:  972:    memory_block_t* current = stack_head;
    5145*:  973:    while (current) {
    5137*:  974:        count++;
    5137*:  975:        current = current->next;
        -:  976:    }
       8*:  977:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  978:}
------------------
memory_pool_init:
function memory_pool_init called 0 returned 0% blocks executed 0%
    #####:  932:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
    #####:  933:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 never executed
branch  1 never executed
        -:  934:    
    #####:  935:    pool->block_size = block_size;
    #####:  936:    pool->num_blocks = num_blocks;
        -:  937:    
        -:  938:    // Initialize atomic variables
    #####:  939:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  940:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  941:    
        -:  942:    // Pre-allocate all blocks in a contiguous array for better cache locality
    #####:  943:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 never executed
    #####:  944:    if (!pool->all_blocks) {
branch  0 never executed
branch  1 never executed
    #####:  945:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  946:        return;
        -:  947:    }
        -:  948:    
        -:  949:    // Initialize all blocks and build the lock-free stack
        -:  950:    memory_block_t* stack_head = NULL;
    #####:  951:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  952:        memory_block_t* block = &pool->all_blocks[i];
        -:  953:        
    #####:  954:        block->size = block_size;
    #####:  955:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 never executed
    #####:  956:        if (!block->data) {
branch  0 never executed
branch  1 never executed
        -:  957:            // Skip this block on allocation failure
    #####:  958:            continue;
        -:  959:        }
        -:  960:        
    #####:  961:        block->in_use = false;
        -:  962:        // Build stack in reverse order for better locality
    #####:  963:        block->next = stack_head;
        -:  964:        stack_head = block;
        -:  965:    }
        -:  966:    
        -:  967:    // Set the initial stack head atomically
    #####:  968:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  969:    
        -:  970:    // Count actual allocated blocks
        -:  971:    size_t count = 0;
        -:  972:    memory_block_t* current = stack_head;
    #####:  973:    while (current) {
branch  0 never executed
branch  1 never executed
    #####:  974:        count++;
    #####:  975:        current = current->next;
        -:  976:    }
    #####:  977:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  978:}
------------------
memory_pool_init:
function memory_pool_init called 2 returned 100% blocks executed 87%
        2:  932:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
        2:  933:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  934:    
        2:  935:    pool->block_size = block_size;
        2:  936:    pool->num_blocks = num_blocks;
        -:  937:    
        -:  938:    // Initialize atomic variables
        2:  939:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        2:  940:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  941:    
        -:  942:    // Pre-allocate all blocks in a contiguous array for better cache locality
        2:  943:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 returned 100%
        2:  944:    if (!pool->all_blocks) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  945:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  946:        return;
        -:  947:    }
        -:  948:    
        -:  949:    // Initialize all blocks and build the lock-free stack
        -:  950:    memory_block_t* stack_head = NULL;
      118:  951:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
      116:  952:        memory_block_t* block = &pool->all_blocks[i];
        -:  953:        
      116:  954:        block->size = block_size;
      116:  955:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 returned 100%
     116*:  956:        if (!block->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  957:            // Skip this block on allocation failure
    #####:  958:            continue;
        -:  959:        }
        -:  960:        
      116:  961:        block->in_use = false;
        -:  962:        // Build stack in reverse order for better locality
      116:  963:        block->next = stack_head;
        -:  964:        stack_head = block;
        -:  965:    }
        -:  966:    
        -:  967:    // Set the initial stack head atomically
        2:  968:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  969:    
        -:  970:    // Count actual allocated blocks
        -:  971:    size_t count = 0;
        -:  972:    memory_block_t* current = stack_head;
      118:  973:    while (current) {
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
      116:  974:        count++;
      116:  975:        current = current->next;
        -:  976:    }
        2:  977:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  978:}
------------------
memory_pool_init:
function memory_pool_init called 2 returned 100% blocks executed 87%
        2:  932:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
        2:  933:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  934:    
        2:  935:    pool->block_size = block_size;
        2:  936:    pool->num_blocks = num_blocks;
        -:  937:    
        -:  938:    // Initialize atomic variables
        2:  939:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        2:  940:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  941:    
        -:  942:    // Pre-allocate all blocks in a contiguous array for better cache locality
        2:  943:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 returned 100%
        2:  944:    if (!pool->all_blocks) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  945:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  946:        return;
        -:  947:    }
        -:  948:    
        -:  949:    // Initialize all blocks and build the lock-free stack
        -:  950:    memory_block_t* stack_head = NULL;
        8:  951:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        6:  952:        memory_block_t* block = &pool->all_blocks[i];
        -:  953:        
        6:  954:        block->size = block_size;
        6:  955:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 returned 100%
       6*:  956:        if (!block->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  957:            // Skip this block on allocation failure
    #####:  958:            continue;
        -:  959:        }
        -:  960:        
        6:  961:        block->in_use = false;
        -:  962:        // Build stack in reverse order for better locality
        6:  963:        block->next = stack_head;
        -:  964:        stack_head = block;
        -:  965:    }
        -:  966:    
        -:  967:    // Set the initial stack head atomically
        2:  968:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  969:    
        -:  970:    // Count actual allocated blocks
        -:  971:    size_t count = 0;
        -:  972:    memory_block_t* current = stack_head;
        8:  973:    while (current) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        6:  974:        count++;
        6:  975:        current = current->next;
        -:  976:    }
        2:  977:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  978:}
------------------
memory_pool_init:
function memory_pool_init called 2 returned 100% blocks executed 87%
        2:  932:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
        2:  933:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  934:    
        2:  935:    pool->block_size = block_size;
        2:  936:    pool->num_blocks = num_blocks;
        -:  937:    
        -:  938:    // Initialize atomic variables
        2:  939:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        2:  940:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  941:    
        -:  942:    // Pre-allocate all blocks in a contiguous array for better cache locality
        2:  943:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 returned 100%
        2:  944:    if (!pool->all_blocks) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  945:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  946:        return;
        -:  947:    }
        -:  948:    
        -:  949:    // Initialize all blocks and build the lock-free stack
        -:  950:    memory_block_t* stack_head = NULL;
       17:  951:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
       15:  952:        memory_block_t* block = &pool->all_blocks[i];
        -:  953:        
       15:  954:        block->size = block_size;
       15:  955:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 returned 100%
      15*:  956:        if (!block->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  957:            // Skip this block on allocation failure
    #####:  958:            continue;
        -:  959:        }
        -:  960:        
       15:  961:        block->in_use = false;
        -:  962:        // Build stack in reverse order for better locality
       15:  963:        block->next = stack_head;
        -:  964:        stack_head = block;
        -:  965:    }
        -:  966:    
        -:  967:    // Set the initial stack head atomically
        2:  968:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  969:    
        -:  970:    // Count actual allocated blocks
        -:  971:    size_t count = 0;
        -:  972:    memory_block_t* current = stack_head;
       17:  973:    while (current) {
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
       15:  974:        count++;
       15:  975:        current = current->next;
        -:  976:    }
        2:  977:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  978:}
------------------
memory_pool_init:
function memory_pool_init called 0 returned 0% blocks executed 0%
    #####:  932:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
    #####:  933:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 never executed
branch  1 never executed
        -:  934:    
    #####:  935:    pool->block_size = block_size;
    #####:  936:    pool->num_blocks = num_blocks;
        -:  937:    
        -:  938:    // Initialize atomic variables
    #####:  939:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  940:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  941:    
        -:  942:    // Pre-allocate all blocks in a contiguous array for better cache locality
    #####:  943:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 never executed
    #####:  944:    if (!pool->all_blocks) {
branch  0 never executed
branch  1 never executed
    #####:  945:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  946:        return;
        -:  947:    }
        -:  948:    
        -:  949:    // Initialize all blocks and build the lock-free stack
        -:  950:    memory_block_t* stack_head = NULL;
    #####:  951:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  952:        memory_block_t* block = &pool->all_blocks[i];
        -:  953:        
    #####:  954:        block->size = block_size;
    #####:  955:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 never executed
    #####:  956:        if (!block->data) {
branch  0 never executed
branch  1 never executed
        -:  957:            // Skip this block on allocation failure
    #####:  958:            continue;
        -:  959:        }
        -:  960:        
    #####:  961:        block->in_use = false;
        -:  962:        // Build stack in reverse order for better locality
    #####:  963:        block->next = stack_head;
        -:  964:        stack_head = block;
        -:  965:    }
        -:  966:    
        -:  967:    // Set the initial stack head atomically
    #####:  968:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  969:    
        -:  970:    // Count actual allocated blocks
        -:  971:    size_t count = 0;
        -:  972:    memory_block_t* current = stack_head;
    #####:  973:    while (current) {
branch  0 never executed
branch  1 never executed
    #####:  974:        count++;
    #####:  975:        current = current->next;
        -:  976:    }
    #####:  977:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  978:}
------------------
memory_pool_init:
function memory_pool_init called 0 returned 0% blocks executed 0%
    #####:  932:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
    #####:  933:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 never executed
branch  1 never executed
        -:  934:    
    #####:  935:    pool->block_size = block_size;
    #####:  936:    pool->num_blocks = num_blocks;
        -:  937:    
        -:  938:    // Initialize atomic variables
    #####:  939:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  940:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  941:    
        -:  942:    // Pre-allocate all blocks in a contiguous array for better cache locality
    #####:  943:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 never executed
    #####:  944:    if (!pool->all_blocks) {
branch  0 never executed
branch  1 never executed
    #####:  945:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  946:        return;
        -:  947:    }
        -:  948:    
        -:  949:    // Initialize all blocks and build the lock-free stack
        -:  950:    memory_block_t* stack_head = NULL;
    #####:  951:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  952:        memory_block_t* block = &pool->all_blocks[i];
        -:  953:        
    #####:  954:        block->size = block_size;
    #####:  955:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 never executed
    #####:  956:        if (!block->data) {
branch  0 never executed
branch  1 never executed
        -:  957:            // Skip this block on allocation failure
    #####:  958:            continue;
        -:  959:        }
        -:  960:        
    #####:  961:        block->in_use = false;
        -:  962:        // Build stack in reverse order for better locality
    #####:  963:        block->next = stack_head;
        -:  964:        stack_head = block;
        -:  965:    }
        -:  966:    
        -:  967:    // Set the initial stack head atomically
    #####:  968:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  969:    
        -:  970:    // Count actual allocated blocks
        -:  971:    size_t count = 0;
        -:  972:    memory_block_t* current = stack_head;
    #####:  973:    while (current) {
branch  0 never executed
branch  1 never executed
    #####:  974:        count++;
    #####:  975:        current = current->next;
        -:  976:    }
    #####:  977:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  978:}
------------------
memory_pool_init:
function memory_pool_init called 1 returned 100% blocks executed 87%
        1:  932:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
        1:  933:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  934:    
        1:  935:    pool->block_size = block_size;
        1:  936:    pool->num_blocks = num_blocks;
        -:  937:    
        -:  938:    // Initialize atomic variables
        1:  939:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        1:  940:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  941:    
        -:  942:    // Pre-allocate all blocks in a contiguous array for better cache locality
        1:  943:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 returned 100%
        1:  944:    if (!pool->all_blocks) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  945:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  946:        return;
        -:  947:    }
        -:  948:    
        -:  949:    // Initialize all blocks and build the lock-free stack
        -:  950:    memory_block_t* stack_head = NULL;
     2501:  951:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     2500:  952:        memory_block_t* block = &pool->all_blocks[i];
        -:  953:        
     2500:  954:        block->size = block_size;
     2500:  955:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 returned 100%
    2500*:  956:        if (!block->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  957:            // Skip this block on allocation failure
    #####:  958:            continue;
        -:  959:        }
        -:  960:        
     2500:  961:        block->in_use = false;
        -:  962:        // Build stack in reverse order for better locality
     2500:  963:        block->next = stack_head;
        -:  964:        stack_head = block;
        -:  965:    }
        -:  966:    
        -:  967:    // Set the initial stack head atomically
        1:  968:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  969:    
        -:  970:    // Count actual allocated blocks
        -:  971:    size_t count = 0;
        -:  972:    memory_block_t* current = stack_head;
     2501:  973:    while (current) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     2500:  974:        count++;
     2500:  975:        current = current->next;
        -:  976:    }
        1:  977:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  978:}
------------------
memory_pool_init:
function memory_pool_init called 1 returned 100% blocks executed 87%
        1:  932:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
        1:  933:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  934:    
        1:  935:    pool->block_size = block_size;
        1:  936:    pool->num_blocks = num_blocks;
        -:  937:    
        -:  938:    // Initialize atomic variables
        1:  939:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        1:  940:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  941:    
        -:  942:    // Pre-allocate all blocks in a contiguous array for better cache locality
        1:  943:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 returned 100%
        1:  944:    if (!pool->all_blocks) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  945:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  946:        return;
        -:  947:    }
        -:  948:    
        -:  949:    // Initialize all blocks and build the lock-free stack
        -:  950:    memory_block_t* stack_head = NULL;
     2501:  951:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     2500:  952:        memory_block_t* block = &pool->all_blocks[i];
        -:  953:        
     2500:  954:        block->size = block_size;
     2500:  955:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 returned 100%
    2500*:  956:        if (!block->data) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  957:            // Skip this block on allocation failure
    #####:  958:            continue;
        -:  959:        }
        -:  960:        
     2500:  961:        block->in_use = false;
        -:  962:        // Build stack in reverse order for better locality
     2500:  963:        block->next = stack_head;
        -:  964:        stack_head = block;
        -:  965:    }
        -:  966:    
        -:  967:    // Set the initial stack head atomically
        1:  968:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  969:    
        -:  970:    // Count actual allocated blocks
        -:  971:    size_t count = 0;
        -:  972:    memory_block_t* current = stack_head;
     2501:  973:    while (current) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     2500:  974:        count++;
     2500:  975:        current = current->next;
        -:  976:    }
        1:  977:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  978:}
------------------
memory_pool_init:
function memory_pool_init called 0 returned 0% blocks executed 0%
    #####:  932:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
    #####:  933:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 never executed
branch  1 never executed
        -:  934:    
    #####:  935:    pool->block_size = block_size;
    #####:  936:    pool->num_blocks = num_blocks;
        -:  937:    
        -:  938:    // Initialize atomic variables
    #####:  939:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  940:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  941:    
        -:  942:    // Pre-allocate all blocks in a contiguous array for better cache locality
    #####:  943:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 never executed
    #####:  944:    if (!pool->all_blocks) {
branch  0 never executed
branch  1 never executed
    #####:  945:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  946:        return;
        -:  947:    }
        -:  948:    
        -:  949:    // Initialize all blocks and build the lock-free stack
        -:  950:    memory_block_t* stack_head = NULL;
    #####:  951:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  952:        memory_block_t* block = &pool->all_blocks[i];
        -:  953:        
    #####:  954:        block->size = block_size;
    #####:  955:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 never executed
    #####:  956:        if (!block->data) {
branch  0 never executed
branch  1 never executed
        -:  957:            // Skip this block on allocation failure
    #####:  958:            continue;
        -:  959:        }
        -:  960:        
    #####:  961:        block->in_use = false;
        -:  962:        // Build stack in reverse order for better locality
    #####:  963:        block->next = stack_head;
        -:  964:        stack_head = block;
        -:  965:    }
        -:  966:    
        -:  967:    // Set the initial stack head atomically
    #####:  968:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  969:    
        -:  970:    // Count actual allocated blocks
        -:  971:    size_t count = 0;
        -:  972:    memory_block_t* current = stack_head;
    #####:  973:    while (current) {
branch  0 never executed
branch  1 never executed
    #####:  974:        count++;
    #####:  975:        current = current->next;
        -:  976:    }
    #####:  977:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  978:}
------------------
memory_pool_init:
function memory_pool_init called 0 returned 0% blocks executed 0%
    #####:  932:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
    #####:  933:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 never executed
branch  1 never executed
        -:  934:    
    #####:  935:    pool->block_size = block_size;
    #####:  936:    pool->num_blocks = num_blocks;
        -:  937:    
        -:  938:    // Initialize atomic variables
    #####:  939:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  940:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  941:    
        -:  942:    // Pre-allocate all blocks in a contiguous array for better cache locality
    #####:  943:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 never executed
    #####:  944:    if (!pool->all_blocks) {
branch  0 never executed
branch  1 never executed
    #####:  945:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  946:        return;
        -:  947:    }
        -:  948:    
        -:  949:    // Initialize all blocks and build the lock-free stack
        -:  950:    memory_block_t* stack_head = NULL;
    #####:  951:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  952:        memory_block_t* block = &pool->all_blocks[i];
        -:  953:        
    #####:  954:        block->size = block_size;
    #####:  955:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 never executed
    #####:  956:        if (!block->data) {
branch  0 never executed
branch  1 never executed
        -:  957:            // Skip this block on allocation failure
    #####:  958:            continue;
        -:  959:        }
        -:  960:        
    #####:  961:        block->in_use = false;
        -:  962:        // Build stack in reverse order for better locality
    #####:  963:        block->next = stack_head;
        -:  964:        stack_head = block;
        -:  965:    }
        -:  966:    
        -:  967:    // Set the initial stack head atomically
    #####:  968:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  969:    
        -:  970:    // Count actual allocated blocks
        -:  971:    size_t count = 0;
        -:  972:    memory_block_t* current = stack_head;
    #####:  973:    while (current) {
branch  0 never executed
branch  1 never executed
    #####:  974:        count++;
    #####:  975:        current = current->next;
        -:  976:    }
    #####:  977:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  978:}
------------------
memory_pool_init:
function memory_pool_init called 0 returned 0% blocks executed 0%
    #####:  932:void memory_pool_init(memory_pool_t* pool, size_t block_size, size_t num_blocks) {
    #####:  933:    if (MERCURY_UNLIKELY(!pool)) return;
branch  0 never executed
branch  1 never executed
        -:  934:    
    #####:  935:    pool->block_size = block_size;
    #####:  936:    pool->num_blocks = num_blocks;
        -:  937:    
        -:  938:    // Initialize atomic variables
    #####:  939:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####:  940:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -:  941:    
        -:  942:    // Pre-allocate all blocks in a contiguous array for better cache locality
    #####:  943:    pool->all_blocks = mercury_aligned_alloc(sizeof(memory_block_t) * num_blocks, 64);
call    0 never executed
    #####:  944:    if (!pool->all_blocks) {
branch  0 never executed
branch  1 never executed
    #####:  945:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate block array");
    #####:  946:        return;
        -:  947:    }
        -:  948:    
        -:  949:    // Initialize all blocks and build the lock-free stack
        -:  950:    memory_block_t* stack_head = NULL;
    #####:  951:    for (size_t i = 0; i < num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####:  952:        memory_block_t* block = &pool->all_blocks[i];
        -:  953:        
    #####:  954:        block->size = block_size;
    #####:  955:        block->data = mercury_aligned_alloc(block_size, 64);  // 64-byte aligned
call    0 never executed
    #####:  956:        if (!block->data) {
branch  0 never executed
branch  1 never executed
        -:  957:            // Skip this block on allocation failure
    #####:  958:            continue;
        -:  959:        }
        -:  960:        
    #####:  961:        block->in_use = false;
        -:  962:        // Build stack in reverse order for better locality
    #####:  963:        block->next = stack_head;
        -:  964:        stack_head = block;
        -:  965:    }
        -:  966:    
        -:  967:    // Set the initial stack head atomically
    #####:  968:    atomic_store_explicit(&pool->free_stack, stack_head, memory_order_release);
        -:  969:    
        -:  970:    // Count actual allocated blocks
        -:  971:    size_t count = 0;
        -:  972:    memory_block_t* current = stack_head;
    #####:  973:    while (current) {
branch  0 never executed
branch  1 never executed
    #####:  974:        count++;
    #####:  975:        current = current->next;
        -:  976:    }
    #####:  977:    atomic_store_explicit(&pool->free_count, count, memory_order_relaxed);
        -:  978:}
------------------
        -:  979:
        -:  980:/**
        -:  981: * @brief Allocate a block from the memory pool
        -:  982: * 
        -:  983: * @details Uses lock-free atomic operations for thread-safe allocation
        -:  984: * with O(1) performance.
        -:  985: * 
        -:  986: * @param pool Memory pool to allocate from
        -:  987: * @return Pointer to allocated block or NULL if pool exhausted
        -:  988: * 
        -:  989: * @warning Caller must return block with memory_pool_free()
        -:  990: * @note Thread-safe with multiple concurrent allocators
        -:  991: */
    3309*:  992:void* memory_pool_alloc(memory_pool_t* pool) {
    3309*:  993:    if (MERCURY_UNLIKELY(!pool)) return NULL;
        -:  994:    
        -:  995:    // Lock-free atomic stack pop operation
        -:  996:    memory_block_t* head;
        -:  997:    memory_block_t* next;
        -:  998:    
        -:  999:    do {
        -: 1000:        // Load current head with acquire ordering
    3311*: 1001:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1002:        
        -: 1003:        // Check if stack is empty
    3311*: 1004:        if (MERCURY_UNLIKELY(head == NULL)) {
        -: 1005:            return NULL;  // Pool exhausted
        -: 1006:        }
        -: 1007:        
        -: 1008:        // Prefetch the head block for reading its fields
    3309*: 1009:        MERCURY_PREFETCH_READ(head);
        -: 1010:        
        -: 1011:        // Get the next block in the stack  
    3309*: 1012:        next = head->next;
        -: 1013:        
        -: 1014:        // Prefetch the next block in case CAS fails and we need to retry
    3309*: 1015:        if (MERCURY_LIKELY(next != NULL)) {
    3305*: 1016:            MERCURY_PREFETCH_READ_LOW(next);
        -: 1017:        }
        -: 1018:        
        -: 1019:        // Try to update the head atomically (CAS operation)
        -: 1020:        // This will fail if another thread modified the head
    3309*: 1021:    } while (!atomic_compare_exchange_weak_explicit(
        -: 1022:        &pool->free_stack, &head, next,
        -: 1023:        memory_order_acq_rel, memory_order_acquire));
        -: 1024:    
        -: 1025:    // Successfully popped a block from the stack
    3307*: 1026:    head->in_use = true;
    3307*: 1027:    head->next = NULL;  // Clear the next pointer for safety
        -: 1028:    
        -: 1029:    // Prefetch the actual data block for the caller
    3307*: 1030:    MERCURY_PREFETCH_WRITE(head->data);
        -: 1031:    
        -: 1032:    // Update statistics (relaxed ordering for performance)
    3307*: 1033:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1034:    
    3307*: 1035:    return head->data;
        -: 1036:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 0 returned 0% blocks executed 0%
    #####:  992:void* memory_pool_alloc(memory_pool_t* pool) {
    #####:  993:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 never executed
branch  1 never executed
        -:  994:    
        -:  995:    // Lock-free atomic stack pop operation
        -:  996:    memory_block_t* head;
        -:  997:    memory_block_t* next;
        -:  998:    
        -:  999:    do {
        -: 1000:        // Load current head with acquire ordering
    #####: 1001:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1002:        
        -: 1003:        // Check if stack is empty
    #####: 1004:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 never executed
branch  1 never executed
        -: 1005:            return NULL;  // Pool exhausted
        -: 1006:        }
        -: 1007:        
        -: 1008:        // Prefetch the head block for reading its fields
    #####: 1009:        MERCURY_PREFETCH_READ(head);
call    0 never executed
        -: 1010:        
        -: 1011:        // Get the next block in the stack  
    #####: 1012:        next = head->next;
        -: 1013:        
        -: 1014:        // Prefetch the next block in case CAS fails and we need to retry
    #####: 1015:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 never executed
branch  1 never executed
    #####: 1016:            MERCURY_PREFETCH_READ_LOW(next);
call    0 never executed
        -: 1017:        }
        -: 1018:        
        -: 1019:        // Try to update the head atomically (CAS operation)
        -: 1020:        // This will fail if another thread modified the head
    #####: 1021:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1022:        &pool->free_stack, &head, next,
        -: 1023:        memory_order_acq_rel, memory_order_acquire));
        -: 1024:    
        -: 1025:    // Successfully popped a block from the stack
    #####: 1026:    head->in_use = true;
    #####: 1027:    head->next = NULL;  // Clear the next pointer for safety
        -: 1028:    
        -: 1029:    // Prefetch the actual data block for the caller
    #####: 1030:    MERCURY_PREFETCH_WRITE(head->data);
call    0 never executed
        -: 1031:    
        -: 1032:    // Update statistics (relaxed ordering for performance)
    #####: 1033:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1034:    
    #####: 1035:    return head->data;
        -: 1036:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 13 returned 100% blocks executed 100%
       13:  992:void* memory_pool_alloc(memory_pool_t* pool) {
       13:  993:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  994:    
        -:  995:    // Lock-free atomic stack pop operation
        -:  996:    memory_block_t* head;
        -:  997:    memory_block_t* next;
        -:  998:    
        -:  999:    do {
        -: 1000:        // Load current head with acquire ordering
       13: 1001:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1002:        
        -: 1003:        // Check if stack is empty
       13: 1004:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1005:            return NULL;  // Pool exhausted
        -: 1006:        }
        -: 1007:        
        -: 1008:        // Prefetch the head block for reading its fields
       13: 1009:        MERCURY_PREFETCH_READ(head);
call    0 returned 100%
        -: 1010:        
        -: 1011:        // Get the next block in the stack  
       13: 1012:        next = head->next;
        -: 1013:        
        -: 1014:        // Prefetch the next block in case CAS fails and we need to retry
       13: 1015:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       13: 1016:            MERCURY_PREFETCH_READ_LOW(next);
call    0 returned 100%
        -: 1017:        }
        -: 1018:        
        -: 1019:        // Try to update the head atomically (CAS operation)
        -: 1020:        // This will fail if another thread modified the head
       13: 1021:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -: 1022:        &pool->free_stack, &head, next,
        -: 1023:        memory_order_acq_rel, memory_order_acquire));
        -: 1024:    
        -: 1025:    // Successfully popped a block from the stack
       13: 1026:    head->in_use = true;
       13: 1027:    head->next = NULL;  // Clear the next pointer for safety
        -: 1028:    
        -: 1029:    // Prefetch the actual data block for the caller
       13: 1030:    MERCURY_PREFETCH_WRITE(head->data);
call    0 returned 100%
        -: 1031:    
        -: 1032:    // Update statistics (relaxed ordering for performance)
       13: 1033:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1034:    
       13: 1035:    return head->data;
        -: 1036:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 5 returned 100% blocks executed 100%
        5:  992:void* memory_pool_alloc(memory_pool_t* pool) {
        5:  993:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  994:    
        -:  995:    // Lock-free atomic stack pop operation
        -:  996:    memory_block_t* head;
        -:  997:    memory_block_t* next;
        -:  998:    
        -:  999:    do {
        -: 1000:        // Load current head with acquire ordering
        5: 1001:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1002:        
        -: 1003:        // Check if stack is empty
        5: 1004:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1005:            return NULL;  // Pool exhausted
        -: 1006:        }
        -: 1007:        
        -: 1008:        // Prefetch the head block for reading its fields
        4: 1009:        MERCURY_PREFETCH_READ(head);
call    0 returned 100%
        -: 1010:        
        -: 1011:        // Get the next block in the stack  
        4: 1012:        next = head->next;
        -: 1013:        
        -: 1014:        // Prefetch the next block in case CAS fails and we need to retry
        4: 1015:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        2: 1016:            MERCURY_PREFETCH_READ_LOW(next);
call    0 returned 100%
        -: 1017:        }
        -: 1018:        
        -: 1019:        // Try to update the head atomically (CAS operation)
        -: 1020:        // This will fail if another thread modified the head
        4: 1021:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -: 1022:        &pool->free_stack, &head, next,
        -: 1023:        memory_order_acq_rel, memory_order_acquire));
        -: 1024:    
        -: 1025:    // Successfully popped a block from the stack
        4: 1026:    head->in_use = true;
        4: 1027:    head->next = NULL;  // Clear the next pointer for safety
        -: 1028:    
        -: 1029:    // Prefetch the actual data block for the caller
        4: 1030:    MERCURY_PREFETCH_WRITE(head->data);
call    0 returned 100%
        -: 1031:    
        -: 1032:    // Update statistics (relaxed ordering for performance)
        4: 1033:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1034:    
        4: 1035:    return head->data;
        -: 1036:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 13 returned 100% blocks executed 100%
       13:  992:void* memory_pool_alloc(memory_pool_t* pool) {
       13:  993:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  994:    
        -:  995:    // Lock-free atomic stack pop operation
        -:  996:    memory_block_t* head;
        -:  997:    memory_block_t* next;
        -:  998:    
        -:  999:    do {
        -: 1000:        // Load current head with acquire ordering
       13: 1001:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1002:        
        -: 1003:        // Check if stack is empty
       13: 1004:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
        -: 1005:            return NULL;  // Pool exhausted
        -: 1006:        }
        -: 1007:        
        -: 1008:        // Prefetch the head block for reading its fields
       12: 1009:        MERCURY_PREFETCH_READ(head);
call    0 returned 100%
        -: 1010:        
        -: 1011:        // Get the next block in the stack  
       12: 1012:        next = head->next;
        -: 1013:        
        -: 1014:        // Prefetch the next block in case CAS fails and we need to retry
       12: 1015:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 taken 83% (fallthrough)
branch  1 taken 17%
       10: 1016:            MERCURY_PREFETCH_READ_LOW(next);
call    0 returned 100%
        -: 1017:        }
        -: 1018:        
        -: 1019:        // Try to update the head atomically (CAS operation)
        -: 1020:        // This will fail if another thread modified the head
       12: 1021:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -: 1022:        &pool->free_stack, &head, next,
        -: 1023:        memory_order_acq_rel, memory_order_acquire));
        -: 1024:    
        -: 1025:    // Successfully popped a block from the stack
       12: 1026:    head->in_use = true;
       12: 1027:    head->next = NULL;  // Clear the next pointer for safety
        -: 1028:    
        -: 1029:    // Prefetch the actual data block for the caller
       12: 1030:    MERCURY_PREFETCH_WRITE(head->data);
call    0 returned 100%
        -: 1031:    
        -: 1032:    // Update statistics (relaxed ordering for performance)
       12: 1033:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1034:    
       12: 1035:    return head->data;
        -: 1036:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 0 returned 0% blocks executed 0%
    #####:  992:void* memory_pool_alloc(memory_pool_t* pool) {
    #####:  993:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 never executed
branch  1 never executed
        -:  994:    
        -:  995:    // Lock-free atomic stack pop operation
        -:  996:    memory_block_t* head;
        -:  997:    memory_block_t* next;
        -:  998:    
        -:  999:    do {
        -: 1000:        // Load current head with acquire ordering
    #####: 1001:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1002:        
        -: 1003:        // Check if stack is empty
    #####: 1004:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 never executed
branch  1 never executed
        -: 1005:            return NULL;  // Pool exhausted
        -: 1006:        }
        -: 1007:        
        -: 1008:        // Prefetch the head block for reading its fields
    #####: 1009:        MERCURY_PREFETCH_READ(head);
call    0 never executed
        -: 1010:        
        -: 1011:        // Get the next block in the stack  
    #####: 1012:        next = head->next;
        -: 1013:        
        -: 1014:        // Prefetch the next block in case CAS fails and we need to retry
    #####: 1015:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 never executed
branch  1 never executed
    #####: 1016:            MERCURY_PREFETCH_READ_LOW(next);
call    0 never executed
        -: 1017:        }
        -: 1018:        
        -: 1019:        // Try to update the head atomically (CAS operation)
        -: 1020:        // This will fail if another thread modified the head
    #####: 1021:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1022:        &pool->free_stack, &head, next,
        -: 1023:        memory_order_acq_rel, memory_order_acquire));
        -: 1024:    
        -: 1025:    // Successfully popped a block from the stack
    #####: 1026:    head->in_use = true;
    #####: 1027:    head->next = NULL;  // Clear the next pointer for safety
        -: 1028:    
        -: 1029:    // Prefetch the actual data block for the caller
    #####: 1030:    MERCURY_PREFETCH_WRITE(head->data);
call    0 never executed
        -: 1031:    
        -: 1032:    // Update statistics (relaxed ordering for performance)
    #####: 1033:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1034:    
    #####: 1035:    return head->data;
        -: 1036:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 0 returned 0% blocks executed 0%
    #####:  992:void* memory_pool_alloc(memory_pool_t* pool) {
    #####:  993:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 never executed
branch  1 never executed
        -:  994:    
        -:  995:    // Lock-free atomic stack pop operation
        -:  996:    memory_block_t* head;
        -:  997:    memory_block_t* next;
        -:  998:    
        -:  999:    do {
        -: 1000:        // Load current head with acquire ordering
    #####: 1001:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1002:        
        -: 1003:        // Check if stack is empty
    #####: 1004:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 never executed
branch  1 never executed
        -: 1005:            return NULL;  // Pool exhausted
        -: 1006:        }
        -: 1007:        
        -: 1008:        // Prefetch the head block for reading its fields
    #####: 1009:        MERCURY_PREFETCH_READ(head);
call    0 never executed
        -: 1010:        
        -: 1011:        // Get the next block in the stack  
    #####: 1012:        next = head->next;
        -: 1013:        
        -: 1014:        // Prefetch the next block in case CAS fails and we need to retry
    #####: 1015:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 never executed
branch  1 never executed
    #####: 1016:            MERCURY_PREFETCH_READ_LOW(next);
call    0 never executed
        -: 1017:        }
        -: 1018:        
        -: 1019:        // Try to update the head atomically (CAS operation)
        -: 1020:        // This will fail if another thread modified the head
    #####: 1021:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1022:        &pool->free_stack, &head, next,
        -: 1023:        memory_order_acq_rel, memory_order_acquire));
        -: 1024:    
        -: 1025:    // Successfully popped a block from the stack
    #####: 1026:    head->in_use = true;
    #####: 1027:    head->next = NULL;  // Clear the next pointer for safety
        -: 1028:    
        -: 1029:    // Prefetch the actual data block for the caller
    #####: 1030:    MERCURY_PREFETCH_WRITE(head->data);
call    0 never executed
        -: 1031:    
        -: 1032:    // Update statistics (relaxed ordering for performance)
    #####: 1033:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1034:    
    #####: 1035:    return head->data;
        -: 1036:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 173 returned 100% blocks executed 100%
      173:  992:void* memory_pool_alloc(memory_pool_t* pool) {
      173:  993:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  994:    
        -:  995:    // Lock-free atomic stack pop operation
        -:  996:    memory_block_t* head;
        -:  997:    memory_block_t* next;
        -:  998:    
        -:  999:    do {
        -: 1000:        // Load current head with acquire ordering
      173: 1001:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1002:        
        -: 1003:        // Check if stack is empty
      173: 1004:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1005:            return NULL;  // Pool exhausted
        -: 1006:        }
        -: 1007:        
        -: 1008:        // Prefetch the head block for reading its fields
      173: 1009:        MERCURY_PREFETCH_READ(head);
call    0 returned 100%
        -: 1010:        
        -: 1011:        // Get the next block in the stack  
      173: 1012:        next = head->next;
        -: 1013:        
        -: 1014:        // Prefetch the next block in case CAS fails and we need to retry
      173: 1015:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      173: 1016:            MERCURY_PREFETCH_READ_LOW(next);
call    0 returned 100%
        -: 1017:        }
        -: 1018:        
        -: 1019:        // Try to update the head atomically (CAS operation)
        -: 1020:        // This will fail if another thread modified the head
      173: 1021:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -: 1022:        &pool->free_stack, &head, next,
        -: 1023:        memory_order_acq_rel, memory_order_acquire));
        -: 1024:    
        -: 1025:    // Successfully popped a block from the stack
      173: 1026:    head->in_use = true;
      173: 1027:    head->next = NULL;  // Clear the next pointer for safety
        -: 1028:    
        -: 1029:    // Prefetch the actual data block for the caller
      173: 1030:    MERCURY_PREFETCH_WRITE(head->data);
call    0 returned 100%
        -: 1031:    
        -: 1032:    // Update statistics (relaxed ordering for performance)
      173: 1033:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1034:    
      173: 1035:    return head->data;
        -: 1036:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 3105 returned 100% blocks executed 100%
     3105:  992:void* memory_pool_alloc(memory_pool_t* pool) {
     3105:  993:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  994:    
        -:  995:    // Lock-free atomic stack pop operation
        -:  996:    memory_block_t* head;
        -:  997:    memory_block_t* next;
        -:  998:    
        -:  999:    do {
        -: 1000:        // Load current head with acquire ordering
     3107: 1001:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1002:        
        -: 1003:        // Check if stack is empty
     3107: 1004:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1005:            return NULL;  // Pool exhausted
        -: 1006:        }
        -: 1007:        
        -: 1008:        // Prefetch the head block for reading its fields
     3107: 1009:        MERCURY_PREFETCH_READ(head);
call    0 returned 100%
        -: 1010:        
        -: 1011:        // Get the next block in the stack  
     3107: 1012:        next = head->next;
        -: 1013:        
        -: 1014:        // Prefetch the next block in case CAS fails and we need to retry
     3107: 1015:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     3107: 1016:            MERCURY_PREFETCH_READ_LOW(next);
call    0 returned 100%
        -: 1017:        }
        -: 1018:        
        -: 1019:        // Try to update the head atomically (CAS operation)
        -: 1020:        // This will fail if another thread modified the head
     3107: 1021:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 1%
branch  2 taken 100% (fallthrough)
        -: 1022:        &pool->free_stack, &head, next,
        -: 1023:        memory_order_acq_rel, memory_order_acquire));
        -: 1024:    
        -: 1025:    // Successfully popped a block from the stack
     3105: 1026:    head->in_use = true;
     3105: 1027:    head->next = NULL;  // Clear the next pointer for safety
        -: 1028:    
        -: 1029:    // Prefetch the actual data block for the caller
     3105: 1030:    MERCURY_PREFETCH_WRITE(head->data);
call    0 returned 100%
        -: 1031:    
        -: 1032:    // Update statistics (relaxed ordering for performance)
     3105: 1033:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1034:    
     3105: 1035:    return head->data;
        -: 1036:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 0 returned 0% blocks executed 0%
    #####:  992:void* memory_pool_alloc(memory_pool_t* pool) {
    #####:  993:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 never executed
branch  1 never executed
        -:  994:    
        -:  995:    // Lock-free atomic stack pop operation
        -:  996:    memory_block_t* head;
        -:  997:    memory_block_t* next;
        -:  998:    
        -:  999:    do {
        -: 1000:        // Load current head with acquire ordering
    #####: 1001:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1002:        
        -: 1003:        // Check if stack is empty
    #####: 1004:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 never executed
branch  1 never executed
        -: 1005:            return NULL;  // Pool exhausted
        -: 1006:        }
        -: 1007:        
        -: 1008:        // Prefetch the head block for reading its fields
    #####: 1009:        MERCURY_PREFETCH_READ(head);
call    0 never executed
        -: 1010:        
        -: 1011:        // Get the next block in the stack  
    #####: 1012:        next = head->next;
        -: 1013:        
        -: 1014:        // Prefetch the next block in case CAS fails and we need to retry
    #####: 1015:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 never executed
branch  1 never executed
    #####: 1016:            MERCURY_PREFETCH_READ_LOW(next);
call    0 never executed
        -: 1017:        }
        -: 1018:        
        -: 1019:        // Try to update the head atomically (CAS operation)
        -: 1020:        // This will fail if another thread modified the head
    #####: 1021:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1022:        &pool->free_stack, &head, next,
        -: 1023:        memory_order_acq_rel, memory_order_acquire));
        -: 1024:    
        -: 1025:    // Successfully popped a block from the stack
    #####: 1026:    head->in_use = true;
    #####: 1027:    head->next = NULL;  // Clear the next pointer for safety
        -: 1028:    
        -: 1029:    // Prefetch the actual data block for the caller
    #####: 1030:    MERCURY_PREFETCH_WRITE(head->data);
call    0 never executed
        -: 1031:    
        -: 1032:    // Update statistics (relaxed ordering for performance)
    #####: 1033:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1034:    
    #####: 1035:    return head->data;
        -: 1036:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 0 returned 0% blocks executed 0%
    #####:  992:void* memory_pool_alloc(memory_pool_t* pool) {
    #####:  993:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 never executed
branch  1 never executed
        -:  994:    
        -:  995:    // Lock-free atomic stack pop operation
        -:  996:    memory_block_t* head;
        -:  997:    memory_block_t* next;
        -:  998:    
        -:  999:    do {
        -: 1000:        // Load current head with acquire ordering
    #####: 1001:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1002:        
        -: 1003:        // Check if stack is empty
    #####: 1004:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 never executed
branch  1 never executed
        -: 1005:            return NULL;  // Pool exhausted
        -: 1006:        }
        -: 1007:        
        -: 1008:        // Prefetch the head block for reading its fields
    #####: 1009:        MERCURY_PREFETCH_READ(head);
call    0 never executed
        -: 1010:        
        -: 1011:        // Get the next block in the stack  
    #####: 1012:        next = head->next;
        -: 1013:        
        -: 1014:        // Prefetch the next block in case CAS fails and we need to retry
    #####: 1015:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 never executed
branch  1 never executed
    #####: 1016:            MERCURY_PREFETCH_READ_LOW(next);
call    0 never executed
        -: 1017:        }
        -: 1018:        
        -: 1019:        // Try to update the head atomically (CAS operation)
        -: 1020:        // This will fail if another thread modified the head
    #####: 1021:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1022:        &pool->free_stack, &head, next,
        -: 1023:        memory_order_acq_rel, memory_order_acquire));
        -: 1024:    
        -: 1025:    // Successfully popped a block from the stack
    #####: 1026:    head->in_use = true;
    #####: 1027:    head->next = NULL;  // Clear the next pointer for safety
        -: 1028:    
        -: 1029:    // Prefetch the actual data block for the caller
    #####: 1030:    MERCURY_PREFETCH_WRITE(head->data);
call    0 never executed
        -: 1031:    
        -: 1032:    // Update statistics (relaxed ordering for performance)
    #####: 1033:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1034:    
    #####: 1035:    return head->data;
        -: 1036:}
------------------
memory_pool_alloc:
function memory_pool_alloc called 0 returned 0% blocks executed 0%
    #####:  992:void* memory_pool_alloc(memory_pool_t* pool) {
    #####:  993:    if (MERCURY_UNLIKELY(!pool)) return NULL;
branch  0 never executed
branch  1 never executed
        -:  994:    
        -:  995:    // Lock-free atomic stack pop operation
        -:  996:    memory_block_t* head;
        -:  997:    memory_block_t* next;
        -:  998:    
        -:  999:    do {
        -: 1000:        // Load current head with acquire ordering
    #####: 1001:        head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1002:        
        -: 1003:        // Check if stack is empty
    #####: 1004:        if (MERCURY_UNLIKELY(head == NULL)) {
branch  0 never executed
branch  1 never executed
        -: 1005:            return NULL;  // Pool exhausted
        -: 1006:        }
        -: 1007:        
        -: 1008:        // Prefetch the head block for reading its fields
    #####: 1009:        MERCURY_PREFETCH_READ(head);
call    0 never executed
        -: 1010:        
        -: 1011:        // Get the next block in the stack  
    #####: 1012:        next = head->next;
        -: 1013:        
        -: 1014:        // Prefetch the next block in case CAS fails and we need to retry
    #####: 1015:        if (MERCURY_LIKELY(next != NULL)) {
branch  0 never executed
branch  1 never executed
    #####: 1016:            MERCURY_PREFETCH_READ_LOW(next);
call    0 never executed
        -: 1017:        }
        -: 1018:        
        -: 1019:        // Try to update the head atomically (CAS operation)
        -: 1020:        // This will fail if another thread modified the head
    #####: 1021:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1022:        &pool->free_stack, &head, next,
        -: 1023:        memory_order_acq_rel, memory_order_acquire));
        -: 1024:    
        -: 1025:    // Successfully popped a block from the stack
    #####: 1026:    head->in_use = true;
    #####: 1027:    head->next = NULL;  // Clear the next pointer for safety
        -: 1028:    
        -: 1029:    // Prefetch the actual data block for the caller
    #####: 1030:    MERCURY_PREFETCH_WRITE(head->data);
call    0 never executed
        -: 1031:    
        -: 1032:    // Update statistics (relaxed ordering for performance)
    #####: 1033:    atomic_fetch_sub_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1034:    
    #####: 1035:    return head->data;
        -: 1036:}
------------------
        -: 1037:
        -: 1038:/**
        -: 1039: * @brief Return a block to the memory pool
        -: 1040: * 
        -: 1041: * @details Uses lock-free atomic operations for thread-safe deallocation
        -: 1042: * with O(1) performance.
        -: 1043: * 
        -: 1044: * @param pool Memory pool that owns the block
        -: 1045: * @param ptr Pointer previously returned by memory_pool_alloc
        -: 1046: * 
        -: 1047: * @warning ptr must be from this pool's memory_pool_alloc()
        -: 1048: * @note Thread-safe with multiple concurrent deallocators
        -: 1049: */
    3308*: 1050:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    3308*: 1051:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
        -: 1052:    
        -: 1053:    // Find the block that contains this pointer
        -: 1054:    // Since we allocated all blocks contiguously, we can search through them
        -: 1055:    memory_block_t* target_block = NULL;
 6689168*: 1056:    for (size_t i = 0; i < pool->num_blocks; i++) {
 6689167*: 1057:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
        -: 1058:            target_block = &pool->all_blocks[i];
        -: 1059:            break;
        -: 1060:        }
        -: 1061:    }
        -: 1062:    
    3308*: 1063:    if (MERCURY_UNLIKELY(!target_block)) {
        -: 1064:        // Invalid pointer or already freed
        -: 1065:        return;
        -: 1066:    }
        -: 1067:    
        -: 1068:    // Mark as not in use
    3307*: 1069:    target_block->in_use = false;
        -: 1070:    
        -: 1071:    // Lock-free atomic stack push operation
        -: 1072:    memory_block_t* current_head;
        -: 1073:    do {
        -: 1074:        // Load current head with acquire ordering
    3307*: 1075:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1076:        
        -: 1077:        // Set this block's next to point to current head
    3307*: 1078:        target_block->next = current_head;
        -: 1079:        
        -: 1080:        // Try to update the head atomically (CAS operation)
        -: 1081:        // This will fail if another thread modified the head
    3307*: 1082:    } while (!atomic_compare_exchange_weak_explicit(
        -: 1083:        &pool->free_stack, &current_head, target_block,
        -: 1084:        memory_order_acq_rel, memory_order_acquire));
        -: 1085:    
        -: 1086:    // Successfully pushed the block back onto the free stack
        -: 1087:    // Update statistics (relaxed ordering for performance)
    3307*: 1088:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1089:}
------------------
memory_pool_free:
function memory_pool_free called 0 returned 0% blocks executed 0%
    #####: 1050:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    #####: 1051:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 never executed
branch  1 never executed
        -: 1052:    
        -: 1053:    // Find the block that contains this pointer
        -: 1054:    // Since we allocated all blocks contiguously, we can search through them
        -: 1055:    memory_block_t* target_block = NULL;
    #####: 1056:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1057:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1058:            target_block = &pool->all_blocks[i];
        -: 1059:            break;
        -: 1060:        }
        -: 1061:    }
        -: 1062:    
    #####: 1063:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 never executed
branch  1 never executed
        -: 1064:        // Invalid pointer or already freed
        -: 1065:        return;
        -: 1066:    }
        -: 1067:    
        -: 1068:    // Mark as not in use
    #####: 1069:    target_block->in_use = false;
        -: 1070:    
        -: 1071:    // Lock-free atomic stack push operation
        -: 1072:    memory_block_t* current_head;
        -: 1073:    do {
        -: 1074:        // Load current head with acquire ordering
    #####: 1075:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1076:        
        -: 1077:        // Set this block's next to point to current head
    #####: 1078:        target_block->next = current_head;
        -: 1079:        
        -: 1080:        // Try to update the head atomically (CAS operation)
        -: 1081:        // This will fail if another thread modified the head
    #####: 1082:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1083:        &pool->free_stack, &current_head, target_block,
        -: 1084:        memory_order_acq_rel, memory_order_acquire));
        -: 1085:    
        -: 1086:    // Successfully pushed the block back onto the free stack
        -: 1087:    // Update statistics (relaxed ordering for performance)
    #####: 1088:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1089:}
------------------
memory_pool_free:
function memory_pool_free called 13 returned 100% blocks executed 100%
       13: 1050:void memory_pool_free(memory_pool_t* pool, void* ptr) {
       13: 1051:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 taken 100%
branch  1 taken 0%
        -: 1052:    
        -: 1053:    // Find the block that contains this pointer
        -: 1054:    // Since we allocated all blocks contiguously, we can search through them
        -: 1055:    memory_block_t* target_block = NULL;
     1001: 1056:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
     1001: 1057:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1058:            target_block = &pool->all_blocks[i];
        -: 1059:            break;
        -: 1060:        }
        -: 1061:    }
        -: 1062:    
       13: 1063:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1064:        // Invalid pointer or already freed
        -: 1065:        return;
        -: 1066:    }
        -: 1067:    
        -: 1068:    // Mark as not in use
       13: 1069:    target_block->in_use = false;
        -: 1070:    
        -: 1071:    // Lock-free atomic stack push operation
        -: 1072:    memory_block_t* current_head;
        -: 1073:    do {
        -: 1074:        // Load current head with acquire ordering
       13: 1075:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1076:        
        -: 1077:        // Set this block's next to point to current head
       13: 1078:        target_block->next = current_head;
        -: 1079:        
        -: 1080:        // Try to update the head atomically (CAS operation)
        -: 1081:        // This will fail if another thread modified the head
       13: 1082:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -: 1083:        &pool->free_stack, &current_head, target_block,
        -: 1084:        memory_order_acq_rel, memory_order_acquire));
        -: 1085:    
        -: 1086:    // Successfully pushed the block back onto the free stack
        -: 1087:    // Update statistics (relaxed ordering for performance)
       13: 1088:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1089:}
------------------
memory_pool_free:
function memory_pool_free called 5 returned 100% blocks executed 100%
        5: 1050:void memory_pool_free(memory_pool_t* pool, void* ptr) {
        5: 1051:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 taken 100%
branch  1 taken 0%
        -: 1052:    
        -: 1053:    // Find the block that contains this pointer
        -: 1054:    // Since we allocated all blocks contiguously, we can search through them
        -: 1055:    memory_block_t* target_block = NULL;
       14: 1056:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 93%
branch  1 taken 7% (fallthrough)
       13: 1057:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
branch  2 taken 20% (fallthrough)
branch  3 taken 80%
        -: 1058:            target_block = &pool->all_blocks[i];
        -: 1059:            break;
        -: 1060:        }
        -: 1061:    }
        -: 1062:    
        5: 1063:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 taken 80% (fallthrough)
branch  1 taken 20%
        -: 1064:        // Invalid pointer or already freed
        -: 1065:        return;
        -: 1066:    }
        -: 1067:    
        -: 1068:    // Mark as not in use
        4: 1069:    target_block->in_use = false;
        -: 1070:    
        -: 1071:    // Lock-free atomic stack push operation
        -: 1072:    memory_block_t* current_head;
        -: 1073:    do {
        -: 1074:        // Load current head with acquire ordering
        4: 1075:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1076:        
        -: 1077:        // Set this block's next to point to current head
        4: 1078:        target_block->next = current_head;
        -: 1079:        
        -: 1080:        // Try to update the head atomically (CAS operation)
        -: 1081:        // This will fail if another thread modified the head
        4: 1082:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -: 1083:        &pool->free_stack, &current_head, target_block,
        -: 1084:        memory_order_acq_rel, memory_order_acquire));
        -: 1085:    
        -: 1086:    // Successfully pushed the block back onto the free stack
        -: 1087:    // Update statistics (relaxed ordering for performance)
        4: 1088:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1089:}
------------------
memory_pool_free:
function memory_pool_free called 12 returned 100% blocks executed 100%
       12: 1050:void memory_pool_free(memory_pool_t* pool, void* ptr) {
       12: 1051:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 taken 100%
branch  1 taken 0%
        -: 1052:    
        -: 1053:    // Find the block that contains this pointer
        -: 1054:    // Since we allocated all blocks contiguously, we can search through them
        -: 1055:    memory_block_t* target_block = NULL;
       65: 1056:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
       65: 1057:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1058:            target_block = &pool->all_blocks[i];
        -: 1059:            break;
        -: 1060:        }
        -: 1061:    }
        -: 1062:    
       12: 1063:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1064:        // Invalid pointer or already freed
        -: 1065:        return;
        -: 1066:    }
        -: 1067:    
        -: 1068:    // Mark as not in use
       12: 1069:    target_block->in_use = false;
        -: 1070:    
        -: 1071:    // Lock-free atomic stack push operation
        -: 1072:    memory_block_t* current_head;
        -: 1073:    do {
        -: 1074:        // Load current head with acquire ordering
       12: 1075:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1076:        
        -: 1077:        // Set this block's next to point to current head
       12: 1078:        target_block->next = current_head;
        -: 1079:        
        -: 1080:        // Try to update the head atomically (CAS operation)
        -: 1081:        // This will fail if another thread modified the head
       12: 1082:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -: 1083:        &pool->free_stack, &current_head, target_block,
        -: 1084:        memory_order_acq_rel, memory_order_acquire));
        -: 1085:    
        -: 1086:    // Successfully pushed the block back onto the free stack
        -: 1087:    // Update statistics (relaxed ordering for performance)
       12: 1088:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1089:}
------------------
memory_pool_free:
function memory_pool_free called 0 returned 0% blocks executed 0%
    #####: 1050:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    #####: 1051:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 never executed
branch  1 never executed
        -: 1052:    
        -: 1053:    // Find the block that contains this pointer
        -: 1054:    // Since we allocated all blocks contiguously, we can search through them
        -: 1055:    memory_block_t* target_block = NULL;
    #####: 1056:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1057:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1058:            target_block = &pool->all_blocks[i];
        -: 1059:            break;
        -: 1060:        }
        -: 1061:    }
        -: 1062:    
    #####: 1063:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 never executed
branch  1 never executed
        -: 1064:        // Invalid pointer or already freed
        -: 1065:        return;
        -: 1066:    }
        -: 1067:    
        -: 1068:    // Mark as not in use
    #####: 1069:    target_block->in_use = false;
        -: 1070:    
        -: 1071:    // Lock-free atomic stack push operation
        -: 1072:    memory_block_t* current_head;
        -: 1073:    do {
        -: 1074:        // Load current head with acquire ordering
    #####: 1075:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1076:        
        -: 1077:        // Set this block's next to point to current head
    #####: 1078:        target_block->next = current_head;
        -: 1079:        
        -: 1080:        // Try to update the head atomically (CAS operation)
        -: 1081:        // This will fail if another thread modified the head
    #####: 1082:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1083:        &pool->free_stack, &current_head, target_block,
        -: 1084:        memory_order_acq_rel, memory_order_acquire));
        -: 1085:    
        -: 1086:    // Successfully pushed the block back onto the free stack
        -: 1087:    // Update statistics (relaxed ordering for performance)
    #####: 1088:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1089:}
------------------
memory_pool_free:
function memory_pool_free called 0 returned 0% blocks executed 0%
    #####: 1050:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    #####: 1051:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 never executed
branch  1 never executed
        -: 1052:    
        -: 1053:    // Find the block that contains this pointer
        -: 1054:    // Since we allocated all blocks contiguously, we can search through them
        -: 1055:    memory_block_t* target_block = NULL;
    #####: 1056:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1057:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1058:            target_block = &pool->all_blocks[i];
        -: 1059:            break;
        -: 1060:        }
        -: 1061:    }
        -: 1062:    
    #####: 1063:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 never executed
branch  1 never executed
        -: 1064:        // Invalid pointer or already freed
        -: 1065:        return;
        -: 1066:    }
        -: 1067:    
        -: 1068:    // Mark as not in use
    #####: 1069:    target_block->in_use = false;
        -: 1070:    
        -: 1071:    // Lock-free atomic stack push operation
        -: 1072:    memory_block_t* current_head;
        -: 1073:    do {
        -: 1074:        // Load current head with acquire ordering
    #####: 1075:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1076:        
        -: 1077:        // Set this block's next to point to current head
    #####: 1078:        target_block->next = current_head;
        -: 1079:        
        -: 1080:        // Try to update the head atomically (CAS operation)
        -: 1081:        // This will fail if another thread modified the head
    #####: 1082:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1083:        &pool->free_stack, &current_head, target_block,
        -: 1084:        memory_order_acq_rel, memory_order_acquire));
        -: 1085:    
        -: 1086:    // Successfully pushed the block back onto the free stack
        -: 1087:    // Update statistics (relaxed ordering for performance)
    #####: 1088:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1089:}
------------------
memory_pool_free:
function memory_pool_free called 173 returned 100% blocks executed 100%
      173: 1050:void memory_pool_free(memory_pool_t* pool, void* ptr) {
      173: 1051:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 taken 100%
branch  1 taken 0%
        -: 1052:    
        -: 1053:    // Find the block that contains this pointer
        -: 1054:    // Since we allocated all blocks contiguously, we can search through them
        -: 1055:    memory_block_t* target_block = NULL;
   426487: 1056:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
   426487: 1057:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1058:            target_block = &pool->all_blocks[i];
        -: 1059:            break;
        -: 1060:        }
        -: 1061:    }
        -: 1062:    
      173: 1063:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1064:        // Invalid pointer or already freed
        -: 1065:        return;
        -: 1066:    }
        -: 1067:    
        -: 1068:    // Mark as not in use
      173: 1069:    target_block->in_use = false;
        -: 1070:    
        -: 1071:    // Lock-free atomic stack push operation
        -: 1072:    memory_block_t* current_head;
        -: 1073:    do {
        -: 1074:        // Load current head with acquire ordering
      173: 1075:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1076:        
        -: 1077:        // Set this block's next to point to current head
      173: 1078:        target_block->next = current_head;
        -: 1079:        
        -: 1080:        // Try to update the head atomically (CAS operation)
        -: 1081:        // This will fail if another thread modified the head
      173: 1082:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -: 1083:        &pool->free_stack, &current_head, target_block,
        -: 1084:        memory_order_acq_rel, memory_order_acquire));
        -: 1085:    
        -: 1086:    // Successfully pushed the block back onto the free stack
        -: 1087:    // Update statistics (relaxed ordering for performance)
      173: 1088:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1089:}
------------------
memory_pool_free:
function memory_pool_free called 3105 returned 100% blocks executed 100%
     3105: 1050:void memory_pool_free(memory_pool_t* pool, void* ptr) {
     3105: 1051:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 taken 100%
branch  1 taken 0%
        -: 1052:    
        -: 1053:    // Find the block that contains this pointer
        -: 1054:    // Since we allocated all blocks contiguously, we can search through them
        -: 1055:    memory_block_t* target_block = NULL;
  6261601: 1056:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
  6261601: 1057:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1058:            target_block = &pool->all_blocks[i];
        -: 1059:            break;
        -: 1060:        }
        -: 1061:    }
        -: 1062:    
     3105: 1063:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1064:        // Invalid pointer or already freed
        -: 1065:        return;
        -: 1066:    }
        -: 1067:    
        -: 1068:    // Mark as not in use
     3105: 1069:    target_block->in_use = false;
        -: 1070:    
        -: 1071:    // Lock-free atomic stack push operation
        -: 1072:    memory_block_t* current_head;
        -: 1073:    do {
        -: 1074:        // Load current head with acquire ordering
     3105: 1075:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1076:        
        -: 1077:        // Set this block's next to point to current head
     3105: 1078:        target_block->next = current_head;
        -: 1079:        
        -: 1080:        // Try to update the head atomically (CAS operation)
        -: 1081:        // This will fail if another thread modified the head
     3105: 1082:    } while (!atomic_compare_exchange_weak_explicit(
call    0 returned 100%
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
        -: 1083:        &pool->free_stack, &current_head, target_block,
        -: 1084:        memory_order_acq_rel, memory_order_acquire));
        -: 1085:    
        -: 1086:    // Successfully pushed the block back onto the free stack
        -: 1087:    // Update statistics (relaxed ordering for performance)
     3105: 1088:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1089:}
------------------
memory_pool_free:
function memory_pool_free called 0 returned 0% blocks executed 0%
    #####: 1050:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    #####: 1051:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 never executed
branch  1 never executed
        -: 1052:    
        -: 1053:    // Find the block that contains this pointer
        -: 1054:    // Since we allocated all blocks contiguously, we can search through them
        -: 1055:    memory_block_t* target_block = NULL;
    #####: 1056:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1057:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1058:            target_block = &pool->all_blocks[i];
        -: 1059:            break;
        -: 1060:        }
        -: 1061:    }
        -: 1062:    
    #####: 1063:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 never executed
branch  1 never executed
        -: 1064:        // Invalid pointer or already freed
        -: 1065:        return;
        -: 1066:    }
        -: 1067:    
        -: 1068:    // Mark as not in use
    #####: 1069:    target_block->in_use = false;
        -: 1070:    
        -: 1071:    // Lock-free atomic stack push operation
        -: 1072:    memory_block_t* current_head;
        -: 1073:    do {
        -: 1074:        // Load current head with acquire ordering
    #####: 1075:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1076:        
        -: 1077:        // Set this block's next to point to current head
    #####: 1078:        target_block->next = current_head;
        -: 1079:        
        -: 1080:        // Try to update the head atomically (CAS operation)
        -: 1081:        // This will fail if another thread modified the head
    #####: 1082:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1083:        &pool->free_stack, &current_head, target_block,
        -: 1084:        memory_order_acq_rel, memory_order_acquire));
        -: 1085:    
        -: 1086:    // Successfully pushed the block back onto the free stack
        -: 1087:    // Update statistics (relaxed ordering for performance)
    #####: 1088:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1089:}
------------------
memory_pool_free:
function memory_pool_free called 0 returned 0% blocks executed 0%
    #####: 1050:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    #####: 1051:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 never executed
branch  1 never executed
        -: 1052:    
        -: 1053:    // Find the block that contains this pointer
        -: 1054:    // Since we allocated all blocks contiguously, we can search through them
        -: 1055:    memory_block_t* target_block = NULL;
    #####: 1056:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1057:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1058:            target_block = &pool->all_blocks[i];
        -: 1059:            break;
        -: 1060:        }
        -: 1061:    }
        -: 1062:    
    #####: 1063:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 never executed
branch  1 never executed
        -: 1064:        // Invalid pointer or already freed
        -: 1065:        return;
        -: 1066:    }
        -: 1067:    
        -: 1068:    // Mark as not in use
    #####: 1069:    target_block->in_use = false;
        -: 1070:    
        -: 1071:    // Lock-free atomic stack push operation
        -: 1072:    memory_block_t* current_head;
        -: 1073:    do {
        -: 1074:        // Load current head with acquire ordering
    #####: 1075:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1076:        
        -: 1077:        // Set this block's next to point to current head
    #####: 1078:        target_block->next = current_head;
        -: 1079:        
        -: 1080:        // Try to update the head atomically (CAS operation)
        -: 1081:        // This will fail if another thread modified the head
    #####: 1082:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1083:        &pool->free_stack, &current_head, target_block,
        -: 1084:        memory_order_acq_rel, memory_order_acquire));
        -: 1085:    
        -: 1086:    // Successfully pushed the block back onto the free stack
        -: 1087:    // Update statistics (relaxed ordering for performance)
    #####: 1088:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1089:}
------------------
memory_pool_free:
function memory_pool_free called 0 returned 0% blocks executed 0%
    #####: 1050:void memory_pool_free(memory_pool_t* pool, void* ptr) {
    #####: 1051:    if (MERCURY_UNLIKELY(!pool || !ptr)) return;
branch  0 never executed
branch  1 never executed
        -: 1052:    
        -: 1053:    // Find the block that contains this pointer
        -: 1054:    // Since we allocated all blocks contiguously, we can search through them
        -: 1055:    memory_block_t* target_block = NULL;
    #####: 1056:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1057:        if (pool->all_blocks[i].data == ptr && pool->all_blocks[i].in_use) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1058:            target_block = &pool->all_blocks[i];
        -: 1059:            break;
        -: 1060:        }
        -: 1061:    }
        -: 1062:    
    #####: 1063:    if (MERCURY_UNLIKELY(!target_block)) {
branch  0 never executed
branch  1 never executed
        -: 1064:        // Invalid pointer or already freed
        -: 1065:        return;
        -: 1066:    }
        -: 1067:    
        -: 1068:    // Mark as not in use
    #####: 1069:    target_block->in_use = false;
        -: 1070:    
        -: 1071:    // Lock-free atomic stack push operation
        -: 1072:    memory_block_t* current_head;
        -: 1073:    do {
        -: 1074:        // Load current head with acquire ordering
    #####: 1075:        current_head = atomic_load_explicit(&pool->free_stack, memory_order_acquire);
        -: 1076:        
        -: 1077:        // Set this block's next to point to current head
    #####: 1078:        target_block->next = current_head;
        -: 1079:        
        -: 1080:        // Try to update the head atomically (CAS operation)
        -: 1081:        // This will fail if another thread modified the head
    #####: 1082:    } while (!atomic_compare_exchange_weak_explicit(
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1083:        &pool->free_stack, &current_head, target_block,
        -: 1084:        memory_order_acq_rel, memory_order_acquire));
        -: 1085:    
        -: 1086:    // Successfully pushed the block back onto the free stack
        -: 1087:    // Update statistics (relaxed ordering for performance)
    #####: 1088:    atomic_fetch_add_explicit(&pool->free_count, 1, memory_order_relaxed);
        -: 1089:}
------------------
        -: 1090:
        -: 1091:/**
        -: 1092: * @brief Destroy memory pool and free all resources
        -: 1093: * 
        -: 1094: * @param pool Memory pool to destroy
        -: 1095: * 
        -: 1096: * @warning Not thread-safe - ensure no concurrent access
        -: 1097: * @note Safe to call with NULL or already destroyed pool
        -: 1098: */
       8*: 1099:void memory_pool_destroy(memory_pool_t* pool) {
       8*: 1100:    if (!pool || !pool->all_blocks) return;
        -: 1101:    
        -: 1102:    // Free all allocated block data
    5145*: 1103:    for (size_t i = 0; i < pool->num_blocks; i++) {
    5137*: 1104:        if (pool->all_blocks[i].data) {
    5137*: 1105:            mercury_aligned_free(pool->all_blocks[i].data);
    5137*: 1106:            pool->all_blocks[i].data = NULL;
        -: 1107:        }
        -: 1108:    }
        -: 1109:    
        -: 1110:    // Free the block array
       8*: 1111:    mercury_aligned_free(pool->all_blocks);
       8*: 1112:    pool->all_blocks = NULL;
        -: 1113:    
        -: 1114:    // Reset atomic variables
       8*: 1115:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
       8*: 1116:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -: 1117:    
       8*: 1118:    pool->block_size = 0;
       8*: 1119:    pool->num_blocks = 0;
        -: 1120:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 0 returned 0% blocks executed 0%
    #####: 1099:void memory_pool_destroy(memory_pool_t* pool) {
    #####: 1100:    if (!pool || !pool->all_blocks) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1101:    
        -: 1102:    // Free all allocated block data
    #####: 1103:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1104:        if (pool->all_blocks[i].data) {
branch  0 never executed
branch  1 never executed
    #####: 1105:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 never executed
    #####: 1106:            pool->all_blocks[i].data = NULL;
        -: 1107:        }
        -: 1108:    }
        -: 1109:    
        -: 1110:    // Free the block array
    #####: 1111:    mercury_aligned_free(pool->all_blocks);
call    0 never executed
    #####: 1112:    pool->all_blocks = NULL;
        -: 1113:    
        -: 1114:    // Reset atomic variables
    #####: 1115:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####: 1116:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -: 1117:    
    #####: 1118:    pool->block_size = 0;
    #####: 1119:    pool->num_blocks = 0;
        -: 1120:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 2 returned 100% blocks executed 100%
        2: 1099:void memory_pool_destroy(memory_pool_t* pool) {
        2: 1100:    if (!pool || !pool->all_blocks) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -: 1101:    
        -: 1102:    // Free all allocated block data
      118: 1103:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
      116: 1104:        if (pool->all_blocks[i].data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      116: 1105:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 returned 100%
      116: 1106:            pool->all_blocks[i].data = NULL;
        -: 1107:        }
        -: 1108:    }
        -: 1109:    
        -: 1110:    // Free the block array
        2: 1111:    mercury_aligned_free(pool->all_blocks);
call    0 returned 100%
        2: 1112:    pool->all_blocks = NULL;
        -: 1113:    
        -: 1114:    // Reset atomic variables
        2: 1115:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        2: 1116:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -: 1117:    
        2: 1118:    pool->block_size = 0;
        2: 1119:    pool->num_blocks = 0;
        -: 1120:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 2 returned 100% blocks executed 100%
        2: 1099:void memory_pool_destroy(memory_pool_t* pool) {
        2: 1100:    if (!pool || !pool->all_blocks) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -: 1101:    
        -: 1102:    // Free all allocated block data
        8: 1103:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        6: 1104:        if (pool->all_blocks[i].data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        6: 1105:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 returned 100%
        6: 1106:            pool->all_blocks[i].data = NULL;
        -: 1107:        }
        -: 1108:    }
        -: 1109:    
        -: 1110:    // Free the block array
        2: 1111:    mercury_aligned_free(pool->all_blocks);
call    0 returned 100%
        2: 1112:    pool->all_blocks = NULL;
        -: 1113:    
        -: 1114:    // Reset atomic variables
        2: 1115:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        2: 1116:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -: 1117:    
        2: 1118:    pool->block_size = 0;
        2: 1119:    pool->num_blocks = 0;
        -: 1120:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 2 returned 100% blocks executed 100%
        2: 1099:void memory_pool_destroy(memory_pool_t* pool) {
        2: 1100:    if (!pool || !pool->all_blocks) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -: 1101:    
        -: 1102:    // Free all allocated block data
       17: 1103:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 88%
branch  1 taken 12% (fallthrough)
       15: 1104:        if (pool->all_blocks[i].data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       15: 1105:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 returned 100%
       15: 1106:            pool->all_blocks[i].data = NULL;
        -: 1107:        }
        -: 1108:    }
        -: 1109:    
        -: 1110:    // Free the block array
        2: 1111:    mercury_aligned_free(pool->all_blocks);
call    0 returned 100%
        2: 1112:    pool->all_blocks = NULL;
        -: 1113:    
        -: 1114:    // Reset atomic variables
        2: 1115:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        2: 1116:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -: 1117:    
        2: 1118:    pool->block_size = 0;
        2: 1119:    pool->num_blocks = 0;
        -: 1120:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 0 returned 0% blocks executed 0%
    #####: 1099:void memory_pool_destroy(memory_pool_t* pool) {
    #####: 1100:    if (!pool || !pool->all_blocks) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1101:    
        -: 1102:    // Free all allocated block data
    #####: 1103:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1104:        if (pool->all_blocks[i].data) {
branch  0 never executed
branch  1 never executed
    #####: 1105:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 never executed
    #####: 1106:            pool->all_blocks[i].data = NULL;
        -: 1107:        }
        -: 1108:    }
        -: 1109:    
        -: 1110:    // Free the block array
    #####: 1111:    mercury_aligned_free(pool->all_blocks);
call    0 never executed
    #####: 1112:    pool->all_blocks = NULL;
        -: 1113:    
        -: 1114:    // Reset atomic variables
    #####: 1115:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####: 1116:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -: 1117:    
    #####: 1118:    pool->block_size = 0;
    #####: 1119:    pool->num_blocks = 0;
        -: 1120:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 0 returned 0% blocks executed 0%
    #####: 1099:void memory_pool_destroy(memory_pool_t* pool) {
    #####: 1100:    if (!pool || !pool->all_blocks) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1101:    
        -: 1102:    // Free all allocated block data
    #####: 1103:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1104:        if (pool->all_blocks[i].data) {
branch  0 never executed
branch  1 never executed
    #####: 1105:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 never executed
    #####: 1106:            pool->all_blocks[i].data = NULL;
        -: 1107:        }
        -: 1108:    }
        -: 1109:    
        -: 1110:    // Free the block array
    #####: 1111:    mercury_aligned_free(pool->all_blocks);
call    0 never executed
    #####: 1112:    pool->all_blocks = NULL;
        -: 1113:    
        -: 1114:    // Reset atomic variables
    #####: 1115:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####: 1116:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -: 1117:    
    #####: 1118:    pool->block_size = 0;
    #####: 1119:    pool->num_blocks = 0;
        -: 1120:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 1 returned 100% blocks executed 100%
        1: 1099:void memory_pool_destroy(memory_pool_t* pool) {
        1: 1100:    if (!pool || !pool->all_blocks) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -: 1101:    
        -: 1102:    // Free all allocated block data
     2501: 1103:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     2500: 1104:        if (pool->all_blocks[i].data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2500: 1105:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 returned 100%
     2500: 1106:            pool->all_blocks[i].data = NULL;
        -: 1107:        }
        -: 1108:    }
        -: 1109:    
        -: 1110:    // Free the block array
        1: 1111:    mercury_aligned_free(pool->all_blocks);
call    0 returned 100%
        1: 1112:    pool->all_blocks = NULL;
        -: 1113:    
        -: 1114:    // Reset atomic variables
        1: 1115:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        1: 1116:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -: 1117:    
        1: 1118:    pool->block_size = 0;
        1: 1119:    pool->num_blocks = 0;
        -: 1120:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 1 returned 100% blocks executed 100%
        1: 1099:void memory_pool_destroy(memory_pool_t* pool) {
        1: 1100:    if (!pool || !pool->all_blocks) return;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100%
branch  3 taken 0%
        -: 1101:    
        -: 1102:    // Free all allocated block data
     2501: 1103:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 taken 100%
branch  1 taken 1% (fallthrough)
     2500: 1104:        if (pool->all_blocks[i].data) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
     2500: 1105:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 returned 100%
     2500: 1106:            pool->all_blocks[i].data = NULL;
        -: 1107:        }
        -: 1108:    }
        -: 1109:    
        -: 1110:    // Free the block array
        1: 1111:    mercury_aligned_free(pool->all_blocks);
call    0 returned 100%
        1: 1112:    pool->all_blocks = NULL;
        -: 1113:    
        -: 1114:    // Reset atomic variables
        1: 1115:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
        1: 1116:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -: 1117:    
        1: 1118:    pool->block_size = 0;
        1: 1119:    pool->num_blocks = 0;
        -: 1120:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 0 returned 0% blocks executed 0%
    #####: 1099:void memory_pool_destroy(memory_pool_t* pool) {
    #####: 1100:    if (!pool || !pool->all_blocks) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1101:    
        -: 1102:    // Free all allocated block data
    #####: 1103:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1104:        if (pool->all_blocks[i].data) {
branch  0 never executed
branch  1 never executed
    #####: 1105:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 never executed
    #####: 1106:            pool->all_blocks[i].data = NULL;
        -: 1107:        }
        -: 1108:    }
        -: 1109:    
        -: 1110:    // Free the block array
    #####: 1111:    mercury_aligned_free(pool->all_blocks);
call    0 never executed
    #####: 1112:    pool->all_blocks = NULL;
        -: 1113:    
        -: 1114:    // Reset atomic variables
    #####: 1115:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####: 1116:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -: 1117:    
    #####: 1118:    pool->block_size = 0;
    #####: 1119:    pool->num_blocks = 0;
        -: 1120:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 0 returned 0% blocks executed 0%
    #####: 1099:void memory_pool_destroy(memory_pool_t* pool) {
    #####: 1100:    if (!pool || !pool->all_blocks) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1101:    
        -: 1102:    // Free all allocated block data
    #####: 1103:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1104:        if (pool->all_blocks[i].data) {
branch  0 never executed
branch  1 never executed
    #####: 1105:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 never executed
    #####: 1106:            pool->all_blocks[i].data = NULL;
        -: 1107:        }
        -: 1108:    }
        -: 1109:    
        -: 1110:    // Free the block array
    #####: 1111:    mercury_aligned_free(pool->all_blocks);
call    0 never executed
    #####: 1112:    pool->all_blocks = NULL;
        -: 1113:    
        -: 1114:    // Reset atomic variables
    #####: 1115:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####: 1116:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -: 1117:    
    #####: 1118:    pool->block_size = 0;
    #####: 1119:    pool->num_blocks = 0;
        -: 1120:}
------------------
memory_pool_destroy:
function memory_pool_destroy called 0 returned 0% blocks executed 0%
    #####: 1099:void memory_pool_destroy(memory_pool_t* pool) {
    #####: 1100:    if (!pool || !pool->all_blocks) return;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1101:    
        -: 1102:    // Free all allocated block data
    #####: 1103:    for (size_t i = 0; i < pool->num_blocks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1104:        if (pool->all_blocks[i].data) {
branch  0 never executed
branch  1 never executed
    #####: 1105:            mercury_aligned_free(pool->all_blocks[i].data);
call    0 never executed
    #####: 1106:            pool->all_blocks[i].data = NULL;
        -: 1107:        }
        -: 1108:    }
        -: 1109:    
        -: 1110:    // Free the block array
    #####: 1111:    mercury_aligned_free(pool->all_blocks);
call    0 never executed
    #####: 1112:    pool->all_blocks = NULL;
        -: 1113:    
        -: 1114:    // Reset atomic variables
    #####: 1115:    atomic_store_explicit(&pool->free_stack, NULL, memory_order_relaxed);
    #####: 1116:    atomic_store_explicit(&pool->free_count, 0, memory_order_relaxed);
        -: 1117:    
    #####: 1118:    pool->block_size = 0;
    #####: 1119:    pool->num_blocks = 0;
        -: 1120:}
------------------
        -: 1121:
        -: 1122:// === ERROR CHAIN IMPLEMENTATION ===
        -: 1123:
        -: 1124:// Error chain types now in common.h
        -: 1125:
    #####: 1126:void error_chain_init(error_chain_t* chain) {
    #####: 1127:    if (!chain) return;
        -: 1128:    
    #####: 1129:    chain->head = NULL;
    #####: 1130:    chain->count = 0;
        -: 1131:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####: 1126:void error_chain_init(error_chain_t* chain) {
    #####: 1127:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1128:    
    #####: 1129:    chain->head = NULL;
    #####: 1130:    chain->count = 0;
        -: 1131:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####: 1126:void error_chain_init(error_chain_t* chain) {
    #####: 1127:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1128:    
    #####: 1129:    chain->head = NULL;
    #####: 1130:    chain->count = 0;
        -: 1131:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####: 1126:void error_chain_init(error_chain_t* chain) {
    #####: 1127:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1128:    
    #####: 1129:    chain->head = NULL;
    #####: 1130:    chain->count = 0;
        -: 1131:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####: 1126:void error_chain_init(error_chain_t* chain) {
    #####: 1127:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1128:    
    #####: 1129:    chain->head = NULL;
    #####: 1130:    chain->count = 0;
        -: 1131:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####: 1126:void error_chain_init(error_chain_t* chain) {
    #####: 1127:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1128:    
    #####: 1129:    chain->head = NULL;
    #####: 1130:    chain->count = 0;
        -: 1131:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####: 1126:void error_chain_init(error_chain_t* chain) {
    #####: 1127:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1128:    
    #####: 1129:    chain->head = NULL;
    #####: 1130:    chain->count = 0;
        -: 1131:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####: 1126:void error_chain_init(error_chain_t* chain) {
    #####: 1127:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1128:    
    #####: 1129:    chain->head = NULL;
    #####: 1130:    chain->count = 0;
        -: 1131:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####: 1126:void error_chain_init(error_chain_t* chain) {
    #####: 1127:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1128:    
    #####: 1129:    chain->head = NULL;
    #####: 1130:    chain->count = 0;
        -: 1131:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####: 1126:void error_chain_init(error_chain_t* chain) {
    #####: 1127:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1128:    
    #####: 1129:    chain->head = NULL;
    #####: 1130:    chain->count = 0;
        -: 1131:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####: 1126:void error_chain_init(error_chain_t* chain) {
    #####: 1127:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1128:    
    #####: 1129:    chain->head = NULL;
    #####: 1130:    chain->count = 0;
        -: 1131:}
------------------
error_chain_init:
function error_chain_init called 0 returned 0% blocks executed 0%
    #####: 1126:void error_chain_init(error_chain_t* chain) {
    #####: 1127:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1128:    
    #####: 1129:    chain->head = NULL;
    #####: 1130:    chain->count = 0;
        -: 1131:}
------------------
        -: 1132:
    #####: 1133:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####: 1134:    if (!chain || !format) return;
        -: 1135:    
    #####: 1136:    error_node_t* node = malloc(sizeof(error_node_t));
    #####: 1137:    if (!node) return;
        -: 1138:    
    #####: 1139:    node->code = code;
        -: 1140:    
        -: 1141:    va_list args;
    #####: 1142:    va_start(args, format);
    #####: 1143:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####: 1144:    va_end(args);
        -: 1145:    
        -: 1146:    // Add to head (LIFO)
    #####: 1147:    node->next = chain->head;
    #####: 1148:    chain->head = node;
    #####: 1149:    chain->count++;
        -: 1150:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####: 1133:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####: 1134:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -: 1135:    
    #####: 1136:    error_node_t* node = malloc(sizeof(error_node_t));
    #####: 1137:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -: 1138:    
    #####: 1139:    node->code = code;
        -: 1140:    
        -: 1141:    va_list args;
    #####: 1142:    va_start(args, format);
    #####: 1143:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####: 1144:    va_end(args);
        -: 1145:    
        -: 1146:    // Add to head (LIFO)
    #####: 1147:    node->next = chain->head;
    #####: 1148:    chain->head = node;
    #####: 1149:    chain->count++;
        -: 1150:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####: 1133:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####: 1134:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -: 1135:    
    #####: 1136:    error_node_t* node = malloc(sizeof(error_node_t));
    #####: 1137:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -: 1138:    
    #####: 1139:    node->code = code;
        -: 1140:    
        -: 1141:    va_list args;
    #####: 1142:    va_start(args, format);
    #####: 1143:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####: 1144:    va_end(args);
        -: 1145:    
        -: 1146:    // Add to head (LIFO)
    #####: 1147:    node->next = chain->head;
    #####: 1148:    chain->head = node;
    #####: 1149:    chain->count++;
        -: 1150:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####: 1133:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####: 1134:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -: 1135:    
    #####: 1136:    error_node_t* node = malloc(sizeof(error_node_t));
    #####: 1137:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -: 1138:    
    #####: 1139:    node->code = code;
        -: 1140:    
        -: 1141:    va_list args;
    #####: 1142:    va_start(args, format);
    #####: 1143:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####: 1144:    va_end(args);
        -: 1145:    
        -: 1146:    // Add to head (LIFO)
    #####: 1147:    node->next = chain->head;
    #####: 1148:    chain->head = node;
    #####: 1149:    chain->count++;
        -: 1150:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####: 1133:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####: 1134:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -: 1135:    
    #####: 1136:    error_node_t* node = malloc(sizeof(error_node_t));
    #####: 1137:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -: 1138:    
    #####: 1139:    node->code = code;
        -: 1140:    
        -: 1141:    va_list args;
    #####: 1142:    va_start(args, format);
    #####: 1143:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####: 1144:    va_end(args);
        -: 1145:    
        -: 1146:    // Add to head (LIFO)
    #####: 1147:    node->next = chain->head;
    #####: 1148:    chain->head = node;
    #####: 1149:    chain->count++;
        -: 1150:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####: 1133:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####: 1134:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -: 1135:    
    #####: 1136:    error_node_t* node = malloc(sizeof(error_node_t));
    #####: 1137:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -: 1138:    
    #####: 1139:    node->code = code;
        -: 1140:    
        -: 1141:    va_list args;
    #####: 1142:    va_start(args, format);
    #####: 1143:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####: 1144:    va_end(args);
        -: 1145:    
        -: 1146:    // Add to head (LIFO)
    #####: 1147:    node->next = chain->head;
    #####: 1148:    chain->head = node;
    #####: 1149:    chain->count++;
        -: 1150:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####: 1133:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####: 1134:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -: 1135:    
    #####: 1136:    error_node_t* node = malloc(sizeof(error_node_t));
    #####: 1137:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -: 1138:    
    #####: 1139:    node->code = code;
        -: 1140:    
        -: 1141:    va_list args;
    #####: 1142:    va_start(args, format);
    #####: 1143:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####: 1144:    va_end(args);
        -: 1145:    
        -: 1146:    // Add to head (LIFO)
    #####: 1147:    node->next = chain->head;
    #####: 1148:    chain->head = node;
    #####: 1149:    chain->count++;
        -: 1150:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####: 1133:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####: 1134:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -: 1135:    
    #####: 1136:    error_node_t* node = malloc(sizeof(error_node_t));
    #####: 1137:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -: 1138:    
    #####: 1139:    node->code = code;
        -: 1140:    
        -: 1141:    va_list args;
    #####: 1142:    va_start(args, format);
    #####: 1143:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####: 1144:    va_end(args);
        -: 1145:    
        -: 1146:    // Add to head (LIFO)
    #####: 1147:    node->next = chain->head;
    #####: 1148:    chain->head = node;
    #####: 1149:    chain->count++;
        -: 1150:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####: 1133:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####: 1134:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -: 1135:    
    #####: 1136:    error_node_t* node = malloc(sizeof(error_node_t));
    #####: 1137:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -: 1138:    
    #####: 1139:    node->code = code;
        -: 1140:    
        -: 1141:    va_list args;
    #####: 1142:    va_start(args, format);
    #####: 1143:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####: 1144:    va_end(args);
        -: 1145:    
        -: 1146:    // Add to head (LIFO)
    #####: 1147:    node->next = chain->head;
    #####: 1148:    chain->head = node;
    #####: 1149:    chain->count++;
        -: 1150:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####: 1133:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####: 1134:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -: 1135:    
    #####: 1136:    error_node_t* node = malloc(sizeof(error_node_t));
    #####: 1137:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -: 1138:    
    #####: 1139:    node->code = code;
        -: 1140:    
        -: 1141:    va_list args;
    #####: 1142:    va_start(args, format);
    #####: 1143:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####: 1144:    va_end(args);
        -: 1145:    
        -: 1146:    // Add to head (LIFO)
    #####: 1147:    node->next = chain->head;
    #####: 1148:    chain->head = node;
    #####: 1149:    chain->count++;
        -: 1150:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####: 1133:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####: 1134:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -: 1135:    
    #####: 1136:    error_node_t* node = malloc(sizeof(error_node_t));
    #####: 1137:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -: 1138:    
    #####: 1139:    node->code = code;
        -: 1140:    
        -: 1141:    va_list args;
    #####: 1142:    va_start(args, format);
    #####: 1143:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####: 1144:    va_end(args);
        -: 1145:    
        -: 1146:    // Add to head (LIFO)
    #####: 1147:    node->next = chain->head;
    #####: 1148:    chain->head = node;
    #####: 1149:    chain->count++;
        -: 1150:}
------------------
error_chain_add:
function error_chain_add called 0 returned 0% blocks executed 0%
    #####: 1133:void error_chain_add(error_chain_t* chain, int code, const char* format, ...) {
    #####: 1134:    if (!chain || !format) return;
branch  0 never executed
branch  1 never executed
        -: 1135:    
    #####: 1136:    error_node_t* node = malloc(sizeof(error_node_t));
    #####: 1137:    if (!node) return;
branch  0 never executed
branch  1 never executed
        -: 1138:    
    #####: 1139:    node->code = code;
        -: 1140:    
        -: 1141:    va_list args;
    #####: 1142:    va_start(args, format);
    #####: 1143:    vsnprintf(node->message, sizeof(node->message), format, args);
    #####: 1144:    va_end(args);
        -: 1145:    
        -: 1146:    // Add to head (LIFO)
    #####: 1147:    node->next = chain->head;
    #####: 1148:    chain->head = node;
    #####: 1149:    chain->count++;
        -: 1150:}
------------------
        -: 1151:
    #####: 1152:void error_chain_destroy(error_chain_t* chain) {
    #####: 1153:    if (!chain) return;
        -: 1154:    
    #####: 1155:    error_node_t* node = chain->head;
    #####: 1156:    while (node) {
    #####: 1157:        error_node_t* next = node->next;
    #####: 1158:        free(node);
        -: 1159:        node = next;
        -: 1160:    }
        -: 1161:    
    #####: 1162:    chain->head = NULL;
    #####: 1163:    chain->count = 0;
        -: 1164:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####: 1152:void error_chain_destroy(error_chain_t* chain) {
    #####: 1153:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1154:    
    #####: 1155:    error_node_t* node = chain->head;
    #####: 1156:    while (node) {
branch  0 never executed
branch  1 never executed
    #####: 1157:        error_node_t* next = node->next;
    #####: 1158:        free(node);
        -: 1159:        node = next;
        -: 1160:    }
        -: 1161:    
    #####: 1162:    chain->head = NULL;
    #####: 1163:    chain->count = 0;
        -: 1164:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####: 1152:void error_chain_destroy(error_chain_t* chain) {
    #####: 1153:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1154:    
    #####: 1155:    error_node_t* node = chain->head;
    #####: 1156:    while (node) {
branch  0 never executed
branch  1 never executed
    #####: 1157:        error_node_t* next = node->next;
    #####: 1158:        free(node);
        -: 1159:        node = next;
        -: 1160:    }
        -: 1161:    
    #####: 1162:    chain->head = NULL;
    #####: 1163:    chain->count = 0;
        -: 1164:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####: 1152:void error_chain_destroy(error_chain_t* chain) {
    #####: 1153:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1154:    
    #####: 1155:    error_node_t* node = chain->head;
    #####: 1156:    while (node) {
branch  0 never executed
branch  1 never executed
    #####: 1157:        error_node_t* next = node->next;
    #####: 1158:        free(node);
        -: 1159:        node = next;
        -: 1160:    }
        -: 1161:    
    #####: 1162:    chain->head = NULL;
    #####: 1163:    chain->count = 0;
        -: 1164:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####: 1152:void error_chain_destroy(error_chain_t* chain) {
    #####: 1153:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1154:    
    #####: 1155:    error_node_t* node = chain->head;
    #####: 1156:    while (node) {
branch  0 never executed
branch  1 never executed
    #####: 1157:        error_node_t* next = node->next;
    #####: 1158:        free(node);
        -: 1159:        node = next;
        -: 1160:    }
        -: 1161:    
    #####: 1162:    chain->head = NULL;
    #####: 1163:    chain->count = 0;
        -: 1164:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####: 1152:void error_chain_destroy(error_chain_t* chain) {
    #####: 1153:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1154:    
    #####: 1155:    error_node_t* node = chain->head;
    #####: 1156:    while (node) {
branch  0 never executed
branch  1 never executed
    #####: 1157:        error_node_t* next = node->next;
    #####: 1158:        free(node);
        -: 1159:        node = next;
        -: 1160:    }
        -: 1161:    
    #####: 1162:    chain->head = NULL;
    #####: 1163:    chain->count = 0;
        -: 1164:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####: 1152:void error_chain_destroy(error_chain_t* chain) {
    #####: 1153:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1154:    
    #####: 1155:    error_node_t* node = chain->head;
    #####: 1156:    while (node) {
branch  0 never executed
branch  1 never executed
    #####: 1157:        error_node_t* next = node->next;
    #####: 1158:        free(node);
        -: 1159:        node = next;
        -: 1160:    }
        -: 1161:    
    #####: 1162:    chain->head = NULL;
    #####: 1163:    chain->count = 0;
        -: 1164:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####: 1152:void error_chain_destroy(error_chain_t* chain) {
    #####: 1153:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1154:    
    #####: 1155:    error_node_t* node = chain->head;
    #####: 1156:    while (node) {
branch  0 never executed
branch  1 never executed
    #####: 1157:        error_node_t* next = node->next;
    #####: 1158:        free(node);
        -: 1159:        node = next;
        -: 1160:    }
        -: 1161:    
    #####: 1162:    chain->head = NULL;
    #####: 1163:    chain->count = 0;
        -: 1164:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####: 1152:void error_chain_destroy(error_chain_t* chain) {
    #####: 1153:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1154:    
    #####: 1155:    error_node_t* node = chain->head;
    #####: 1156:    while (node) {
branch  0 never executed
branch  1 never executed
    #####: 1157:        error_node_t* next = node->next;
    #####: 1158:        free(node);
        -: 1159:        node = next;
        -: 1160:    }
        -: 1161:    
    #####: 1162:    chain->head = NULL;
    #####: 1163:    chain->count = 0;
        -: 1164:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####: 1152:void error_chain_destroy(error_chain_t* chain) {
    #####: 1153:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1154:    
    #####: 1155:    error_node_t* node = chain->head;
    #####: 1156:    while (node) {
branch  0 never executed
branch  1 never executed
    #####: 1157:        error_node_t* next = node->next;
    #####: 1158:        free(node);
        -: 1159:        node = next;
        -: 1160:    }
        -: 1161:    
    #####: 1162:    chain->head = NULL;
    #####: 1163:    chain->count = 0;
        -: 1164:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####: 1152:void error_chain_destroy(error_chain_t* chain) {
    #####: 1153:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1154:    
    #####: 1155:    error_node_t* node = chain->head;
    #####: 1156:    while (node) {
branch  0 never executed
branch  1 never executed
    #####: 1157:        error_node_t* next = node->next;
    #####: 1158:        free(node);
        -: 1159:        node = next;
        -: 1160:    }
        -: 1161:    
    #####: 1162:    chain->head = NULL;
    #####: 1163:    chain->count = 0;
        -: 1164:}
------------------
error_chain_destroy:
function error_chain_destroy called 0 returned 0% blocks executed 0%
    #####: 1152:void error_chain_destroy(error_chain_t* chain) {
    #####: 1153:    if (!chain) return;
branch  0 never executed
branch  1 never executed
        -: 1154:    
    #####: 1155:    error_node_t* node = chain->head;
    #####: 1156:    while (node) {
branch  0 never executed
branch  1 never executed
    #####: 1157:        error_node_t* next = node->next;
    #####: 1158:        free(node);
        -: 1159:        node = next;
        -: 1160:    }
        -: 1161:    
    #####: 1162:    chain->head = NULL;
    #####: 1163:    chain->count = 0;
        -: 1164:}
------------------
        -: 1165:
        -: 1166:// === SIMD OPTIMIZED OPERATIONS ===
        -: 1167:
        -: 1168:#ifdef USE_SIMD
      25*: 1169:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
      25*: 1170:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
        -: 1171:        return;
        -: 1172:    }
        -: 1173:    
        -: 1174:    char* d = (char*)dest;
        -: 1175:    const char* s = (const char*)src;
        -: 1176:    
        -: 1177:    // For small sizes, use regular memcpy
      22*: 1178:    if (MERCURY_UNLIKELY(size < 32)) {
        -: 1179:        memcpy(dest, src, size);
    #####: 1180:        return;
        -: 1181:    }
        -: 1182:    
        -: 1183:    // AVX2 implementation for 256-bit (32-byte) chunks
      22*: 1184:    size_t avx_chunks = size / 32;
      22*: 1185:    size_t remainder = size % 32;
        -: 1186:    
    1627*: 1187:    for (size_t i = 0; i < avx_chunks; i++) {
    1605*: 1188:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    1605*: 1189:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -: 1190:    }
        -: 1191:    
        -: 1192:    // Handle remainder with regular memcpy
      22*: 1193:    if (remainder > 0) {
      19*: 1194:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -: 1195:    }
        -: 1196:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 0 returned 0% blocks executed 0%
    #####: 1169:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    #####: 1170:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1171:        return;
        -: 1172:    }
        -: 1173:    
        -: 1174:    char* d = (char*)dest;
        -: 1175:    const char* s = (const char*)src;
        -: 1176:    
        -: 1177:    // For small sizes, use regular memcpy
    #####: 1178:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 never executed
branch  1 never executed
        -: 1179:        memcpy(dest, src, size);
    #####: 1180:        return;
        -: 1181:    }
        -: 1182:    
        -: 1183:    // AVX2 implementation for 256-bit (32-byte) chunks
    #####: 1184:    size_t avx_chunks = size / 32;
    #####: 1185:    size_t remainder = size % 32;
        -: 1186:    
    #####: 1187:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1188:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    #####: 1189:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -: 1190:    }
        -: 1191:    
        -: 1192:    // Handle remainder with regular memcpy
    #####: 1193:    if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1194:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -: 1195:    }
        -: 1196:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 15 returned 100% blocks executed 90%
       15: 1169:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
       15: 1170:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 1171:        return;
        -: 1172:    }
        -: 1173:    
        -: 1174:    char* d = (char*)dest;
        -: 1175:    const char* s = (const char*)src;
        -: 1176:    
        -: 1177:    // For small sizes, use regular memcpy
       15: 1178:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1179:        memcpy(dest, src, size);
    #####: 1180:        return;
        -: 1181:    }
        -: 1182:    
        -: 1183:    // AVX2 implementation for 256-bit (32-byte) chunks
       15: 1184:    size_t avx_chunks = size / 32;
       15: 1185:    size_t remainder = size % 32;
        -: 1186:    
     1600: 1187:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
     1585: 1188:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
     1585: 1189:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -: 1190:    }
        -: 1191:    
        -: 1192:    // Handle remainder with regular memcpy
       15: 1193:    if (remainder > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       15: 1194:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -: 1195:    }
        -: 1196:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 0 returned 0% blocks executed 0%
    #####: 1169:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    #####: 1170:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1171:        return;
        -: 1172:    }
        -: 1173:    
        -: 1174:    char* d = (char*)dest;
        -: 1175:    const char* s = (const char*)src;
        -: 1176:    
        -: 1177:    // For small sizes, use regular memcpy
    #####: 1178:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 never executed
branch  1 never executed
        -: 1179:        memcpy(dest, src, size);
    #####: 1180:        return;
        -: 1181:    }
        -: 1182:    
        -: 1183:    // AVX2 implementation for 256-bit (32-byte) chunks
    #####: 1184:    size_t avx_chunks = size / 32;
    #####: 1185:    size_t remainder = size % 32;
        -: 1186:    
    #####: 1187:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1188:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    #####: 1189:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -: 1190:    }
        -: 1191:    
        -: 1192:    // Handle remainder with regular memcpy
    #####: 1193:    if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1194:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -: 1195:    }
        -: 1196:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 7 returned 100% blocks executed 90%
        7: 1169:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
        7: 1170:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
branch  2 taken 80% (fallthrough)
branch  3 taken 20%
        -: 1171:        return;
        -: 1172:    }
        -: 1173:    
        -: 1174:    char* d = (char*)dest;
        -: 1175:    const char* s = (const char*)src;
        -: 1176:    
        -: 1177:    // For small sizes, use regular memcpy
        4: 1178:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1179:        memcpy(dest, src, size);
    #####: 1180:        return;
        -: 1181:    }
        -: 1182:    
        -: 1183:    // AVX2 implementation for 256-bit (32-byte) chunks
        4: 1184:    size_t avx_chunks = size / 32;
        4: 1185:    size_t remainder = size % 32;
        -: 1186:    
       18: 1187:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 taken 78%
branch  1 taken 22% (fallthrough)
       14: 1188:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
       14: 1189:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -: 1190:    }
        -: 1191:    
        -: 1192:    // Handle remainder with regular memcpy
        4: 1193:    if (remainder > 0) {
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        1: 1194:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -: 1195:    }
        -: 1196:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 0 returned 0% blocks executed 0%
    #####: 1169:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    #####: 1170:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1171:        return;
        -: 1172:    }
        -: 1173:    
        -: 1174:    char* d = (char*)dest;
        -: 1175:    const char* s = (const char*)src;
        -: 1176:    
        -: 1177:    // For small sizes, use regular memcpy
    #####: 1178:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 never executed
branch  1 never executed
        -: 1179:        memcpy(dest, src, size);
    #####: 1180:        return;
        -: 1181:    }
        -: 1182:    
        -: 1183:    // AVX2 implementation for 256-bit (32-byte) chunks
    #####: 1184:    size_t avx_chunks = size / 32;
    #####: 1185:    size_t remainder = size % 32;
        -: 1186:    
    #####: 1187:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1188:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    #####: 1189:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -: 1190:    }
        -: 1191:    
        -: 1192:    // Handle remainder with regular memcpy
    #####: 1193:    if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1194:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -: 1195:    }
        -: 1196:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 0 returned 0% blocks executed 0%
    #####: 1169:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    #####: 1170:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1171:        return;
        -: 1172:    }
        -: 1173:    
        -: 1174:    char* d = (char*)dest;
        -: 1175:    const char* s = (const char*)src;
        -: 1176:    
        -: 1177:    // For small sizes, use regular memcpy
    #####: 1178:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 never executed
branch  1 never executed
        -: 1179:        memcpy(dest, src, size);
    #####: 1180:        return;
        -: 1181:    }
        -: 1182:    
        -: 1183:    // AVX2 implementation for 256-bit (32-byte) chunks
    #####: 1184:    size_t avx_chunks = size / 32;
    #####: 1185:    size_t remainder = size % 32;
        -: 1186:    
    #####: 1187:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1188:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    #####: 1189:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -: 1190:    }
        -: 1191:    
        -: 1192:    // Handle remainder with regular memcpy
    #####: 1193:    if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1194:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -: 1195:    }
        -: 1196:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 1 returned 100% blocks executed 90%
        1: 1169:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
        1: 1170:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 1171:        return;
        -: 1172:    }
        -: 1173:    
        -: 1174:    char* d = (char*)dest;
        -: 1175:    const char* s = (const char*)src;
        -: 1176:    
        -: 1177:    // For small sizes, use regular memcpy
        1: 1178:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1179:        memcpy(dest, src, size);
    #####: 1180:        return;
        -: 1181:    }
        -: 1182:    
        -: 1183:    // AVX2 implementation for 256-bit (32-byte) chunks
        1: 1184:    size_t avx_chunks = size / 32;
        1: 1185:    size_t remainder = size % 32;
        -: 1186:    
        3: 1187:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        2: 1188:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
        2: 1189:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -: 1190:    }
        -: 1191:    
        -: 1192:    // Handle remainder with regular memcpy
        1: 1193:    if (remainder > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1: 1194:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -: 1195:    }
        -: 1196:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 2 returned 100% blocks executed 90%
        2: 1169:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
        2: 1170:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 1171:        return;
        -: 1172:    }
        -: 1173:    
        -: 1174:    char* d = (char*)dest;
        -: 1175:    const char* s = (const char*)src;
        -: 1176:    
        -: 1177:    // For small sizes, use regular memcpy
        2: 1178:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1179:        memcpy(dest, src, size);
    #####: 1180:        return;
        -: 1181:    }
        -: 1182:    
        -: 1183:    // AVX2 implementation for 256-bit (32-byte) chunks
        2: 1184:    size_t avx_chunks = size / 32;
        2: 1185:    size_t remainder = size % 32;
        -: 1186:    
        6: 1187:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        4: 1188:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
        4: 1189:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -: 1190:    }
        -: 1191:    
        -: 1192:    // Handle remainder with regular memcpy
        2: 1193:    if (remainder > 0) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2: 1194:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -: 1195:    }
        -: 1196:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 0 returned 0% blocks executed 0%
    #####: 1169:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    #####: 1170:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1171:        return;
        -: 1172:    }
        -: 1173:    
        -: 1174:    char* d = (char*)dest;
        -: 1175:    const char* s = (const char*)src;
        -: 1176:    
        -: 1177:    // For small sizes, use regular memcpy
    #####: 1178:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 never executed
branch  1 never executed
        -: 1179:        memcpy(dest, src, size);
    #####: 1180:        return;
        -: 1181:    }
        -: 1182:    
        -: 1183:    // AVX2 implementation for 256-bit (32-byte) chunks
    #####: 1184:    size_t avx_chunks = size / 32;
    #####: 1185:    size_t remainder = size % 32;
        -: 1186:    
    #####: 1187:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1188:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    #####: 1189:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -: 1190:    }
        -: 1191:    
        -: 1192:    // Handle remainder with regular memcpy
    #####: 1193:    if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1194:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -: 1195:    }
        -: 1196:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 0 returned 0% blocks executed 0%
    #####: 1169:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    #####: 1170:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1171:        return;
        -: 1172:    }
        -: 1173:    
        -: 1174:    char* d = (char*)dest;
        -: 1175:    const char* s = (const char*)src;
        -: 1176:    
        -: 1177:    // For small sizes, use regular memcpy
    #####: 1178:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 never executed
branch  1 never executed
        -: 1179:        memcpy(dest, src, size);
    #####: 1180:        return;
        -: 1181:    }
        -: 1182:    
        -: 1183:    // AVX2 implementation for 256-bit (32-byte) chunks
    #####: 1184:    size_t avx_chunks = size / 32;
    #####: 1185:    size_t remainder = size % 32;
        -: 1186:    
    #####: 1187:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1188:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    #####: 1189:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -: 1190:    }
        -: 1191:    
        -: 1192:    // Handle remainder with regular memcpy
    #####: 1193:    if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1194:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -: 1195:    }
        -: 1196:}
------------------
mercury_memcpy_simd:
function mercury_memcpy_simd called 0 returned 0% blocks executed 0%
    #####: 1169:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
    #####: 1170:    if (MERCURY_UNLIKELY(!dest || !src || size == 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1171:        return;
        -: 1172:    }
        -: 1173:    
        -: 1174:    char* d = (char*)dest;
        -: 1175:    const char* s = (const char*)src;
        -: 1176:    
        -: 1177:    // For small sizes, use regular memcpy
    #####: 1178:    if (MERCURY_UNLIKELY(size < 32)) {
branch  0 never executed
branch  1 never executed
        -: 1179:        memcpy(dest, src, size);
    #####: 1180:        return;
        -: 1181:    }
        -: 1182:    
        -: 1183:    // AVX2 implementation for 256-bit (32-byte) chunks
    #####: 1184:    size_t avx_chunks = size / 32;
    #####: 1185:    size_t remainder = size % 32;
        -: 1186:    
    #####: 1187:    for (size_t i = 0; i < avx_chunks; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1188:        __m256i data = _mm256_loadu_si256((const __m256i*)(s + i * 32));
    #####: 1189:        _mm256_storeu_si256((__m256i*)(d + i * 32), data);
        -: 1190:    }
        -: 1191:    
        -: 1192:    // Handle remainder with regular memcpy
    #####: 1193:    if (remainder > 0) {
branch  0 never executed
branch  1 never executed
    #####: 1194:        memcpy(d + avx_chunks * 32, s + avx_chunks * 32, remainder);
        -: 1195:    }
        -: 1196:}
------------------
        -: 1197:
        -: 1198:// SIMD-accelerated string search (Boyer-Moore style)
    #####: 1199:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1200:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
        -: 1201:        return -1;
        -: 1202:    }
        -: 1203:    
        -: 1204:    // For small patterns, use regular strstr
    #####: 1205:    if (pattern_len < 4) {
    #####: 1206:        const char* found = strstr(text, pattern);
    #####: 1207:        return found ? (int)(found - text) : -1;
        -: 1208:    }
        -: 1209:    
        -: 1210:    // Use SIMD for searching the first character of pattern
    #####: 1211:    const char first_char = pattern[0];
        -: 1212:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1213:    
    #####: 1214:    size_t max_pos = text_len - pattern_len;
        -: 1215:    size_t pos = 0;
        -: 1216:    
        -: 1217:    // SIMD scan for potential matches
    #####: 1218:    while (pos <= max_pos) {
    #####: 1219:        if (pos + 32 <= text_len) {
        -: 1220:            // Prefetch next chunk for sequential scanning
    #####: 1221:            if (pos + 64 <= text_len) {
    #####: 1222:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
        -: 1223:            }
        -: 1224:            
        -: 1225:            // Load 32 characters from text
    #####: 1226:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1227:            
        -: 1228:            // Compare with first character
        -: 1229:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1230:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1231:            
        -: 1232:            // Check each potential match
    #####: 1233:            while (match_mask != 0) {
    #####: 1234:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1235:                size_t match_pos = pos + bit_pos;
        -: 1236:                
    #####: 1237:                if (match_pos <= max_pos) {
        -: 1238:                    // Prefetch the potential match location
    #####: 1239:                    MERCURY_PREFETCH_READ(text + match_pos);
        -: 1240:                    
        -: 1241:                    // Verify full pattern match
    #####: 1242:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
    #####: 1243:                        return (int)match_pos;
        -: 1244:                    }
        -: 1245:                }
        -: 1246:                
    #####: 1247:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1248:            }
        -: 1249:            
        -: 1250:            pos += 32;
        -: 1251:        } else {
        -: 1252:            // Handle remainder with regular search
    #####: 1253:            const char* found = strstr(text + pos, pattern);
    #####: 1254:            return found ? (int)(found - text) : -1;
        -: 1255:        }
        -: 1256:    }
        -: 1257:    
        -: 1258:    return -1;  // Not found
        -: 1259:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1199:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1200:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1201:        return -1;
        -: 1202:    }
        -: 1203:    
        -: 1204:    // For small patterns, use regular strstr
    #####: 1205:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1206:        const char* found = strstr(text, pattern);
    #####: 1207:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1208:    }
        -: 1209:    
        -: 1210:    // Use SIMD for searching the first character of pattern
    #####: 1211:    const char first_char = pattern[0];
        -: 1212:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1213:    
    #####: 1214:    size_t max_pos = text_len - pattern_len;
        -: 1215:    size_t pos = 0;
        -: 1216:    
        -: 1217:    // SIMD scan for potential matches
    #####: 1218:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1219:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1220:            // Prefetch next chunk for sequential scanning
    #####: 1221:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1222:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1223:            }
        -: 1224:            
        -: 1225:            // Load 32 characters from text
    #####: 1226:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1227:            
        -: 1228:            // Compare with first character
        -: 1229:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1230:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1231:            
        -: 1232:            // Check each potential match
    #####: 1233:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1234:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1235:                size_t match_pos = pos + bit_pos;
        -: 1236:                
    #####: 1237:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1238:                    // Prefetch the potential match location
    #####: 1239:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1240:                    
        -: 1241:                    // Verify full pattern match
    #####: 1242:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1243:                        return (int)match_pos;
        -: 1244:                    }
        -: 1245:                }
        -: 1246:                
    #####: 1247:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1248:            }
        -: 1249:            
        -: 1250:            pos += 32;
        -: 1251:        } else {
        -: 1252:            // Handle remainder with regular search
    #####: 1253:            const char* found = strstr(text + pos, pattern);
    #####: 1254:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1255:        }
        -: 1256:    }
        -: 1257:    
        -: 1258:    return -1;  // Not found
        -: 1259:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1199:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1200:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1201:        return -1;
        -: 1202:    }
        -: 1203:    
        -: 1204:    // For small patterns, use regular strstr
    #####: 1205:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1206:        const char* found = strstr(text, pattern);
    #####: 1207:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1208:    }
        -: 1209:    
        -: 1210:    // Use SIMD for searching the first character of pattern
    #####: 1211:    const char first_char = pattern[0];
        -: 1212:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1213:    
    #####: 1214:    size_t max_pos = text_len - pattern_len;
        -: 1215:    size_t pos = 0;
        -: 1216:    
        -: 1217:    // SIMD scan for potential matches
    #####: 1218:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1219:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1220:            // Prefetch next chunk for sequential scanning
    #####: 1221:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1222:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1223:            }
        -: 1224:            
        -: 1225:            // Load 32 characters from text
    #####: 1226:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1227:            
        -: 1228:            // Compare with first character
        -: 1229:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1230:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1231:            
        -: 1232:            // Check each potential match
    #####: 1233:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1234:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1235:                size_t match_pos = pos + bit_pos;
        -: 1236:                
    #####: 1237:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1238:                    // Prefetch the potential match location
    #####: 1239:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1240:                    
        -: 1241:                    // Verify full pattern match
    #####: 1242:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1243:                        return (int)match_pos;
        -: 1244:                    }
        -: 1245:                }
        -: 1246:                
    #####: 1247:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1248:            }
        -: 1249:            
        -: 1250:            pos += 32;
        -: 1251:        } else {
        -: 1252:            // Handle remainder with regular search
    #####: 1253:            const char* found = strstr(text + pos, pattern);
    #####: 1254:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1255:        }
        -: 1256:    }
        -: 1257:    
        -: 1258:    return -1;  // Not found
        -: 1259:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1199:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1200:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1201:        return -1;
        -: 1202:    }
        -: 1203:    
        -: 1204:    // For small patterns, use regular strstr
    #####: 1205:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1206:        const char* found = strstr(text, pattern);
    #####: 1207:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1208:    }
        -: 1209:    
        -: 1210:    // Use SIMD for searching the first character of pattern
    #####: 1211:    const char first_char = pattern[0];
        -: 1212:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1213:    
    #####: 1214:    size_t max_pos = text_len - pattern_len;
        -: 1215:    size_t pos = 0;
        -: 1216:    
        -: 1217:    // SIMD scan for potential matches
    #####: 1218:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1219:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1220:            // Prefetch next chunk for sequential scanning
    #####: 1221:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1222:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1223:            }
        -: 1224:            
        -: 1225:            // Load 32 characters from text
    #####: 1226:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1227:            
        -: 1228:            // Compare with first character
        -: 1229:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1230:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1231:            
        -: 1232:            // Check each potential match
    #####: 1233:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1234:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1235:                size_t match_pos = pos + bit_pos;
        -: 1236:                
    #####: 1237:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1238:                    // Prefetch the potential match location
    #####: 1239:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1240:                    
        -: 1241:                    // Verify full pattern match
    #####: 1242:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1243:                        return (int)match_pos;
        -: 1244:                    }
        -: 1245:                }
        -: 1246:                
    #####: 1247:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1248:            }
        -: 1249:            
        -: 1250:            pos += 32;
        -: 1251:        } else {
        -: 1252:            // Handle remainder with regular search
    #####: 1253:            const char* found = strstr(text + pos, pattern);
    #####: 1254:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1255:        }
        -: 1256:    }
        -: 1257:    
        -: 1258:    return -1;  // Not found
        -: 1259:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1199:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1200:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1201:        return -1;
        -: 1202:    }
        -: 1203:    
        -: 1204:    // For small patterns, use regular strstr
    #####: 1205:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1206:        const char* found = strstr(text, pattern);
    #####: 1207:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1208:    }
        -: 1209:    
        -: 1210:    // Use SIMD for searching the first character of pattern
    #####: 1211:    const char first_char = pattern[0];
        -: 1212:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1213:    
    #####: 1214:    size_t max_pos = text_len - pattern_len;
        -: 1215:    size_t pos = 0;
        -: 1216:    
        -: 1217:    // SIMD scan for potential matches
    #####: 1218:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1219:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1220:            // Prefetch next chunk for sequential scanning
    #####: 1221:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1222:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1223:            }
        -: 1224:            
        -: 1225:            // Load 32 characters from text
    #####: 1226:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1227:            
        -: 1228:            // Compare with first character
        -: 1229:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1230:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1231:            
        -: 1232:            // Check each potential match
    #####: 1233:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1234:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1235:                size_t match_pos = pos + bit_pos;
        -: 1236:                
    #####: 1237:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1238:                    // Prefetch the potential match location
    #####: 1239:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1240:                    
        -: 1241:                    // Verify full pattern match
    #####: 1242:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1243:                        return (int)match_pos;
        -: 1244:                    }
        -: 1245:                }
        -: 1246:                
    #####: 1247:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1248:            }
        -: 1249:            
        -: 1250:            pos += 32;
        -: 1251:        } else {
        -: 1252:            // Handle remainder with regular search
    #####: 1253:            const char* found = strstr(text + pos, pattern);
    #####: 1254:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1255:        }
        -: 1256:    }
        -: 1257:    
        -: 1258:    return -1;  // Not found
        -: 1259:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1199:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1200:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1201:        return -1;
        -: 1202:    }
        -: 1203:    
        -: 1204:    // For small patterns, use regular strstr
    #####: 1205:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1206:        const char* found = strstr(text, pattern);
    #####: 1207:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1208:    }
        -: 1209:    
        -: 1210:    // Use SIMD for searching the first character of pattern
    #####: 1211:    const char first_char = pattern[0];
        -: 1212:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1213:    
    #####: 1214:    size_t max_pos = text_len - pattern_len;
        -: 1215:    size_t pos = 0;
        -: 1216:    
        -: 1217:    // SIMD scan for potential matches
    #####: 1218:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1219:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1220:            // Prefetch next chunk for sequential scanning
    #####: 1221:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1222:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1223:            }
        -: 1224:            
        -: 1225:            // Load 32 characters from text
    #####: 1226:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1227:            
        -: 1228:            // Compare with first character
        -: 1229:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1230:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1231:            
        -: 1232:            // Check each potential match
    #####: 1233:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1234:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1235:                size_t match_pos = pos + bit_pos;
        -: 1236:                
    #####: 1237:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1238:                    // Prefetch the potential match location
    #####: 1239:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1240:                    
        -: 1241:                    // Verify full pattern match
    #####: 1242:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1243:                        return (int)match_pos;
        -: 1244:                    }
        -: 1245:                }
        -: 1246:                
    #####: 1247:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1248:            }
        -: 1249:            
        -: 1250:            pos += 32;
        -: 1251:        } else {
        -: 1252:            // Handle remainder with regular search
    #####: 1253:            const char* found = strstr(text + pos, pattern);
    #####: 1254:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1255:        }
        -: 1256:    }
        -: 1257:    
        -: 1258:    return -1;  // Not found
        -: 1259:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1199:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1200:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1201:        return -1;
        -: 1202:    }
        -: 1203:    
        -: 1204:    // For small patterns, use regular strstr
    #####: 1205:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1206:        const char* found = strstr(text, pattern);
    #####: 1207:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1208:    }
        -: 1209:    
        -: 1210:    // Use SIMD for searching the first character of pattern
    #####: 1211:    const char first_char = pattern[0];
        -: 1212:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1213:    
    #####: 1214:    size_t max_pos = text_len - pattern_len;
        -: 1215:    size_t pos = 0;
        -: 1216:    
        -: 1217:    // SIMD scan for potential matches
    #####: 1218:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1219:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1220:            // Prefetch next chunk for sequential scanning
    #####: 1221:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1222:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1223:            }
        -: 1224:            
        -: 1225:            // Load 32 characters from text
    #####: 1226:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1227:            
        -: 1228:            // Compare with first character
        -: 1229:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1230:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1231:            
        -: 1232:            // Check each potential match
    #####: 1233:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1234:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1235:                size_t match_pos = pos + bit_pos;
        -: 1236:                
    #####: 1237:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1238:                    // Prefetch the potential match location
    #####: 1239:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1240:                    
        -: 1241:                    // Verify full pattern match
    #####: 1242:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1243:                        return (int)match_pos;
        -: 1244:                    }
        -: 1245:                }
        -: 1246:                
    #####: 1247:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1248:            }
        -: 1249:            
        -: 1250:            pos += 32;
        -: 1251:        } else {
        -: 1252:            // Handle remainder with regular search
    #####: 1253:            const char* found = strstr(text + pos, pattern);
    #####: 1254:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1255:        }
        -: 1256:    }
        -: 1257:    
        -: 1258:    return -1;  // Not found
        -: 1259:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1199:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1200:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1201:        return -1;
        -: 1202:    }
        -: 1203:    
        -: 1204:    // For small patterns, use regular strstr
    #####: 1205:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1206:        const char* found = strstr(text, pattern);
    #####: 1207:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1208:    }
        -: 1209:    
        -: 1210:    // Use SIMD for searching the first character of pattern
    #####: 1211:    const char first_char = pattern[0];
        -: 1212:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1213:    
    #####: 1214:    size_t max_pos = text_len - pattern_len;
        -: 1215:    size_t pos = 0;
        -: 1216:    
        -: 1217:    // SIMD scan for potential matches
    #####: 1218:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1219:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1220:            // Prefetch next chunk for sequential scanning
    #####: 1221:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1222:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1223:            }
        -: 1224:            
        -: 1225:            // Load 32 characters from text
    #####: 1226:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1227:            
        -: 1228:            // Compare with first character
        -: 1229:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1230:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1231:            
        -: 1232:            // Check each potential match
    #####: 1233:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1234:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1235:                size_t match_pos = pos + bit_pos;
        -: 1236:                
    #####: 1237:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1238:                    // Prefetch the potential match location
    #####: 1239:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1240:                    
        -: 1241:                    // Verify full pattern match
    #####: 1242:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1243:                        return (int)match_pos;
        -: 1244:                    }
        -: 1245:                }
        -: 1246:                
    #####: 1247:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1248:            }
        -: 1249:            
        -: 1250:            pos += 32;
        -: 1251:        } else {
        -: 1252:            // Handle remainder with regular search
    #####: 1253:            const char* found = strstr(text + pos, pattern);
    #####: 1254:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1255:        }
        -: 1256:    }
        -: 1257:    
        -: 1258:    return -1;  // Not found
        -: 1259:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1199:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1200:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1201:        return -1;
        -: 1202:    }
        -: 1203:    
        -: 1204:    // For small patterns, use regular strstr
    #####: 1205:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1206:        const char* found = strstr(text, pattern);
    #####: 1207:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1208:    }
        -: 1209:    
        -: 1210:    // Use SIMD for searching the first character of pattern
    #####: 1211:    const char first_char = pattern[0];
        -: 1212:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1213:    
    #####: 1214:    size_t max_pos = text_len - pattern_len;
        -: 1215:    size_t pos = 0;
        -: 1216:    
        -: 1217:    // SIMD scan for potential matches
    #####: 1218:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1219:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1220:            // Prefetch next chunk for sequential scanning
    #####: 1221:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1222:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1223:            }
        -: 1224:            
        -: 1225:            // Load 32 characters from text
    #####: 1226:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1227:            
        -: 1228:            // Compare with first character
        -: 1229:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1230:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1231:            
        -: 1232:            // Check each potential match
    #####: 1233:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1234:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1235:                size_t match_pos = pos + bit_pos;
        -: 1236:                
    #####: 1237:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1238:                    // Prefetch the potential match location
    #####: 1239:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1240:                    
        -: 1241:                    // Verify full pattern match
    #####: 1242:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1243:                        return (int)match_pos;
        -: 1244:                    }
        -: 1245:                }
        -: 1246:                
    #####: 1247:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1248:            }
        -: 1249:            
        -: 1250:            pos += 32;
        -: 1251:        } else {
        -: 1252:            // Handle remainder with regular search
    #####: 1253:            const char* found = strstr(text + pos, pattern);
    #####: 1254:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1255:        }
        -: 1256:    }
        -: 1257:    
        -: 1258:    return -1;  // Not found
        -: 1259:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1199:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1200:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1201:        return -1;
        -: 1202:    }
        -: 1203:    
        -: 1204:    // For small patterns, use regular strstr
    #####: 1205:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1206:        const char* found = strstr(text, pattern);
    #####: 1207:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1208:    }
        -: 1209:    
        -: 1210:    // Use SIMD for searching the first character of pattern
    #####: 1211:    const char first_char = pattern[0];
        -: 1212:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1213:    
    #####: 1214:    size_t max_pos = text_len - pattern_len;
        -: 1215:    size_t pos = 0;
        -: 1216:    
        -: 1217:    // SIMD scan for potential matches
    #####: 1218:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1219:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1220:            // Prefetch next chunk for sequential scanning
    #####: 1221:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1222:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1223:            }
        -: 1224:            
        -: 1225:            // Load 32 characters from text
    #####: 1226:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1227:            
        -: 1228:            // Compare with first character
        -: 1229:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1230:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1231:            
        -: 1232:            // Check each potential match
    #####: 1233:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1234:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1235:                size_t match_pos = pos + bit_pos;
        -: 1236:                
    #####: 1237:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1238:                    // Prefetch the potential match location
    #####: 1239:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1240:                    
        -: 1241:                    // Verify full pattern match
    #####: 1242:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1243:                        return (int)match_pos;
        -: 1244:                    }
        -: 1245:                }
        -: 1246:                
    #####: 1247:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1248:            }
        -: 1249:            
        -: 1250:            pos += 32;
        -: 1251:        } else {
        -: 1252:            // Handle remainder with regular search
    #####: 1253:            const char* found = strstr(text + pos, pattern);
    #####: 1254:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1255:        }
        -: 1256:    }
        -: 1257:    
        -: 1258:    return -1;  // Not found
        -: 1259:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1199:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1200:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1201:        return -1;
        -: 1202:    }
        -: 1203:    
        -: 1204:    // For small patterns, use regular strstr
    #####: 1205:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1206:        const char* found = strstr(text, pattern);
    #####: 1207:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1208:    }
        -: 1209:    
        -: 1210:    // Use SIMD for searching the first character of pattern
    #####: 1211:    const char first_char = pattern[0];
        -: 1212:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1213:    
    #####: 1214:    size_t max_pos = text_len - pattern_len;
        -: 1215:    size_t pos = 0;
        -: 1216:    
        -: 1217:    // SIMD scan for potential matches
    #####: 1218:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1219:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1220:            // Prefetch next chunk for sequential scanning
    #####: 1221:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1222:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1223:            }
        -: 1224:            
        -: 1225:            // Load 32 characters from text
    #####: 1226:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1227:            
        -: 1228:            // Compare with first character
        -: 1229:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1230:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1231:            
        -: 1232:            // Check each potential match
    #####: 1233:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1234:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1235:                size_t match_pos = pos + bit_pos;
        -: 1236:                
    #####: 1237:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1238:                    // Prefetch the potential match location
    #####: 1239:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1240:                    
        -: 1241:                    // Verify full pattern match
    #####: 1242:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1243:                        return (int)match_pos;
        -: 1244:                    }
        -: 1245:                }
        -: 1246:                
    #####: 1247:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1248:            }
        -: 1249:            
        -: 1250:            pos += 32;
        -: 1251:        } else {
        -: 1252:            // Handle remainder with regular search
    #####: 1253:            const char* found = strstr(text + pos, pattern);
    #####: 1254:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1255:        }
        -: 1256:    }
        -: 1257:    
        -: 1258:    return -1;  // Not found
        -: 1259:}
------------------
mercury_string_search_simd:
function mercury_string_search_simd called 0 returned 0% blocks executed 0%
    #####: 1199:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
    #####: 1200:    if (!text || !pattern || pattern_len == 0 || text_len < pattern_len) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1201:        return -1;
        -: 1202:    }
        -: 1203:    
        -: 1204:    // For small patterns, use regular strstr
    #####: 1205:    if (pattern_len < 4) {
branch  0 never executed
branch  1 never executed
    #####: 1206:        const char* found = strstr(text, pattern);
    #####: 1207:        return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1208:    }
        -: 1209:    
        -: 1210:    // Use SIMD for searching the first character of pattern
    #####: 1211:    const char first_char = pattern[0];
        -: 1212:    const __m256i first_chars = _mm256_set1_epi8(first_char);
        -: 1213:    
    #####: 1214:    size_t max_pos = text_len - pattern_len;
        -: 1215:    size_t pos = 0;
        -: 1216:    
        -: 1217:    // SIMD scan for potential matches
    #####: 1218:    while (pos <= max_pos) {
branch  0 never executed
branch  1 never executed
    #####: 1219:        if (pos + 32 <= text_len) {
branch  0 never executed
branch  1 never executed
        -: 1220:            // Prefetch next chunk for sequential scanning
    #####: 1221:            if (pos + 64 <= text_len) {
branch  0 never executed
branch  1 never executed
    #####: 1222:                MERCURY_PREFETCH_READ_LOW(text + pos + 64);
call    0 never executed
        -: 1223:            }
        -: 1224:            
        -: 1225:            // Load 32 characters from text
    #####: 1226:            __m256i text_chunk = _mm256_loadu_si256((const __m256i*)(text + pos));
        -: 1227:            
        -: 1228:            // Compare with first character
        -: 1229:            __m256i matches = _mm256_cmpeq_epi8(text_chunk, first_chars);
    #####: 1230:            uint32_t match_mask = _mm256_movemask_epi8(matches);
        -: 1231:            
        -: 1232:            // Check each potential match
    #####: 1233:            while (match_mask != 0) {
branch  0 never executed
branch  1 never executed
    #####: 1234:                int bit_pos = __builtin_ctz(match_mask);  // Count trailing zeros
    #####: 1235:                size_t match_pos = pos + bit_pos;
        -: 1236:                
    #####: 1237:                if (match_pos <= max_pos) {
branch  0 never executed
branch  1 never executed
        -: 1238:                    // Prefetch the potential match location
    #####: 1239:                    MERCURY_PREFETCH_READ(text + match_pos);
call    0 never executed
        -: 1240:                    
        -: 1241:                    // Verify full pattern match
    #####: 1242:                    if (memcmp(text + match_pos, pattern, pattern_len) == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1243:                        return (int)match_pos;
        -: 1244:                    }
        -: 1245:                }
        -: 1246:                
    #####: 1247:                match_mask &= (match_mask - 1);  // Clear lowest set bit
        -: 1248:            }
        -: 1249:            
        -: 1250:            pos += 32;
        -: 1251:        } else {
        -: 1252:            // Handle remainder with regular search
    #####: 1253:            const char* found = strstr(text + pos, pattern);
    #####: 1254:            return found ? (int)(found - text) : -1;
branch  0 never executed
branch  1 never executed
        -: 1255:        }
        -: 1256:    }
        -: 1257:    
        -: 1258:    return -1;  // Not found
        -: 1259:}
------------------
        -: 1260:
        -: 1261:// === MULTI-PATTERN SIMD SEARCH IMPLEMENTATION ===
        -: 1262:
       7*: 1263:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
       7*: 1264:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
       2*: 1265:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
       2*: 1266:        return NULL;
        -: 1267:    }
        -: 1268:    
       5*: 1269:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
       5*: 1270:    if (!mps) {
    #####: 1271:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1272:        return NULL;
        -: 1273:    }
        -: 1274:    
        -: 1275:    // Initialize structure
        -: 1276:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
       5*: 1277:    mps->pattern_count = count;
        -: 1278:    
        -: 1279:    // Copy patterns and build lookup tables
      38*: 1280:    for (size_t i = 0; i < count; i++) {
      33*: 1281:        if (!patterns[i]) {
    #####: 1282:            mercury_aligned_free(mps);
    #####: 1283:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1284:            return NULL;
        -: 1285:        }
        -: 1286:        
      33*: 1287:        size_t len = strlen(patterns[i]);
      33*: 1288:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
    #####: 1289:            mercury_aligned_free(mps);
    #####: 1290:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1291:            return NULL;
        -: 1292:        }
        -: 1293:        
        -: 1294:        // Copy pattern safely with bounds checking
        -: 1295:        #ifdef _MSC_VER
        -: 1296:        // Use Windows-safe version
        -: 1297:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1298:        #else
        -: 1299:        // POSIX version
        -: 1300:        #ifdef _MSC_VER
        -: 1301:        // Use Windows-safe version
        -: 1302:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1303:        #else
        -: 1304:        // POSIX version
      33*: 1305:        strncpy(mps->patterns[i], patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
      33*: 1306:        mps->patterns[i][MERCURY_MAX_PATTERN_LENGTH - 1] = '\0';  // Ensure null termination
        -: 1307:        #endif
        -: 1308:        #endif
      33*: 1309:        mps->pattern_lengths[i] = len;
      33*: 1310:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1311:        
        -: 1312:        // Update first character lookup table
      33*: 1313:        uint8_t first_char = (uint8_t)patterns[i][0];
      33*: 1314:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1315:    }
        -: 1316:    
        -: 1317:    return mps;
        -: 1318:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1263:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1264:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1265:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1266:        return NULL;
        -: 1267:    }
        -: 1268:    
    #####: 1269:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1270:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1271:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1272:        return NULL;
        -: 1273:    }
        -: 1274:    
        -: 1275:    // Initialize structure
        -: 1276:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1277:    mps->pattern_count = count;
        -: 1278:    
        -: 1279:    // Copy patterns and build lookup tables
    #####: 1280:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1281:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1282:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1283:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1284:            return NULL;
        -: 1285:        }
        -: 1286:        
    #####: 1287:        size_t len = strlen(patterns[i]);
    #####: 1288:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1289:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1290:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1291:            return NULL;
        -: 1292:        }
        -: 1293:        
        -: 1294:        // Copy pattern safely with bounds checking
        -: 1295:        #ifdef _MSC_VER
        -: 1296:        // Use Windows-safe version
        -: 1297:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1298:        #else
        -: 1299:        // POSIX version
        -: 1300:        #ifdef _MSC_VER
        -: 1301:        // Use Windows-safe version
        -: 1302:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1303:        #else
        -: 1304:        // POSIX version
    #####: 1305:        strncpy(mps->patterns[i], patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
    #####: 1306:        mps->patterns[i][MERCURY_MAX_PATTERN_LENGTH - 1] = '\0';  // Ensure null termination
        -: 1307:        #endif
        -: 1308:        #endif
    #####: 1309:        mps->pattern_lengths[i] = len;
    #####: 1310:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1311:        
        -: 1312:        // Update first character lookup table
    #####: 1313:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1314:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1315:    }
        -: 1316:    
        -: 1317:    return mps;
        -: 1318:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 5 returned 100% blocks executed 69%
        5: 1263:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
        5: 1264:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 taken 60% (fallthrough)
branch  1 taken 40%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        2: 1265:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
        2: 1266:        return NULL;
        -: 1267:    }
        -: 1268:    
        3: 1269:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 returned 100%
        3: 1270:    if (!mps) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1271:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1272:        return NULL;
        -: 1273:    }
        -: 1274:    
        -: 1275:    // Initialize structure
        -: 1276:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
        3: 1277:    mps->pattern_count = count;
        -: 1278:    
        -: 1279:    // Copy patterns and build lookup tables
       15: 1280:    for (size_t i = 0; i < count; i++) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
       12: 1281:        if (!patterns[i]) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1282:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1283:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1284:            return NULL;
        -: 1285:        }
        -: 1286:        
       12: 1287:        size_t len = strlen(patterns[i]);
       12: 1288:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1289:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1290:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1291:            return NULL;
        -: 1292:        }
        -: 1293:        
        -: 1294:        // Copy pattern safely with bounds checking
        -: 1295:        #ifdef _MSC_VER
        -: 1296:        // Use Windows-safe version
        -: 1297:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1298:        #else
        -: 1299:        // POSIX version
        -: 1300:        #ifdef _MSC_VER
        -: 1301:        // Use Windows-safe version
        -: 1302:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1303:        #else
        -: 1304:        // POSIX version
       12: 1305:        strncpy(mps->patterns[i], patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
       12: 1306:        mps->patterns[i][MERCURY_MAX_PATTERN_LENGTH - 1] = '\0';  // Ensure null termination
        -: 1307:        #endif
        -: 1308:        #endif
       12: 1309:        mps->pattern_lengths[i] = len;
       12: 1310:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1311:        
        -: 1312:        // Update first character lookup table
       12: 1313:        uint8_t first_char = (uint8_t)patterns[i][0];
       12: 1314:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1315:    }
        -: 1316:    
        -: 1317:    return mps;
        -: 1318:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1263:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1264:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1265:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1266:        return NULL;
        -: 1267:    }
        -: 1268:    
    #####: 1269:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1270:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1271:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1272:        return NULL;
        -: 1273:    }
        -: 1274:    
        -: 1275:    // Initialize structure
        -: 1276:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1277:    mps->pattern_count = count;
        -: 1278:    
        -: 1279:    // Copy patterns and build lookup tables
    #####: 1280:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1281:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1282:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1283:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1284:            return NULL;
        -: 1285:        }
        -: 1286:        
    #####: 1287:        size_t len = strlen(patterns[i]);
    #####: 1288:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1289:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1290:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1291:            return NULL;
        -: 1292:        }
        -: 1293:        
        -: 1294:        // Copy pattern safely with bounds checking
        -: 1295:        #ifdef _MSC_VER
        -: 1296:        // Use Windows-safe version
        -: 1297:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1298:        #else
        -: 1299:        // POSIX version
        -: 1300:        #ifdef _MSC_VER
        -: 1301:        // Use Windows-safe version
        -: 1302:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1303:        #else
        -: 1304:        // POSIX version
    #####: 1305:        strncpy(mps->patterns[i], patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
    #####: 1306:        mps->patterns[i][MERCURY_MAX_PATTERN_LENGTH - 1] = '\0';  // Ensure null termination
        -: 1307:        #endif
        -: 1308:        #endif
    #####: 1309:        mps->pattern_lengths[i] = len;
    #####: 1310:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1311:        
        -: 1312:        // Update first character lookup table
    #####: 1313:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1314:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1315:    }
        -: 1316:    
        -: 1317:    return mps;
        -: 1318:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 2 returned 100% blocks executed 62%
        2: 1263:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
        2: 1264:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
    #####: 1265:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1266:        return NULL;
        -: 1267:    }
        -: 1268:    
        2: 1269:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 returned 100%
        2: 1270:    if (!mps) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1271:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1272:        return NULL;
        -: 1273:    }
        -: 1274:    
        -: 1275:    // Initialize structure
        -: 1276:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
        2: 1277:    mps->pattern_count = count;
        -: 1278:    
        -: 1279:    // Copy patterns and build lookup tables
       23: 1280:    for (size_t i = 0; i < count; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
       21: 1281:        if (!patterns[i]) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1282:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1283:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1284:            return NULL;
        -: 1285:        }
        -: 1286:        
       21: 1287:        size_t len = strlen(patterns[i]);
       21: 1288:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1289:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1290:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1291:            return NULL;
        -: 1292:        }
        -: 1293:        
        -: 1294:        // Copy pattern safely with bounds checking
        -: 1295:        #ifdef _MSC_VER
        -: 1296:        // Use Windows-safe version
        -: 1297:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1298:        #else
        -: 1299:        // POSIX version
        -: 1300:        #ifdef _MSC_VER
        -: 1301:        // Use Windows-safe version
        -: 1302:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1303:        #else
        -: 1304:        // POSIX version
       21: 1305:        strncpy(mps->patterns[i], patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
       21: 1306:        mps->patterns[i][MERCURY_MAX_PATTERN_LENGTH - 1] = '\0';  // Ensure null termination
        -: 1307:        #endif
        -: 1308:        #endif
       21: 1309:        mps->pattern_lengths[i] = len;
       21: 1310:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1311:        
        -: 1312:        // Update first character lookup table
       21: 1313:        uint8_t first_char = (uint8_t)patterns[i][0];
       21: 1314:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1315:    }
        -: 1316:    
        -: 1317:    return mps;
        -: 1318:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1263:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1264:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1265:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1266:        return NULL;
        -: 1267:    }
        -: 1268:    
    #####: 1269:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1270:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1271:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1272:        return NULL;
        -: 1273:    }
        -: 1274:    
        -: 1275:    // Initialize structure
        -: 1276:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1277:    mps->pattern_count = count;
        -: 1278:    
        -: 1279:    // Copy patterns and build lookup tables
    #####: 1280:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1281:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1282:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1283:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1284:            return NULL;
        -: 1285:        }
        -: 1286:        
    #####: 1287:        size_t len = strlen(patterns[i]);
    #####: 1288:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1289:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1290:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1291:            return NULL;
        -: 1292:        }
        -: 1293:        
        -: 1294:        // Copy pattern safely with bounds checking
        -: 1295:        #ifdef _MSC_VER
        -: 1296:        // Use Windows-safe version
        -: 1297:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1298:        #else
        -: 1299:        // POSIX version
        -: 1300:        #ifdef _MSC_VER
        -: 1301:        // Use Windows-safe version
        -: 1302:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1303:        #else
        -: 1304:        // POSIX version
    #####: 1305:        strncpy(mps->patterns[i], patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
    #####: 1306:        mps->patterns[i][MERCURY_MAX_PATTERN_LENGTH - 1] = '\0';  // Ensure null termination
        -: 1307:        #endif
        -: 1308:        #endif
    #####: 1309:        mps->pattern_lengths[i] = len;
    #####: 1310:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1311:        
        -: 1312:        // Update first character lookup table
    #####: 1313:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1314:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1315:    }
        -: 1316:    
        -: 1317:    return mps;
        -: 1318:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1263:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1264:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1265:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1266:        return NULL;
        -: 1267:    }
        -: 1268:    
    #####: 1269:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1270:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1271:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1272:        return NULL;
        -: 1273:    }
        -: 1274:    
        -: 1275:    // Initialize structure
        -: 1276:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1277:    mps->pattern_count = count;
        -: 1278:    
        -: 1279:    // Copy patterns and build lookup tables
    #####: 1280:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1281:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1282:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1283:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1284:            return NULL;
        -: 1285:        }
        -: 1286:        
    #####: 1287:        size_t len = strlen(patterns[i]);
    #####: 1288:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1289:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1290:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1291:            return NULL;
        -: 1292:        }
        -: 1293:        
        -: 1294:        // Copy pattern safely with bounds checking
        -: 1295:        #ifdef _MSC_VER
        -: 1296:        // Use Windows-safe version
        -: 1297:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1298:        #else
        -: 1299:        // POSIX version
        -: 1300:        #ifdef _MSC_VER
        -: 1301:        // Use Windows-safe version
        -: 1302:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1303:        #else
        -: 1304:        // POSIX version
    #####: 1305:        strncpy(mps->patterns[i], patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
    #####: 1306:        mps->patterns[i][MERCURY_MAX_PATTERN_LENGTH - 1] = '\0';  // Ensure null termination
        -: 1307:        #endif
        -: 1308:        #endif
    #####: 1309:        mps->pattern_lengths[i] = len;
    #####: 1310:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1311:        
        -: 1312:        // Update first character lookup table
    #####: 1313:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1314:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1315:    }
        -: 1316:    
        -: 1317:    return mps;
        -: 1318:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1263:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1264:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1265:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1266:        return NULL;
        -: 1267:    }
        -: 1268:    
    #####: 1269:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1270:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1271:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1272:        return NULL;
        -: 1273:    }
        -: 1274:    
        -: 1275:    // Initialize structure
        -: 1276:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1277:    mps->pattern_count = count;
        -: 1278:    
        -: 1279:    // Copy patterns and build lookup tables
    #####: 1280:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1281:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1282:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1283:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1284:            return NULL;
        -: 1285:        }
        -: 1286:        
    #####: 1287:        size_t len = strlen(patterns[i]);
    #####: 1288:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1289:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1290:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1291:            return NULL;
        -: 1292:        }
        -: 1293:        
        -: 1294:        // Copy pattern safely with bounds checking
        -: 1295:        #ifdef _MSC_VER
        -: 1296:        // Use Windows-safe version
        -: 1297:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1298:        #else
        -: 1299:        // POSIX version
        -: 1300:        #ifdef _MSC_VER
        -: 1301:        // Use Windows-safe version
        -: 1302:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1303:        #else
        -: 1304:        // POSIX version
    #####: 1305:        strncpy(mps->patterns[i], patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
    #####: 1306:        mps->patterns[i][MERCURY_MAX_PATTERN_LENGTH - 1] = '\0';  // Ensure null termination
        -: 1307:        #endif
        -: 1308:        #endif
    #####: 1309:        mps->pattern_lengths[i] = len;
    #####: 1310:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1311:        
        -: 1312:        // Update first character lookup table
    #####: 1313:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1314:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1315:    }
        -: 1316:    
        -: 1317:    return mps;
        -: 1318:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1263:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1264:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1265:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1266:        return NULL;
        -: 1267:    }
        -: 1268:    
    #####: 1269:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1270:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1271:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1272:        return NULL;
        -: 1273:    }
        -: 1274:    
        -: 1275:    // Initialize structure
        -: 1276:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1277:    mps->pattern_count = count;
        -: 1278:    
        -: 1279:    // Copy patterns and build lookup tables
    #####: 1280:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1281:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1282:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1283:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1284:            return NULL;
        -: 1285:        }
        -: 1286:        
    #####: 1287:        size_t len = strlen(patterns[i]);
    #####: 1288:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1289:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1290:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1291:            return NULL;
        -: 1292:        }
        -: 1293:        
        -: 1294:        // Copy pattern safely with bounds checking
        -: 1295:        #ifdef _MSC_VER
        -: 1296:        // Use Windows-safe version
        -: 1297:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1298:        #else
        -: 1299:        // POSIX version
        -: 1300:        #ifdef _MSC_VER
        -: 1301:        // Use Windows-safe version
        -: 1302:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1303:        #else
        -: 1304:        // POSIX version
    #####: 1305:        strncpy(mps->patterns[i], patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
    #####: 1306:        mps->patterns[i][MERCURY_MAX_PATTERN_LENGTH - 1] = '\0';  // Ensure null termination
        -: 1307:        #endif
        -: 1308:        #endif
    #####: 1309:        mps->pattern_lengths[i] = len;
    #####: 1310:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1311:        
        -: 1312:        // Update first character lookup table
    #####: 1313:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1314:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1315:    }
        -: 1316:    
        -: 1317:    return mps;
        -: 1318:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1263:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1264:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1265:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1266:        return NULL;
        -: 1267:    }
        -: 1268:    
    #####: 1269:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1270:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1271:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1272:        return NULL;
        -: 1273:    }
        -: 1274:    
        -: 1275:    // Initialize structure
        -: 1276:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1277:    mps->pattern_count = count;
        -: 1278:    
        -: 1279:    // Copy patterns and build lookup tables
    #####: 1280:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1281:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1282:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1283:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1284:            return NULL;
        -: 1285:        }
        -: 1286:        
    #####: 1287:        size_t len = strlen(patterns[i]);
    #####: 1288:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1289:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1290:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1291:            return NULL;
        -: 1292:        }
        -: 1293:        
        -: 1294:        // Copy pattern safely with bounds checking
        -: 1295:        #ifdef _MSC_VER
        -: 1296:        // Use Windows-safe version
        -: 1297:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1298:        #else
        -: 1299:        // POSIX version
        -: 1300:        #ifdef _MSC_VER
        -: 1301:        // Use Windows-safe version
        -: 1302:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1303:        #else
        -: 1304:        // POSIX version
    #####: 1305:        strncpy(mps->patterns[i], patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
    #####: 1306:        mps->patterns[i][MERCURY_MAX_PATTERN_LENGTH - 1] = '\0';  // Ensure null termination
        -: 1307:        #endif
        -: 1308:        #endif
    #####: 1309:        mps->pattern_lengths[i] = len;
    #####: 1310:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1311:        
        -: 1312:        // Update first character lookup table
    #####: 1313:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1314:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1315:    }
        -: 1316:    
        -: 1317:    return mps;
        -: 1318:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1263:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1264:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1265:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1266:        return NULL;
        -: 1267:    }
        -: 1268:    
    #####: 1269:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1270:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1271:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1272:        return NULL;
        -: 1273:    }
        -: 1274:    
        -: 1275:    // Initialize structure
        -: 1276:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1277:    mps->pattern_count = count;
        -: 1278:    
        -: 1279:    // Copy patterns and build lookup tables
    #####: 1280:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1281:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1282:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1283:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1284:            return NULL;
        -: 1285:        }
        -: 1286:        
    #####: 1287:        size_t len = strlen(patterns[i]);
    #####: 1288:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1289:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1290:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1291:            return NULL;
        -: 1292:        }
        -: 1293:        
        -: 1294:        // Copy pattern safely with bounds checking
        -: 1295:        #ifdef _MSC_VER
        -: 1296:        // Use Windows-safe version
        -: 1297:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1298:        #else
        -: 1299:        // POSIX version
        -: 1300:        #ifdef _MSC_VER
        -: 1301:        // Use Windows-safe version
        -: 1302:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1303:        #else
        -: 1304:        // POSIX version
    #####: 1305:        strncpy(mps->patterns[i], patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
    #####: 1306:        mps->patterns[i][MERCURY_MAX_PATTERN_LENGTH - 1] = '\0';  // Ensure null termination
        -: 1307:        #endif
        -: 1308:        #endif
    #####: 1309:        mps->pattern_lengths[i] = len;
    #####: 1310:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1311:        
        -: 1312:        // Update first character lookup table
    #####: 1313:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1314:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1315:    }
        -: 1316:    
        -: 1317:    return mps;
        -: 1318:}
------------------
mercury_multi_pattern_create:
function mercury_multi_pattern_create called 0 returned 0% blocks executed 0%
    #####: 1263:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
    #####: 1264:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1265:        MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Invalid patterns or count");
    #####: 1266:        return NULL;
        -: 1267:    }
        -: 1268:    
    #####: 1269:    MercuryMultiPatternSearch* mps = mercury_aligned_alloc(sizeof(MercuryMultiPatternSearch), 64);
call    0 never executed
    #####: 1270:    if (!mps) {
branch  0 never executed
branch  1 never executed
    #####: 1271:        MERCURY_SET_ERROR(MERCURY_ERROR_OUT_OF_MEMORY, "Failed to allocate multi-pattern search");
    #####: 1272:        return NULL;
        -: 1273:    }
        -: 1274:    
        -: 1275:    // Initialize structure
        -: 1276:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
    #####: 1277:    mps->pattern_count = count;
        -: 1278:    
        -: 1279:    // Copy patterns and build lookup tables
    #####: 1280:    for (size_t i = 0; i < count; i++) {
branch  0 never executed
branch  1 never executed
    #####: 1281:        if (!patterns[i]) {
branch  0 never executed
branch  1 never executed
    #####: 1282:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1283:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "NULL pattern in array");
    #####: 1284:            return NULL;
        -: 1285:        }
        -: 1286:        
    #####: 1287:        size_t len = strlen(patterns[i]);
    #####: 1288:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
branch  0 never executed
branch  1 never executed
    #####: 1289:            mercury_aligned_free(mps);
call    0 never executed
    #####: 1290:            MERCURY_SET_ERROR(MERCURY_ERROR_INVALID_ARGUMENT, "Pattern length out of range");
    #####: 1291:            return NULL;
        -: 1292:        }
        -: 1293:        
        -: 1294:        // Copy pattern safely with bounds checking
        -: 1295:        #ifdef _MSC_VER
        -: 1296:        // Use Windows-safe version
        -: 1297:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1298:        #else
        -: 1299:        // POSIX version
        -: 1300:        #ifdef _MSC_VER
        -: 1301:        // Use Windows-safe version
        -: 1302:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1303:        #else
        -: 1304:        // POSIX version
    #####: 1305:        strncpy(mps->patterns[i], patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
    #####: 1306:        mps->patterns[i][MERCURY_MAX_PATTERN_LENGTH - 1] = '\0';  // Ensure null termination
        -: 1307:        #endif
        -: 1308:        #endif
    #####: 1309:        mps->pattern_lengths[i] = len;
    #####: 1310:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1311:        
        -: 1312:        // Update first character lookup table
    #####: 1313:        uint8_t first_char = (uint8_t)patterns[i][0];
    #####: 1314:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1315:    }
        -: 1316:    
        -: 1317:    return mps;
        -: 1318:}
------------------
        -: 1319:
       5*: 1320:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
       5*: 1321:    if (mps) {
       5*: 1322:        mercury_aligned_free(mps);
        -: 1323:    }
       5*: 1324:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1320:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1321:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1322:        mercury_aligned_free(mps);
call    0 never executed
        -: 1323:    }
    #####: 1324:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 3 returned 100% blocks executed 100%
        3: 1320:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
        3: 1321:    if (mps) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        3: 1322:        mercury_aligned_free(mps);
call    0 returned 100%
        -: 1323:    }
        3: 1324:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1320:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1321:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1322:        mercury_aligned_free(mps);
call    0 never executed
        -: 1323:    }
    #####: 1324:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 2 returned 100% blocks executed 100%
        2: 1320:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
        2: 1321:    if (mps) {
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2: 1322:        mercury_aligned_free(mps);
call    0 returned 100%
        -: 1323:    }
        2: 1324:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1320:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1321:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1322:        mercury_aligned_free(mps);
call    0 never executed
        -: 1323:    }
    #####: 1324:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1320:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1321:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1322:        mercury_aligned_free(mps);
call    0 never executed
        -: 1323:    }
    #####: 1324:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1320:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1321:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1322:        mercury_aligned_free(mps);
call    0 never executed
        -: 1323:    }
    #####: 1324:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1320:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1321:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1322:        mercury_aligned_free(mps);
call    0 never executed
        -: 1323:    }
    #####: 1324:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1320:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1321:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1322:        mercury_aligned_free(mps);
call    0 never executed
        -: 1323:    }
    #####: 1324:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1320:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1321:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1322:        mercury_aligned_free(mps);
call    0 never executed
        -: 1323:    }
    #####: 1324:}
------------------
mercury_multi_pattern_destroy:
function mercury_multi_pattern_destroy called 0 returned 0% blocks executed 0%
    #####: 1320:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
    #####: 1321:    if (mps) {
branch  0 never executed
branch  1 never executed
    #####: 1322:        mercury_aligned_free(mps);
call    0 never executed
        -: 1323:    }
    #####: 1324:}
------------------
        -: 1325:
        -: 1326:/**
        -: 1327: * @brief Search for multiple patterns in text
        -: 1328: * 
        -: 1329: * @details Finds the leftmost occurrence of any pattern in the text.
        -: 1330: * 
        -: 1331: * @param mps Multi-pattern search structure
        -: 1332: * @param text Text to search in
        -: 1333: * @param text_len Length of text
        -: 1334: * @param[out] pattern_id Index of matched pattern (set on success)
        -: 1335: * @return Index of match in text or -1 if no patterns found
        -: 1336: * 
        -: 1337: * @note Thread-safe for concurrent searches with same mps
        -: 1338: */
       6*: 1339:int mercury_multi_pattern_search_simd(const MercuryMultiPatternSearch* mps, const char* text, 
        -: 1340:                                     size_t text_len, int* pattern_id) {
       6*: 1341:    if (!mps || !text || !pattern_id || text_len == 0) {
        -: 1342:        return -1;
        -: 1343:    }
        -: 1344:    
       6*: 1345:    *pattern_id = -1;
        -: 1346:    
        -: 1347:    // Smart multi-pattern search using optimized strstr
        -: 1348:    // Find the leftmost match across all patterns
        -: 1349:    int best_position = -1;
        -: 1350:    int best_pattern = -1;
        -: 1351:    
        -: 1352:    // Use highly optimized strstr for each pattern
      45*: 1353:    for (size_t p = 0; p < mps->pattern_count; p++) {
      39*: 1354:        const char* found = strstr(text, mps->patterns[p]);
        -: 1355:        
      39*: 1356:        if (found) {
      20*: 1357:            int pos = (int)(found - text);
      20*: 1358:            if (best_position == -1 || pos < best_position) {
        -: 1359:                best_position = pos;
       6*: 1360:                best_pattern = (int)p;
        -: 1361:            }
        -: 1362:        }
        -: 1363:    }
        -: 1364:    
       6*: 1365:    if (best_position >= 0) {
       5*: 1366:        *pattern_id = best_pattern;
       5*: 1367:        return best_position;
        -: 1368:    }
        -: 1369:    
        -: 1370:    return -1;  // No patterns found
        -: 1371:}
        -: 1372:
        -: 1373:#else
        -: 1374:// Fallback implementations when SIMD is not available
        -: 1375:void mercury_memcpy_simd(void* dest, const void* src, size_t size) {
        -: 1376:    memcpy(dest, src, size);
        -: 1377:}
        -: 1378:
        -: 1379:int mercury_string_search_simd(const char* text, size_t text_len, const char* pattern, size_t pattern_len) {
        -: 1380:    const char* found = strstr(text, pattern);
        -: 1381:    return found ? (int)(found - text) : -1;
        -: 1382:}
        -: 1383:
        -: 1384:// Multi-pattern search fallback implementation
        -: 1385:MercuryMultiPatternSearch* mercury_multi_pattern_create(const char* patterns[], size_t count) {
        -: 1386:    if (!patterns || count == 0 || count > MERCURY_MAX_PATTERNS) {
        -: 1387:        return NULL;
        -: 1388:    }
        -: 1389:    
        -: 1390:    MercuryMultiPatternSearch* mps = malloc(sizeof(MercuryMultiPatternSearch));
        -: 1391:    if (!mps) return NULL;
        -: 1392:    
        -: 1393:    memset(mps, 0, sizeof(MercuryMultiPatternSearch));
        -: 1394:    mps->pattern_count = count;
        -: 1395:    
        -: 1396:    for (size_t i = 0; i < count; i++) {
        -: 1397:        if (!patterns[i]) {
        -: 1398:            free(mps);
        -: 1399:            return NULL;
        -: 1400:        }
        -: 1401:        
        -: 1402:        size_t len = strlen(patterns[i]);
        -: 1403:        if (len == 0 || len >= MERCURY_MAX_PATTERN_LENGTH) {
        -: 1404:            free(mps);
        -: 1405:            return NULL;
        -: 1406:        }
        -: 1407:        
        -: 1408:        #ifdef _MSC_VER
        -: 1409:        // Use Windows-safe version
        -: 1410:        strncpy_s(mps->patterns[i], MERCURY_MAX_PATTERN_LENGTH, patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1411:        #else
        -: 1412:        // POSIX version
        -: 1413:        strncpy(mps->patterns[i], patterns[i], MERCURY_MAX_PATTERN_LENGTH - 1);
        -: 1414:        mps->patterns[i][MERCURY_MAX_PATTERN_LENGTH - 1] = '\0';  // Ensure null termination
        -: 1415:        #endif
        -: 1416:        mps->pattern_lengths[i] = len;
        -: 1417:        mps->first_chars[i] = (uint8_t)patterns[i][0];
        -: 1418:        
        -: 1419:        uint8_t first_char = (uint8_t)patterns[i][0];
        -: 1420:        mps->pattern_masks[first_char] |= (1U << i);
        -: 1421:    }
        -: 1422:    
        -: 1423:    return mps;
        -: 1424:}
        -: 1425:
        -: 1426:void mercury_multi_pattern_destroy(MercuryMultiPatternSearch* mps) {
        -: 1427:    if (mps) {
        -: 1428:        free(mps);
        -: 1429:    }
        -: 1430:}
        -: 1431:
        -: 1432:/**
        -: 1433: * @brief Search for multiple patterns in text
        -: 1434: * 
        -: 1435: * @details Finds the leftmost occurrence of any pattern in the text.
        -: 1436: * 
        -: 1437: * @param mps Multi-pattern search structure
        -: 1438: * @param text Text to search in
        -: 1439: * @param text_len Length of text
        -: 1440: * @param[out] pattern_id Index of matched pattern (set on success)
        -: 1441: * @return Index of match in text or -1 if no patterns found
        -: 1442: * 
        -: 1443: * @note Thread-safe for concurrent searches with same mps
        -: 1444: */
        -: 1445:int mercury_multi_pattern_search_simd(const MercuryMultiPatternSearch* mps, const char* text, 
        -: 1446:                                     size_t text_len, int* pattern_id) {
        -: 1447:    if (!mps || !text || !pattern_id || text_len == 0) {
        -: 1448:        return -1;
        -: 1449:    }
        -: 1450:    
        -: 1451:    *pattern_id = -1;
        -: 1452:    
        -: 1453:    // Fallback using optimized strstr
        -: 1454:    int best_position = -1;
        -: 1455:    int best_pattern = -1;
        -: 1456:    
        -: 1457:    for (size_t p = 0; p < mps->pattern_count; p++) {
        -: 1458:        const char* found = strstr(text, mps->patterns[p]);
        -: 1459:        
        -: 1460:        if (found) {
        -: 1461:            int pos = (int)(found - text);
        -: 1462:            if (best_position == -1 || pos < best_position) {
        -: 1463:                best_position = pos;
        -: 1464:                best_pattern = (int)p;
        -: 1465:            }
        -: 1466:        }
        -: 1467:    }
        -: 1468:    
        -: 1469:    if (best_position >= 0) {
        -: 1470:        *pattern_id = best_pattern;
        -: 1471:        return best_position;
        -: 1472:    }
        -: 1473:    
        -: 1474:    return -1;  // No patterns found
        -: 1475:}
        -: 1476:#endif

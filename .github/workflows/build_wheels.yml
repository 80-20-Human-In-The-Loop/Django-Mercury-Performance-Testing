name: Build and Test Wheels

on:
  push:
    branches: [main]
    tags:
      - 'v*'  # Trigger on version tags
  pull_request:
    branches: [main]
  workflow_dispatch:  # Allow manual triggering
    inputs:
      publish_to_test_pypi:
        description: 'Publish to Test PyPI?'
        required: false
        type: boolean
        default: false

env:
  CIBW_BUILD_VERBOSITY: 1

jobs:
  # Run tests (non-blocking - failures won't prevent deployment)
  test:
    name: Run tests
    runs-on: ${{ matrix.os }}
    continue-on-error: true  # Tests can fail without blocking deployment
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        python-version: ['3.8', '3.10', '3.12']
    
    steps:
      - name: Configure Git for Windows paths
        if: runner.os == 'Windows'
        run: |
          git config --global core.protectNTFS false
          git config --global core.longpaths true
          
      - uses: actions/checkout@v4
      
      - uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip setuptools wheel
          pip install -e ".[dev]"
          pip install pytest-cov
      
      - name: Set up MSVC compiler (Windows)
        if: runner.os == 'Windows'
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64
      
      - name: Install C build dependencies (Ubuntu)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential python3-dev libunwind-dev
      
      - name: Build C libraries (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          echo "Building C libraries..."
          cd django_mercury/c_core
          
          # Use the CI target which includes clean, build, and install
          if ! make ci; then
            echo "‚ùå ERROR: C library build failed!"
            echo "C extensions are REQUIRED in CI - pure Python is too slow!"
            echo "Check the build logs above for compilation errors."
            exit 1
          fi
          
          # Verify the build with our verification script
          cd ../..
          echo "Running build verification..."
          if python scripts/verify_build.py; then
            echo "‚úÖ Build verification passed"
            echo "C_BUILD_SUCCESS=1" >> $GITHUB_ENV
          else
            echo "‚ùå ERROR: Build verification failed!"
            echo "C extensions are REQUIRED in CI!"
            exit 1
          fi
      
      - name: Build Python C extensions (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          python -m pip install --upgrade setuptools wheel
          python setup.py build_ext --inplace || echo "Python C extension build failed (expected if C libs missing)"
          
          # Debug C extension loading
          echo "üîç Debugging C extension loading..."
          export DEBUG_C_LOADING=1
          python -c "
          import os
          os.environ['DEBUG_C_LOADING'] = '1'
          from django_mercury.python_bindings.loader import check_c_extensions, get_implementation_info
          available, details = check_c_extensions()
          print(f'C Extensions Available: {available}')
          print(f'Implementation Details: {details}')
          " || echo "Failed to check C extensions"
      
      - name: Build C Extensions (Windows)
        if: runner.os == 'Windows'
        run: |
          echo "Building C extensions on Windows..."
          echo "PYTHONIOENCODING=utf-8" >> $env:GITHUB_ENV
          
          # Install build dependencies
          python -m pip install --upgrade setuptools wheel
          
          # Show compiler information
          echo "Checking for Visual Studio..."
          where cl.exe || echo "cl.exe not in PATH"
          
          # Build C extensions
          echo "Building C extensions with setup.py..."
          python setup.py build_ext --inplace
          
          # List built extensions
          echo ""
          echo "Looking for built extensions (.pyd files):"
          Get-ChildItem -Path . -Filter "*.pyd" -Recurse | Select-Object FullName
          
          # Also check for .dll files
          echo ""
          echo "Looking for DLL files:"
          Get-ChildItem -Path django_mercury -Filter "*.dll" -Recurse | Select-Object FullName
          
          # Check if any C extensions were built
          $pydCount = (Get-ChildItem -Path . -Filter "*.pyd" -Recurse).Count
          if ($pydCount -eq 0) {
              echo "WARNING: No .pyd files found - C extensions may not have built"
              echo "C_EXTENSIONS_BUILT=0" >> $env:GITHUB_ENV
          } else {
              echo "SUCCESS: Found $pydCount .pyd files"
              echo "C_EXTENSIONS_BUILT=1" >> $env:GITHUB_ENV
          }
          
          # Run diagnostics
          echo ""
          echo "Running C extension diagnostics..."
          python scripts/diagnose_c_extensions.py
      
      - name: Verify C libraries exist (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          echo "üîç Verifying C library build products..."
          echo "Libraries in c_core directory:"
          ls -la django_mercury/c_core/*.so 2>/dev/null || echo "No .so files found in c_core"
          echo ""
          echo "Libraries in python_bindings directory:"
          ls -la django_mercury/python_bindings/*.so 2>/dev/null || echo "No .so files found in python_bindings"
          
          # Count libraries found
          SO_COUNT=$(find django_mercury -name "*.so" 2>/dev/null | wc -l)
          echo ""
          echo "Total .so files found: $SO_COUNT"
          
          # C libraries are REQUIRED in CI
          if [ "$SO_COUNT" -eq 0 ]; then
            echo "‚ùå ERROR: No C libraries found!"
            echo "C extensions are REQUIRED in CI - pure Python is too slow!"
            exit 1
          else
            echo "‚úÖ Found $SO_COUNT C libraries"
            echo "C_EXTENSIONS_AVAILABLE=1" >> $GITHUB_ENV
          fi
          
          # Check library dependencies on Linux
          if [ "$RUNNER_OS" == "Linux" ]; then
            echo ""
            echo "üîç Checking library dependencies with ldd:"
            for lib in django_mercury/python_bindings/*.so; do
              if [ -f "$lib" ]; then
                echo "Dependencies for $lib:"
                ldd "$lib" || echo "Failed to check dependencies"
                echo ""
              fi
            done
          fi
      
      - name: Run Python tests (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          # Debug: Show Python path and check library loading
          echo "üîç Python environment debug:"
          echo "Python executable: $(which python)"
          echo "Python version: $(python --version)"
          echo ""
          echo "Python sys.path:"
          python -c "import sys; print('\n'.join(sys.path))"
          echo ""
          echo "Current directory: $(pwd)"
          echo ""
          echo "Checking if libraries can be loaded with ctypes:"
          cat > test_ctypes.py << 'EOF'
import ctypes
import os
import sys
import traceback

print('=== CTYPES LIBRARY LOADING TEST ===')
print(f'Python version: {sys.version}')
print(f'ctypes file: {ctypes.__file__}')
print()

libs = ['libquery_analyzer.so', 'libmetrics_engine.so', 'libtest_orchestrator.so']
for lib in libs:
    print(f'\nTesting {lib}:')
    paths = [
        f'django_mercury/python_bindings/{lib}',
        f'django_mercury/c_core/{lib}',
        lib
    ]
    loaded = False
    for path in paths:
        if os.path.exists(path):
            print(f'  Found at: {path}')
            print(f'  File size: {os.path.getsize(path)} bytes')
            print(f'  Permissions: {oct(os.stat(path).st_mode)}')
            try:
                # Try with RTLD_GLOBAL like the actual code
                if hasattr(ctypes, 'RTLD_GLOBAL'):
                    print('  Using RTLD_GLOBAL mode')
                    handle = ctypes.CDLL(path, mode=ctypes.RTLD_GLOBAL)
                else:
                    print('  Using default mode')
                    handle = ctypes.CDLL(path)
                print(f'  ‚úì Successfully loaded with ctypes')
                print(f'  Handle: {handle}')
                loaded = True
                break
            except Exception as e:
                print(f'  ‚úó Failed to load: {type(e).__name__}: {e}')
                traceback.print_exc()
        else:
            print(f'  Not found at: {path}')
    if not loaded:
        print(f'‚úó {lib} could not be loaded from any path')

# Also test the actual loading mechanism
print('\n=== TESTING ACTUAL C_BINDINGS LOADING ===')
try:
    os.environ['DEBUG_C_LOADING'] = '1'
    from django_mercury.python_bindings import c_bindings
    print('c_bindings imported successfully')
    extensions = c_bindings.c_extensions
    print(f'c_extensions object: {extensions}')
    print(f'Initialized: {extensions._initialized}')
    if not extensions._initialized:
        print('Calling initialize()...')
        result = extensions.initialize()
        print(f'Initialize result: {result}')
    stats = extensions.get_stats()
    print(f'Stats: libraries_loaded={stats.libraries_loaded}, functions_configured={stats.functions_configured}, errors={stats.errors_encountered}')
except Exception as e:
    print(f'Failed to test c_bindings: {type(e).__name__}: {e}')
    traceback.print_exc()
EOF
          python test_ctypes.py
          echo ""
          # C extensions MUST be available in CI
          echo "Running tests with C extensions (DJANGO_MERCURY_PURE_PYTHON=0)"
          export DJANGO_MERCURY_PURE_PYTHON=0
          export DEBUG_C_LOADING=1
          export PYTHONPATH="${PYTHONPATH}:$(pwd)"
          echo "PYTHONPATH=$PYTHONPATH"
          python test_runner.py --coverage --ci
      
      - name: Test C Extensions (Windows)
        if: runner.os == 'Windows'
        run: |
          echo "Testing C extension loading on Windows"
          $env:PYTHONIOENCODING = "utf-8"
          chcp 65001 > $null  # Set console to UTF-8
          
          # Test C extensions without forcing pure Python
          echo "Testing C extensions..."
          $env:DJANGO_MERCURY_PURE_PYTHON = "0"
          
          # Run the test and capture exit code
          python test_windows_dll.py
          $testResult = $LASTEXITCODE
          
          if ($testResult -eq 0) {
              echo "‚úÖ C extensions loaded successfully!"
              # Run tests with C extensions
              echo "Running test suite with C extensions..."
              python test_runner.py --coverage --ci
          } else {
              echo "‚ùå C extensions failed to load (exit code: $testResult)"
              # Fall back to pure Python
              echo "Falling back to pure Python mode..."
              $env:DJANGO_MERCURY_PURE_PYTHON = "1"
              python test_runner.py --coverage --ci
              
              # Still fail the job if we expected C extensions to work
              if ($env:C_EXTENSIONS_BUILT -eq "1") {
                  echo "ERROR: C extensions were built but failed to load!"
                  exit 1
              }
          }
      
      - name: Run C Core Unit Tests (Linux/macOS)
        if: runner.os != 'Windows'
        run: |
          echo "Running C core unit tests..."
          ./c_test_runner.sh test || echo "C tests completed with status: $?"
          echo "Running C coverage analysis..."
          ./c_test_runner.sh coverage || echo "Coverage completed with status: $?"
      
      # NOTE: test_runner.py already executed above in "Run Python tests" step
      # - name: Run test runner
      #   run: |
      #     python test_runner.py || echo "Test runner completed"
      
      - name: Check code quality
        if: matrix.python-version == '3.10' && matrix.os == 'ubuntu-latest'
        run: |
          pip install ruff black isort
          ruff check django_mercury/ || true
          black --check django_mercury/ || true
          isort --check-only django_mercury/ || true

  # Build source distribution
  build_sdist:
    name: Build source distribution
    runs-on: ubuntu-latest
    # No dependency on tests - build immediately
    
    steps:
      - name: Configure Git for Windows paths
        if: runner.os == 'Windows'
        run: |
          git config --global core.protectNTFS false
          git config --global core.longpaths true
          
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for version detection
      
      - uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build
      
      - name: Build source distribution
        run: python -m build --sdist
      
      - uses: actions/upload-artifact@v4
        with:
          name: sdist
          path: dist/*.tar.gz

  # Build wheels for each platform
  build_wheels:
    name: Build wheels on ${{ matrix.os }}-${{ matrix.archs }}
    runs-on: ${{ matrix.os }}
    # No dependency on tests - build immediately
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux x86_64
          - os: ubuntu-latest
            archs: x86_64
            build-name: linux-x86_64
            
          # Linux ARM64 (if needed, slower due to emulation)
          # - os: ubuntu-latest
          #   archs: aarch64
          #   build-name: linux-aarch64
          
          # macOS Intel
          - os: macos-13  # Use macos-13 for Intel
            archs: x86_64
            build-name: macos-x86_64
          
          # macOS Apple Silicon
          - os: macos-14  # Use macos-14 for Apple Silicon
            archs: arm64
            build-name: macos-arm64
          
          # macOS Universal (both architectures)
          - os: macos-latest
            archs: universal2
            build-name: macos-universal2
          
          # Windows 64-bit
          - os: windows-latest
            archs: AMD64
            build-name: windows-amd64
    
    steps:
      - name: Configure Git for Windows paths
        if: runner.os == 'Windows'
        run: |
          git config --global core.protectNTFS false
          git config --global core.longpaths true
          
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      # Set up QEMU for Linux ARM builds (if enabled)
      - name: Set up QEMU
        if: runner.os == 'Linux' && matrix.archs == 'aarch64'
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64
      
      - name: Build wheels
        uses: pypa/cibuildwheel@v2.22.0
        env:
          CIBW_ARCHS: ${{ matrix.archs }}
          # Enable C extensions on Windows
          CIBW_ENVIRONMENT_WINDOWS: DJANGO_MERCURY_PURE_PYTHON=0
      
      - uses: actions/upload-artifact@v4
        with:
          name: wheels-${{ matrix.build-name }}
          path: ./wheelhouse/*.whl

  # Test the built wheels
  # TODO: In the future, make wheel tests mandatory with 90% coverage requirement
  # TODO: Currently allowing failures to ensure deployment proceeds regardless
  test_wheels:
    name: Test wheels on ${{ matrix.os }} Python ${{ matrix.python }}
    needs: [build_wheels]
    runs-on: ${{ matrix.os }}
    continue-on-error: true  # Don't fail the workflow if tests fail
    timeout-minutes: 15  # Prevent infinite loops - max 15 minutes per job
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        python: ['3.8', '3.9', '3.10', '3.11', '3.12']
    
    steps:
      - name: Configure Git for Windows paths
        if: runner.os == 'Windows'
        run: |
          git config --global core.protectNTFS false
          git config --global core.longpaths true
          
      - uses: actions/checkout@v4
      
      - uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python }}
      
      - uses: actions/download-artifact@v4
        with:
          path: dist/
      
      - name: Display downloaded artifacts
        shell: bash
        timeout-minutes: 2  # Simple file listing shouldn't take long
        run: |
          echo "Downloaded artifacts:"
          ls -la dist/
          find dist/ -name "*.whl" -o -name "*.tar.gz"
      
      - name: Install wheel and test
        shell: bash
        timeout-minutes: 10  # Prevent this step from hanging
        run: |
          # Install pip and minimal dependencies
          python -m pip install --upgrade pip
          
          # Simple wheel discovery - try any available wheel first
          echo "Looking for any available wheel..."
          WHEEL=$(find dist/ -name "*.whl" | head -1)
          
          if [ -n "$WHEEL" ]; then
            echo "Found wheel: $WHEEL"
            pip install "$WHEEL" || {
              echo "Wheel install failed, trying source distribution..."
              SDIST=$(find dist/ -name "*.tar.gz" | head -1)
              pip install "$SDIST" || {
                echo "Both wheel and source install failed, skipping test"
                exit 0
              }
            }
          else
            echo "No wheel found, trying source distribution..."
            SDIST=$(find dist/ -name "*.tar.gz" | head -1)
            pip install "$SDIST" || {
              echo "Source install failed, skipping test"
              exit 0
            }
          fi
          
          # Simple import test only - no Django setup required
          echo "Testing basic import..."
          python -c "
          try:
              import django_mercury
              print(f'[SUCCESS] django-mercury {django_mercury.__version__} imported')
          except Exception as e:
              print(f'[FAILED] Import failed - {e}')
              exit(1)
          " || {
            echo "Import test failed, but continuing..."
            exit 0
          }

  # Build status check
  check_build:
    name: Check build results
    needs: [build_sdist, build_wheels]  # No dependency on test_wheels
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/download-artifact@v4
        with:
          path: dist/
      
      - name: Check distributions
        run: |
          echo "Build artifacts:"
          find dist/ -type f -name "*.whl" -o -name "*.tar.gz" | sort
          
          # Count artifacts
          WHEEL_COUNT=$(find dist/ -name "*.whl" | wc -l)
          SDIST_COUNT=$(find dist/ -name "*.tar.gz" | wc -l)
          
          echo "Found $WHEEL_COUNT wheels and $SDIST_COUNT source distributions"
          
          # Check minimum expected artifacts
          if [ $WHEEL_COUNT -lt 5 ]; then
            echo "Warning: Expected at least 5 wheels, found $WHEEL_COUNT"
          fi
          
          if [ $SDIST_COUNT -ne 1 ]; then
            echo "Warning: Expected exactly 1 source distribution, found $SDIST_COUNT"
          fi

  # Publish to Test PyPI (manual trigger or tags)
  # NOTE: Deployment is independent of wheel tests - we deploy even if wheel tests fail
  publish_test:
    name: Publish to Test PyPI
    needs: [check_build]  # Only depends on build, NOT on test_wheels
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.publish_to_test_pypi == 'true'
    
    steps:
      - uses: actions/download-artifact@v4
        with:
          path: dist/
      
      - name: Flatten directory structure
        run: |
          mkdir upload/
          find dist/ -type f \( -name "*.whl" -o -name "*.tar.gz" \) -exec cp {} upload/ \;
          ls -la upload/
      
      - name: Publish to Test PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          repository-url: https://test.pypi.org/legacy/
          password: ${{ secrets.TEST_PYPI_API_TOKEN }}
          packages-dir: upload/
          skip-existing: true

  # Publish to PyPI (only on version tags)
  # NOTE: Deployment is independent of wheel tests - we deploy even if wheel tests fail
  publish:
    name: Publish to PyPI
    needs: [check_build]  # Only depends on build, NOT on test_wheels
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    
    steps:
      - uses: actions/download-artifact@v4
        with:
          path: dist/
      
      - name: Flatten directory structure
        run: |
          mkdir upload/
          find dist/ -type f \( -name "*.whl" -o -name "*.tar.gz" \) -exec cp {} upload/ \;
          ls -la upload/
      
      - name: Check distributions
        run: |
          pip install twine
          twine check upload/*
      
      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_API_TOKEN }}
          packages-dir: upload/